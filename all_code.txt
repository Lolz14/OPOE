./src/main.cpp
#include <Eigen/Dense>
#include <Eigen/Sparse>
#include <iomanip>
#include "../include/sde/FinModels.hpp"
#include <iostream>
#include <cmath>
#include <stdexcept>
#include <vector>
#include <memory>
#include <limits>
#include <functional>
#include <cassert>
#include <algorithm>
#include <type_traits>
#include "../include/polynomials/OrthogonalPolynomials.hpp"
#include "../include/utils/Utils.hpp"
#include "../include/options/OPEOptionPricer.hpp"
#include "../include/options/FFTOptionPricer.hpp"
#include "../include/options/MCOptionPricer.hpp"

using namespace SDE;
using namespace options;

using Eigen::MatrixXd;
using StoringVector = Eigen::VectorXd;


int main() {
    const unsigned int N = 5; // total degree



    StoringVector x0(2);

    x0 << 0.20, std::log(100.0);
    using R = double;

    auto hull_model = std::make_shared<HestonModelSDE<R>>(0.04, 2.0, 0.10, 0.3, -0.7, x0);


    OPEOptionPricer<R, N> ope_pricer(1.0, 0.05, std::make_unique<EuropeanPutPayoff<R>>(100.0), hull_model, 
    traits::SolverType::EulerMaruyama);

    std::cout << "Option Price OPE: " << ope_pricer.price() << std::endl;

    std::cout << "Option Price FFT: " << FFTOptionPricer<R>(1.0, 0.05, std::make_unique<EuropeanPutPayoff<R>>(100.0), hull_model).price() << std::endl;

    std::cout << "Option Price MC: " << MCOptionPricer<R>(1.0, 0.05, std::make_unique<EuropeanPutPayoff<R>>(100.0), hull_model, traits::SolverType::EulerMaruyama, 1000, 100 ).price() << std::endl;


   

  
}
./bindings/bindings.cpp

/*
    bindings.cpp - Pybind11 bindings for stochastic volatility SDE models, solvers, and option pricers.

    This module exposes C++ classes and functions to Python, enabling the use of advanced stochastic differential equation (SDE) models,
    numerical solvers, and option pricing engines in Python workflows. The bindings are designed for flexibility and extensibility,
    supporting multiple models, solvers, and pricer types.

    Main Features:
    --------------
    - SDE Models:
        * Heston, Hull-White, Stein-Stein, Jacobi, and Geometric Brownian Motion models.
        * All models inherit from a common ISDEModel interface.
        * Model parameters and state dimensions are accessible from Python.

    - SDE Solvers:
        * Euler-Maruyama, Milstein, and Interpolated Kahl-Jackel solvers.
        * Generic binding for solver classes, supporting custom SDE models.
        * Solvers can simulate SDE paths with optional user-supplied Brownian increments.

    - Option Payoffs:
        * Base IPayoff interface for extensibility.
        * European call and put payoffs with strike getter/setter and evaluation methods.

    - Option Pricers:
        * Monte Carlo (MCOptionPricer), FFT-based (FFTOptionPricer), and Operator Expansion (OPEOptionPricer) pricers.
        * OPEOptionPricer is templated for different expansion orders (N = 3, 5, 7, 9, 10).
        * All pricers accept model, payoff, and numerical method parameters.

    - Enumerations:
        * QuadratureMethod: TanhSinh, QAGI.
        * SolverType: EulerMaruyama, Milstein, IJK.

    Usage:
    ------
    Import the module in Python as `opoe` and instantiate models, solvers, payoffs, and pricers as needed.
    Example:
        import opoe
        model = opoe.HestonModel(...)
        payoff = opoe.EuropeanCallPayoff(K=100)
        pricer = opoe.MCOptionPricer(ttm=1.0, rate=0.05, payoff=payoff, model=model)
        price = pricer.price()

    Notes:
    ------
    - All numerical types (Real, Matrix, Vector) are defined via the traits system for flexibility.
    - Shared pointers are used for memory management and Python interoperability.
    - The bindings are designed to be extensible for additional models, solvers, and pricer types.

    Author: [Your Name or Organization]
    License: [Appropriate License]
*/
#include <pybind11/pybind11.h>
#include <pybind11/eigen.h>
#include <pybind11/stl.h>
#include <pybind11/functional.h>
#include <memory>
#include <optional>

#include "../include/sde/FinModels.hpp"              
#include "../include/options/MCOptionPricer.hpp"     
#include "../include/options/FFTOptionPricer.hpp"    
#include "../include/options/OPEOptionPricer.hpp"    
#include "../include/options/CFOptionPricer.hpp"    
#include "../include/options/Payoff.hpp"            
#include "../include/traits/OPOE_traits.hpp" 

namespace py = pybind11;

// Short-hands
using Real   = traits::DataType::PolynomialField; 
using Matrix = traits::DataType::StoringMatrix; 
using Vector = traits::DataType::StoringVector;

/**
 * @brief Helper function to expose a solver class to Python via pybind11.
 *
 * This function creates a Python binding for a given solver class by registering
 * it in the specified pybind11 module. It binds the constructor and the
 * `solve` method of the solver to Python.
 *
 * @tparam SolverClass  The concrete solver class to bind.
 * @param m             The pybind11 module where the class will be registered.
 * @param name          The name of the solver class in the Python module.
 *
 * The bound Python class provides:
 * - A constructor taking a reference to an SDE model (`SDE::ISDEModel<Real>`).
 * - A `solve` method that computes the SDE solution over a specified time interval.
 */
template <typename SolverClass>
void bind_solver(py::module_ &m, const char *name) {
    py::class_<SolverClass, std::shared_ptr<SolverClass>>(m, name)
        .def(py::init<SDE::ISDEModel<Real> &>(), py::arg("model"))
        .def("solve",
             [](SolverClass &self,
                Real t0, Real ttm,
                int num_steps, int num_paths,
                const std::optional<Matrix> &dW_opt) -> Matrix {
                 // Call the solve method of the specific solver instance
                 return self.solve(t0, ttm, num_steps, num_paths, dW_opt);
             },
             py::arg("t0"), py::arg("ttm"),
             py::arg("num_steps"), py::arg("num_paths"),
             py::arg("dW_opt") = std::nullopt,
             "Solves the SDE path over the given time interval.");
}

/**
 * @brief Helper function to expose an SDE model class to Python via pybind11.
 *
 * This function registers a model class in the given pybind11 module, binding
 * its constructor and common getter methods that are expected to be present
 * in all SDE models.
 *
 * @tparam ModelT   The concrete model class to bind. It must derive from
 *                  `SDE::ISDEModel<Real>` and implement the listed methods.
 * @param m         The pybind11 module where the class will be registered.
 * @param py_name   The name of the model class in the Python module.
 *
 * ### Bound constructor
 * - `__init__(v0: Real, kappa: Real, theta: Real, sigma: Real, rho: Real, x0: Vector)`  
 *   Creates a model with the specified parameters:
 *   - `v0` : Initial variance  
 *   - `kappa` : Mean-reversion speed  
 *   - `theta` : Long-term variance level  
 *   - `sigma` : Volatility of variance  
 *   - `rho` : Correlation between Brownian motions  
 *   - `x0` : Initial state vector
 *
 * ### Bound methods
 * - `get_x0() -> Vector` : Returns the initial state vector.  
 * - `get_v0() -> Real` : Returns the initial variance.  
 * - `get_kappa() -> Real` : Returns the mean-reversion speed.  
 * - `get_theta() -> Real` : Returns the long-term variance level.  
 * - `get_sigma_v() -> Real` : Returns the volatility of variance.  
 * - `get_correlation() -> Real` : Returns the correlation coefficient.  
 * - `state_dim() -> int` : Returns the state space dimension.  
 * - `wiener_dim() -> int` : Returns the Wiener process dimension.
 *
 * @note All bound methods must be implemented by the concrete `ModelT`.
 */
template <typename ModelT>
void bind_model(py::module_& m, const char* py_name) {
    py::class_<ModelT, SDE::ISDEModel<Real>, std::shared_ptr<ModelT>>(m, py_name)
        // generic constructor (adjust if not always valid)
        .def(py::init<Real, Real, Real, Real, Real, const Vector&>(),
             py::arg("v0"), py::arg("kappa"), py::arg("theta"),
             py::arg("sigma"), py::arg("rho"), py::arg("x0"))
        // common getters (these must exist in all models)
        .def("get_x0", py::overload_cast<>(&ModelT::get_x0, py::const_))
        .def("get_v0", py::overload_cast<>(&ModelT::get_v0, py::const_))
        .def("get_kappa", py::overload_cast<>(&ModelT::get_kappa, py::const_))
        .def("get_theta", py::overload_cast<>(&ModelT::get_theta, py::const_))
        .def("get_sigma_v", py::overload_cast<>(&ModelT::get_sigma_v, py::const_))
        .def("get_correlation", py::overload_cast<>(&ModelT::get_correlation, py::const_))
        .def("state_dim", &ModelT::state_dim)
        .def("wiener_dim", &ModelT::wiener_dim);
}


/**
 * @brief Bind the Geometric Brownian Motion (GBM) SDE model to Python.
 *
 * This specialization of `bind_model` exposes the 
 * `SDE::GeometricBrownianMotionSDE<Real>` class to Python using pybind11.
 *
 * @param m        The pybind11 module where the class will be registered.
 * @param py_name  The name of the model class in the Python module.
 *
 * ### Bound constructor
 * - `__init__(mu: Real, sigma: Real, x0: Real)`  
 *   Constructs a GBM model with:
 *   - `mu` : Drift parameter  
 *   - `sigma` : Volatility parameter  
 *   - `x0` : Initial state  
 *
 * ### Bound methods
 * - `get_x0() -> Real` : Returns the initial state.  
 * - `get_sigma() -> Real` : Returns the volatility parameter.  
 * - `get_mu() -> Real` : Returns the drift parameter.  
 * - `state_dim() -> int` : Returns the state space dimension (typically 1).  
 * - `wiener_dim() -> int` : Returns the Wiener process dimension (typically 1).
 *
 * @note This is a specialization of the `bind_model` template for the GBM SDE.
 */
template <>
void bind_model<SDE::GeometricBrownianMotionSDE<Real>>(py::module_& m, const char* py_name) {
    py::class_<SDE::GeometricBrownianMotionSDE<Real>, SDE::ISDEModel<Real>,
               std::shared_ptr<SDE::GeometricBrownianMotionSDE<Real>>>(m, py_name)
        .def(py::init<Real, Real, Real>(),
             py::arg("mu"), py::arg("sigma"), py::arg("x0"))
        .def("get_x0", py::overload_cast<>(&SDE::GeometricBrownianMotionSDE<Real>::get_x0, py::const_))
        .def("get_sigma", py::overload_cast<>(&SDE::GeometricBrownianMotionSDE<Real>::get_v0, py::const_))
        .def("get_mu", py::overload_cast<>(&SDE::GeometricBrownianMotionSDE<Real>::get_mu, py::const_))
        .def("state_dim", &SDE::GeometricBrownianMotionSDE<Real>::state_dim)
        .def("wiener_dim", &SDE::GeometricBrownianMotionSDE<Real>::wiener_dim);
}

/**
 * @brief Bind the Jacobi SDE model to Python.
 *
 * This specialization of `bind_model` exposes the 
 * `SDE::JacobiModelSDE<Real>` class to Python using pybind11.
 *
 * @param m        The pybind11 module where the class will be registered.
 * @param py_name  The name of the model class in the Python module.
 *
 * ### Bound constructor
 * - `__init__(v0: Real, kappa: Real, theta: Real, sigma: Real, rho: Real, 
 *             y_min: Real, y_max: Real, x0: Vector)`  
 *   Constructs a Jacobi SDE model with parameters:
 *   - `v0` : Initial variance  
 *   - `kappa` : Mean-reversion speed  
 *   - `theta` : Long-term mean  
 *   - `sigma` : Volatility of volatility  
 *   - `rho` : Correlation between Wiener processes  
 *   - `y_min` : Lower bound for the state variable  
 *   - `y_max` : Upper bound for the state variable  
 *   - `x0` : Initial state vector  
 *
 * ### Bound methods
 * - `get_x0() -> Vector` : Returns the initial state.  
 * - `get_v0() -> Real` : Returns the initial variance.  
 * - `get_kappa() -> Real` : Returns the mean-reversion speed.  
 * - `get_theta() -> Real` : Returns the long-term mean.  
 * - `get_sigma_v() -> Real` : Returns the volatility of volatility.  
 * - `get_correlation() -> Real` : Returns the correlation parameter.  
 * - `get_y_min() -> Real` : Returns the lower bound for the state variable.  
 * - `get_y_max() -> Real` : Returns the upper bound for the state variable.  
 * - `state_dim() -> int` : Returns the dimension of the state space.  
 * - `wiener_dim() -> int` : Returns the dimension of the Wiener process.  
 *
 * @note This is a specialization of `bind_model` for the Jacobi SDE.
 */
template <>
void bind_model<SDE::JacobiModelSDE<Real>>(py::module_& m, const char* py_name) {
    py::class_<SDE::JacobiModelSDE<Real>, SDE::ISDEModel<Real>, std::shared_ptr<SDE::JacobiModelSDE<Real>>>(m, py_name)
        // generic constructor (adjust if not always valid)
        .def(py::init<Real, Real, Real, Real, Real, Real, Real, const Vector&>(),
             py::arg("v0"), py::arg("kappa"), py::arg("theta"),
             py::arg("sigma"), py::arg("rho"), py::arg("y_min"), 
             py::arg("y_max"), py::arg("x0"))
        // common getters (these must exist in all models)
        .def("get_x0", py::overload_cast<>(&SDE::JacobiModelSDE<Real>::get_x0, py::const_))
        .def("get_v0", py::overload_cast<>(&SDE::JacobiModelSDE<Real>::get_v0, py::const_))
        .def("get_kappa", py::overload_cast<>(&SDE::JacobiModelSDE<Real>::get_kappa, py::const_))
        .def("get_theta", py::overload_cast<>(&SDE::JacobiModelSDE<Real>::get_theta, py::const_))
        .def("get_sigma_v", py::overload_cast<>(&SDE::JacobiModelSDE<Real>::get_sigma_v, py::const_))
        .def("get_correlation", py::overload_cast<>(&SDE::JacobiModelSDE<Real>::get_correlation, py::const_))
        .def("get_y_min", py::overload_cast<>(&SDE::JacobiModelSDE<Real>::get_y_min, py::const_))
        .def("get_y_max", py::overload_cast<>(&SDE::JacobiModelSDE<Real>::get_y_max, py::const_))
        .def("state_dim", &SDE::JacobiModelSDE<Real>::state_dim)
        .def("wiener_dim", &SDE::JacobiModelSDE<Real>::wiener_dim);
}

/**
 * @brief Bind the OPEOptionPricer class template to Python.
 *
 * This function template exposes the `options::OPEOptionPricer<Real, N>` 
 * class to Python using pybind11. The option pricer computes option prices 
 * under a given SDE model using the Orthonormal Polynomial Expansion.
 *
 * @tparam N         The number of dimensions (state variables) handled by the pricer.
 * @param m          The pybind11 module where the class will be registered.
 * @param class_name The name of the Python class to expose.
 *
 * ### Bound constructor
 * - `__init__(ttm: Real, rate: Real, payoff: IPayoff, model: ISDEModel,
 *             solver_type: SolverType = EulerMaruyama,
 *             integrator: QuadratureMethod = TanhSinh,
 *             num_paths: int = 10)`  
 *
 *   Constructs an OPE option pricer with:
 *   - `ttm` : Time-to-maturity.  
 *   - `rate` : Risk-free interest rate.  
 *   - `payoff` : A payoff function (must implement `IPayoff<Real>`).  
 *   - `model` : An SDE model (must implement `ISDEModel<Real>`).  
 *   - `solver_type` : Numerical SDE solver (default: Euler–Maruyama).  
 *   - `integrator` : Quadrature integration method (default: Tanh–Sinh).  
 *   - `num_paths` : Number of Monte Carlo paths (default: 10).  
 *
 * ### Bound methods
 * - `price() -> Real` : Computes the option price.  
 *
 * @note The class is registered as `OPEOptionPricer<N>` in Python.
 */
template <int N>
void bind_OPEOptionPricer(py::module& m, const std::string& class_name) {
    using OPEType = options::OPEOptionPricer<Real, N>;

    py::class_<OPEType, std::shared_ptr<OPEType>>(m, class_name.c_str())
        .def(py::init(
            [](Real ttm, Real rate,
               std::shared_ptr<options::IPayoff<Real>> payoff,
               std::shared_ptr<SDE::ISDEModel<Real>> model,
               traits::SolverType solver_type = traits::SolverType::EulerMaruyama,
               traits::QuadratureMethod integrator = traits::QuadratureMethod::TanhSinh,
               unsigned int num_paths = 10) 
            {
                return std::make_shared<OPEType>(
                    ttm, rate,
                    std::move(payoff), model,
                    solver_type, integrator, num_paths
                );
            }),
            py::arg("ttm"), py::arg("rate"),
            py::arg("payoff"), py::arg("model"), py::arg("solver_type") = traits::SolverType::EulerMaruyama,
            py::arg("integrator") = traits::QuadratureMethod::TanhSinh,
            py::arg("num_paths") = 10)
        .def("price", &OPEType::price);
}


PYBIND11_MODULE(opoe, m) {
    m.doc() = "Stochastic vol SDE models, solvers, and option pricers (pybind11)";

    // ----- Enums -----
    /**
     * @brief Quadrature integration methods available for option pricing.
     *
     * This enum defines the numerical integration strategies used in 
     * quadrature-based pricing. It is exposed to Python as `QuadratureMethod`.
     *
     * ### Values
     * - `QuadratureMethod.TanhSinh` : Tanh–Sinh quadrature method 
     *   (suitable for singular integrals, highly accurate).
     * - `QuadratureMethod.QAGI` : GSL’s QAGI algorithm for improper integrals.
     */
    py::enum_<traits::QuadratureMethod>(m, "QuadratureMethod")
    .value("TanhSinh", traits::QuadratureMethod::TanhSinh)
    .value("QAGI", traits::QuadratureMethod::QAGI) 
    .export_values();

    /**
     * @brief SDE solver schemes for stochastic simulation.
     *
     * This enum defines the numerical discretization methods used to 
     * approximate solutions of stochastic differential equations (SDEs).  
     * It is exposed to Python as `SolverType`.
     *
     * ### Values
     * - `SolverType.EulerMaruyama` : Explicit Euler–Maruyama scheme 
     *   (first-order weak, simple, widely used).
     * - `SolverType.Milstein` : Milstein scheme 
     *   (higher order, captures diffusion more accurately).
     * - `SolverType.IJK` : Custom/advanced solver (Ito–Taylor variant, if defined).
     */
    py::enum_<traits::SolverType>(m, "SolverType")
    .value("EulerMaruyama", traits::SolverType::EulerMaruyama)
    .value("Milstein", traits::SolverType::Milstein) 
    .value("IJK", traits::SolverType::IJK)
    .export_values();

    //----- Models -----

    py::class_<SDE::ISDEModel<Real>, std::shared_ptr<SDE::ISDEModel<Real>>>(m, "ISDEModel");

    bind_model<SDE::HestonModelSDE<Real>>(m, "HestonModel");
    bind_model<SDE::HullWhiteModelSDE<Real>>(m, "HullWhiteModel");
    bind_model<SDE::SteinSteinModelSDE<Real>>(m, "SteinSteinModel");
    bind_model<SDE::GeometricBrownianMotionSDE<Real>>(m, "GeometricBrownianMotionModel");
    bind_model<SDE::JacobiModelSDE<Real>>(m, "JacobiModel");

    // ----- Solvers -----
    bind_solver<SDE::EulerMaruyamaSolver<SDE::ISDEModel<Real>, Real>>(m, "EulerMaruyamaSolver");
    bind_solver<SDE::MilsteinSolver<SDE::ISDEModel<Real>, Real>>(m, "MilsteinSolver");
    bind_solver<SDE::InterpolatedKahlJackelSolver<SDE::ISDEModel<Real>, Real>>(m, "InterpolatedKahlJackelSolver");

    // ----- Payoffs -----
    // Base payoff interface
    /**
     * @brief Interface for option payoff functions.
     *
     * This is the abstract base class for all option payoff types.
     * Exposed to Python as `IPayoff`.
     *
     * Payoffs define how the terminal asset price `S_T` is transformed
     * into a cashflow (e.g. max(S_T - K, 0) for a call).
     */
    py::class_<options::IPayoff<Real>, std::shared_ptr<options::IPayoff<Real>>>(m, "IPayoff");

    // European call
    /**
     * @brief European Call option payoff.
     *
     * Payoff function: \f$\max(S_T - K, 0)\f$
     */
    py::class_<options::EuropeanCallPayoff<Real>, options::IPayoff<Real>, std::shared_ptr<options::EuropeanCallPayoff<Real>>>(m, "EuropeanCallPayoff")
    .def(py::init<Real>(), py::arg("K"))
    .def("evaluate", py::overload_cast<Real>(&options::EuropeanCallPayoff<Real>::evaluate, py::const_), py::arg("S_T"))
    .def("evaluate_from_log", py::overload_cast<Real>(&options::EuropeanCallPayoff<Real>::evaluate_from_log, py::const_), py::arg("log_S_T"))
    .def("get_strike", &options::EuropeanCallPayoff<Real>::getStrike)
    .def("set_strike", &options::EuropeanCallPayoff<Real>::setStrike, py::arg("K"));

    // European put
    /**
     * @brief European Put option payoff.
     *
     * Payoff function: \f$\max(K - S_T, 0)\f$
     */
    py::class_<options::EuropeanPutPayoff<Real>, options::IPayoff<Real>, std::shared_ptr<options::EuropeanPutPayoff<Real>>>(m, "EuropeanPutPayoff")
    .def(py::init<Real>(), py::arg("K"))
    .def("evaluate", py::overload_cast<Real>(&options::EuropeanPutPayoff<Real>::evaluate, py::const_), py::arg("S_T"))
    .def("evaluate_from_log", py::overload_cast<Real>(&options::EuropeanPutPayoff<Real>::evaluate_from_log, py::const_), py::arg("log_S_T"))
    .def("get_strike", &options::EuropeanPutPayoff<Real>::getStrike)
    .def("set_strike", &options::EuropeanPutPayoff<Real>::setStrike, py::arg("K"));


    // ----- Pricers -----
    /**
     * @brief Monte Carlo Option Pricer.
     *
     * Prices European-style options by simulating paths of the underlying SDE
     * using the specified solver.
     *
     * @tparam Real Floating point type (e.g., double).
     *
     * ### Python Example
     * ```python
     * model = GeometricBrownianMotionSDE(mu=0.05, sigma=0.2, x0=100.0)
     * payoff = EuropeanCallPayoff(K=100.0)
     * pricer = MCOptionPricer(ttm=1.0, rate=0.01,
     *                         payoff=payoff, model=model,
     *                         solver_type=SolverType.EulerMaruyama,
     *                         num_paths=50000, num_steps=100)
     * price = pricer.price()
     */
    py::class_<options::MCOptionPricer<Real>, std::shared_ptr<options::MCOptionPricer<Real>>>(m, "MCOptionPricer")
    .def(py::init(
    [](Real ttm, Real rate,
        std::shared_ptr<options::IPayoff<Real>> payoff,
        std::shared_ptr<SDE::ISDEModel<Real>> model,
        traits::SolverType solver_type = traits::SolverType::EulerMaruyama,
        int num_paths, int num_steps) {

        return std::make_shared<options::MCOptionPricer<Real>>(
            ttm, rate,
            std::move(payoff), model,
            solver_type, num_paths, num_steps
        );
    }),
    py::arg("ttm"), py::arg("rate"),
    py::arg("payoff"), py::arg("model"), py::arg("solver_type") = traits::SolverType::EulerMaruyama,
    py::arg("num_paths") = 10000, py::arg("num_steps") = 100)
    .def("price", &options::MCOptionPricer<Real>::price);



    /**
     * @brief FFT Option Pricer.
     *
     * Prices European-style options using the **Carr–Madan FFT method**.  
     * This method is efficient for computing prices across a range of strikes.
     *
     * @tparam Real Floating point type (e.g., double).
     *
     * @param ttm  Time-to-maturity
     * @param rate Risk-free interest rate
     * @param payoff Payoff function (e.g. EuropeanCallPayoff)
     * @param model Stochastic model for underlying
     * @param Npow Power-of-two grid size for FFT (2^Npow points)
     * @param A Damping factor for characteristic function
     *
     * ### Python Example
     * ```python
     * model = GeometricBrownianMotionSDE(mu=0.05, sigma=0.2, x0=100.0)
     * payoff = EuropeanPutPayoff(K=100.0)
     * pricer = FFTOptionPricer(ttm=1.0, rate=0.01,
     *                          payoff=payoff, model=model,
     *                          Npow=12, A=10)
     * price = pricer.price()
     * ```
     */
    py::class_<options::FFTOptionPricer<Real>, std::shared_ptr<options::FFTOptionPricer<Real>>>(m, "FFTOptionPricer")
    .def(py::init([](Real ttm, Real rate,
                     std::shared_ptr<options::IPayoff<Real>> payoff,
                     std::shared_ptr<SDE::ISDEModel<Real>> sde_model,
                     unsigned int Npow, unsigned int A) {
        return std::make_shared<options::FFTOptionPricer<Real>>(
            ttm, rate, std::move(payoff), sde_model, Npow, A
        );
    }),
    py::arg("ttm"), py::arg("rate"),
    py::arg("payoff"), py::arg("model"),
    py::arg("Npow") = 10, py::arg("A") = 10)
    .def("price", &options::FFTOptionPricer<Real>::price);


 

    /**
     * @brief Exposing the various pricers depending on the number of components.
     *
     */
    bind_OPEOptionPricer<3>(m, "OPEOptionPricerN3"); 
    bind_OPEOptionPricer<5>(m, "OPEOptionPricerN5"); 
    bind_OPEOptionPricer<7>(m, "OPEOptionPricerN7"); 
    bind_OPEOptionPricer<9>(m, "OPEOptionPricerN9"); 
    bind_OPEOptionPricer<10>(m, "OPEOptionPricerN10"); 

    /**
     * @brief Closed Formula (CF) Option Pricer.
     *
     * Prices European-style options using the closed formulae. This method is only available for Geometric Brownian Motion.
     *
     * @tparam Real Floating point type (e.g., double).
     *
     * ### Python Example
     * ```python
     * model = GeometricBrownianMotionSDE(mu=0.05, sigma=0.2, x0=100.0)
     * payoff = EuropeanCallPayoff(K=100.0)
     * pricer = CFOptionPricer(ttm=1.0, rate=0.01,
     *                         payoff=payoff, model=model)
     * price = pricer.price()
     * ```
     */
    py::class_<options::CFOptionPricer<Real>, std::shared_ptr<options::CFOptionPricer<Real>>>(m, "CFOptionPricer")
    .def(py::init(
    [](Real ttm, Real rate,
        std::shared_ptr<options::IPayoff<Real>> payoff,
        std::shared_ptr<SDE::ISDEModel<Real>> model) {

        return std::make_shared<options::CFOptionPricer<Real>>(
            ttm, rate,
            std::move(payoff), model);
    }),
    py::arg("ttm"), py::arg("rate"),
    py::arg("payoff"), py::arg("model"))
    .def("price", &options::CFOptionPricer<Real>::price);




}./include/utils/FFTW.hpp
/**
 * @file FFTW.hpp
 * @brief Utilities for performing FFT-based polynomial multiplication using FFTW and Eigen.
 *
 * This header provides functions to compute the forward and inverse Fast Fourier Transform (FFT)
 * using the FFTW library, as well as utilities for pointwise multiplication in the frequency domain
 * and polynomial multiplication via FFT.
 *
 * Dependencies:
 * - FFTW3 library for FFT computations.
 * - Eigen library for array and matrix operations.
 * - OPOE_traits.hpp for type definitions.
 *
 * Namespace: Utils
 *
 * Types:
 * - Complex: Alias for std::complex<double>.
 * - Array: Alias for Eigen array of complex numbers as defined in traits::DataType::ComplexArray.
 *
 * Functions:
 * - forwardFFT: Computes the forward FFT of a given array, with zero-padding to the next power of two.
 * - inverseFFT: Computes the inverse FFT of a given frequency-domain array, with normalization.
 * - pointwiseMultiply: Performs element-wise multiplication of two arrays in the frequency domain.
 * - fftMultiply: Template function to multiply two polynomials using FFT-based convolution.
 */
#ifndef FFTW_HPP
#define FFTW_HPP

#include <fftw3.h>
#include <Eigen/Dense>
#include <vector>
#include <complex>
#include "../traits/OPOE_traits.hpp"

namespace Utils {
template <typename R = traits::DataType::PolynomialField>
using Complex = std::complex<R>;

using Array = traits::DataType::ComplexArray;

/**
 * @brief Computes the forward FFT.
 * @param data Input time-domain data.
 * @return Frequency-domain data.
 */
template <typename R = traits::DataType::PolynomialField>
inline Array forwardFFT(const Array& data) {
    int n = data.size();
    int paddedSize = 1;
    while (paddedSize < n) {
        paddedSize <<= 1;
    }

    Array paddedData = Array::Zero(paddedSize);
    paddedData.head(n) = data;

    Array freqData(paddedSize);

    fftw_plan plan = fftw_plan_dft_1d(n,
        reinterpret_cast<fftw_complex*>(const_cast<Complex<R>*>(paddedData.data())),
        reinterpret_cast<fftw_complex*>(freqData.data()),
        FFTW_FORWARD, FFTW_ESTIMATE);

    fftw_execute(plan);
    fftw_destroy_plan(plan);

    return freqData;
}
/**
 * @brief Computes the inverse FFT.
 * @param freqData Input frequency-domain data.
 * @return Time-domain data.
 */
template <typename R = traits::DataType::PolynomialField>
inline Array inverseFFT(const Array& freqData) {
    int n = freqData.size();
    int paddedSize = 1;
    while (paddedSize < n) {
        paddedSize <<= 1;
    }
    Array paddedData = Array::Zero(paddedSize);
    paddedData.head(n) = freqData;

    Array timeData(paddedSize);

    fftw_plan plan = fftw_plan_dft_1d(n,
        reinterpret_cast<fftw_complex*>(const_cast<Complex<R>*>(paddedData.data())),
        reinterpret_cast<fftw_complex*>(timeData.data()),
        FFTW_BACKWARD, FFTW_ESTIMATE);

    fftw_execute(plan);
    fftw_destroy_plan(plan);



    return timeData / static_cast<double>(paddedSize);
}

/**
 * @brief Performs pointwise multiplication in the frequency domain.
 * @param A First transformed polynomial.
 * @param B Second transformed polynomial.
 * @return Pointwise multiplied result.
 */
inline Array pointwiseMultiply(const Array& A, const Array& B) {
    return A.cwiseProduct(B);
}

/**
 * @brief Performs FFT-based polynomial multiplication.
 * @tparam T Floating-point type.
 * @param lhs First polynomial coefficients.
 * @param rhs Second polynomial coefficients.
 * @return Resulting polynomial coefficients.
 */
template <typename T = traits::DataType::PolynomialField>
inline Eigen::Array<T, Eigen::Dynamic, 1> fftMultiply(const Eigen::Array<T, Eigen::Dynamic, 1>& lhs,
                                                      const Eigen::Array<T, Eigen::Dynamic, 1>& rhs) {
    int sizeA = lhs.size();
    int sizeB = rhs.size();
    int n = 1;

    while (n < sizeA + sizeB - 1) {
        n <<= 1;
    }


    // Allocate and copy input
    Array fa = Array::Zero(n);
    Array fb = Array::Zero(n);
    fa.head(sizeA) = lhs.template cast<Complex>();
    fb.head(sizeB) = rhs.template cast<Complex>();
    
    // Perform FFT
    Array freqA = forwardFFT(fa);
    Array freqB = forwardFFT(fb);

    // Multiply in frequency domain
    Array freqResult = pointwiseMultiply(freqA, freqB);

    // Inverse FFT to get result
    Array timeResult = inverseFFT(freqResult);

    // Extract real parts
    return timeResult.head(sizeA + sizeB - 1).real().template cast<T>();
}

} // namespace Utils

#endif // FFTW_HPP

./include/utils/FileReader.hpp

/**
 * @file FileReader.hpp
 * @brief Provides functionality to read quantization grid data from a file into Eigen-based structures.
 *
 * This header defines the QuantizationGrid struct and the readQuantizationGrid function template,
 * which are used to load quantization grid data (including coordinates, weights, and distortions)
 * from a file into Eigen matrices and vectors for efficient numerical processing.
 *
 * Dependencies:
 * - OPOE_traits.hpp: For type definitions and concepts.
 */

#ifndef FILE_READER_HPP
#define FILE_READER_HPP
#include <iostream>
#include <fstream>
#include <vector>
#include <string>
#include <sstream>
#include <stdexcept>
#include <filesystem>
#include "../traits/OPOE_traits.hpp" 

/**
 * @struct QuantizationGrid
 * @brief Structure to hold quantization grid data using Eigen types.
 *
 * @tparam R The type used for global distortion values (default: traits::DataType::PolynomialField).
 *
 * Members:
 * - N: Number of grid points.
 * - d: Dimension of each grid point.
 * - coordinates: Eigen matrix storing all grid point coordinates (size N x d).
 * - weights: Eigen vector storing the weight for each grid point (size N).
 * - local_l2_distortions: Eigen vector of local L2 distortions for each grid point (size N).
 * - local_l1_distortions: Eigen vector of local L1 distortions for each grid point (size N).
 * - quadratic_distortion: Global quadratic (L2) distortion.
 * - l1_distortion: Global L1 distortion.
 */
template<typename R = traits::DataType::PolynomialField>
struct QuantizationGrid {
    unsigned int N;
    unsigned int d;

    // Storing all coordinates in one Eigen matrix
    traits::DataType::StoringMatrix coordinates; // e.g., Eigen::MatrixXd

    // Using Eigen vectors for weights and distortions
    traits::DataType::StoringVector weights;
    traits::DataType::StoringVector local_l2_distortions;
    traits::DataType::StoringVector local_l1_distortions;

    // Global distortions
    R quadratic_distortion;
    R l1_distortion;
};


/**
 * @brief Reads a quantization grid from a file into a QuantizationGrid structure using Eigen types.
 *
 * The function expects the file to have N rows of data, each containing:
 *   - weight (scalar)
 *   - d coordinates (space-separated)
 *   - local L2 distortion (scalar)
 *   - local L1 distortion (scalar)
 * followed by a final row containing global distortion values.
 *
 * @tparam R The type used for global distortion values (default: traits::DataType::PolynomialField).
 * @param N Number of grid points.
 * @param d Dimension of each grid point.
 * @param base_dir Directory containing the grid file.
 * @return QuantizationGrid<R> Structure populated with data from the file.
 * @throws std::runtime_error If the file cannot be opened or if the data format is invalid.
 */
template<typename R = traits::DataType::PolynomialField>
QuantizationGrid<R> readQuantizationGrid(int N, int d, const std::filesystem::path& base_dir) {
    // Construct the filename
    std::string filename = std::to_string(N) + "_" + std::to_string(d) + "_nopti";
    std::filesystem::path file_path = base_dir / filename;

    // Open the file
    std::ifstream file(file_path);
    if (!file.is_open()) {
        throw std::runtime_error("Could not open file: " + file_path.string());
    }

    QuantizationGrid<R> grid;
    grid.N = N;
    grid.d = d;

    // Pre-allocate memory for the Eigen matrix and vectors
    grid.coordinates.resize(N, d);
    grid.weights.resize(N);
    grid.local_l2_distortions.resize(N);
    grid.local_l1_distortions.resize(N);

    std::string line;
    int line_num = 0;

    // Read the first N rows and populate the matrix/vectors directly
    while (line_num < N && std::getline(file, line)) {
        std::stringstream ss(line);

        // Read weight into the Eigen vector
        if (!(ss >> grid.weights(line_num))) {
            throw std::runtime_error("Invalid data format for weight at line " + std::to_string(line_num + 1));
        }

        // Read coordinates into the corresponding row of the matrix
        for (int i = 0; i < d; ++i) {
            if (!(ss >> grid.coordinates(line_num, i))) {
                throw std::runtime_error("Invalid data format for coordinates at line " + std::to_string(line_num + 1));
            }
        }

        // Read distortions into Eigen vectors
        if (!(ss >> grid.local_l2_distortions(line_num) >> grid.local_l1_distortions(line_num))) {
            throw std::runtime_error("Invalid data format for distortions at line " + std::to_string(line_num + 1));
        }

        line_num++;
    }

    // Read the last row (N+1) for global distortions
    if (std::getline(file, line)) {
        std::stringstream ss(line);
        double val;
        // Skip the first d+1 zeros
        for(int i = 0; i < d + 1; ++i) {
            if (!(ss >> val)) {
                 throw std::runtime_error("Invalid data format in the last row");
            }
        }
        if (!(ss >> grid.quadratic_distortion >> grid.l1_distortion)) {
            throw std::runtime_error("Invalid data format in the last row for distortions");
        }
    } else {
        throw std::runtime_error("File does not have enough rows for N = " + std::to_string(N));
    }

    return grid;
}

#endif // FILE_READER_HPP

./include/utils/Utils.hpp
/*!
 * @file Utils.hpp
 * @brief Utility functions and templates for polynomial operations, random sampling, and vector/matrix computations.
 *
 * This header provides a collection of utility templates and functions, including:
 * - Compile-time exponentiation of polynomials via the `Pow` struct template, with specializations for exponents 0 and 1.
 * - Computation of the Pochhammer symbol (falling and rising factorial) for generic numeric types.
 * - A flexible `sampler` function for generating Eigen vectors or matrices filled with random samples from a specified distribution.
 * - An `argmin` function to find the column of a matrix closest (in L2 norm) to a target vector, returning the index, distance, and all distances.
 * - A `calculate_overall_distortion` function to compute the average distortion (root mean squared error) between randomly generated samples and their closest centroids.
 *
 * The utilities are designed to work with Eigen types and generic numeric types, and leverage modern C++ features such as variadic templates, `if constexpr`, and concepts.
 * 
 * Dependencies:
 * - Eigen for matrix and vector operations.
 * - OPOE_traits.hpp for type definitions and concepts.
 */

#ifndef UTILS_HPP
#define UTILS_HPP

#include <cmath>
#include <random>
#include <tuple>
#include <unordered_map>
#include <vector>
#include <utility>       
#include <type_traits>
#include "../traits/OPOE_traits.hpp" 
#include <unsupported/Eigen/KroneckerProduct>

namespace Utils
{

/**
 * @section Polynomial Utilities
 * @brief Provides utilities for polynomial operations, including compile-time exponentiation.
 */

using IndexMap = std::unordered_map<long, int>;

/**
 * @brief Forward Declaration of the Polynomial class.
 */
template <unsigned int N, typename R = traits::DataType::PolynomialField> 
class Polynomial;

/**
 * @brief Type alias for a map that associates a long key (m, n) to an integer index.
 *
 * This map is used to efficiently store and retrieve indices based on polynomial degree and exponent.
 */

/**
 * @brief Template structure to compute powers of a Polynomial at compile time.
 *
 * @tparam RDegree Degree of the polynomial.
 * @tparam R Type of the polynomial's coefficients.
 * @tparam Exp Exponent to raise the polynomial to.
 */
template <unsigned int RDegree, typename R = traits::DataType::PolynomialField, unsigned int Exp = 2u> 
struct Pow
{
    /**
     * @brief Computes the polynomial raised to the power of Exp.
     * @param p The input polynomial.
     * @return Result of p^Exp.
     */
    auto inline operator()(Polynomial<RDegree, R> const &p) const
    {
        Pow<RDegree, R, Exp - 1u> next;
        return next(p) * p;
    }
};

/**
 * @brief Specialization of Pow for exponent equal to 1.
 */
template <unsigned int RDegree, typename R> 
struct Pow<RDegree, R, 1u>
{
    /**
     * @brief Returns the polynomial unchanged (p^1 = p).
     * @param p The input polynomial.
     * @return The same polynomial.
     */
    Polynomial<RDegree, R> inline operator()(Polynomial<RDegree, R> const &p) const
        {
            return p;
        }
};

/**
 * @brief Specialization of Pow for exponent equal to 0.
 */
template <unsigned int RDegree, typename R> 
struct Pow<RDegree, R, 0u>
{
     /**
     * @brief Returns the constant polynomial 1 (p^0 = 1).
     * @param p The input polynomial.
     * @return Constant polynomial with value 1.
     */
    Polynomial<0u, R>
    inline operator()(Polynomial<RDegree, R> const &p)
    {
        return Polynomial<0u, R>{{R(1)}};
    }
};

/**
 * @brief Computes the Pochhammer symbol (falling or rising factorial).
 *
 * @tparam R Numeric type.
 * @tparam Type Enum value specifying falling or rising factorial.
 * @param m Base value.
 * @param n Number of terms in the product.
 * @return The result of the Pochhammer symbol computation.
 */
template <typename R = traits::DataType::PolynomialField, traits::PochammerType Type>
requires (Type == traits::PochammerType::Falling || Type == traits::PochammerType::Rising)
inline R Pochhammer(R m, R n) {
    if constexpr (Type == traits::PochammerType::Falling) {
        R result = 1;
        for (R i = 0; i < n; ++i) {
            result *= (m - i);
        }
        return result;
    } else if constexpr (Type == traits::PochammerType::Rising) {
        R result = 1;
        for (R i = 0; i < n; ++i) {
            result *= (m + i);
        }
        return result;
    }
}

/**
 * @section Random Generation Utilities
 * @brief Provides utilities for generating random samples using Eigen types.
 *
 * This section includes a generic `sampler` function that can generate Eigen vectors or matrices filled with random samples from a specified distribution.
 * The function supports both single-dimensional (vector) and two-dimensional (matrix) outputs, leveraging variadic templates for flexibility.
 * It also includes an `argmin` function to find the column of a matrix closest (in L2 norm) to a target vector, and a function to compute average distortion between random samples and centroids.
 */

/**
 * @brief Generates an Eigen vector or matrix filled with random samples.
 *
 * @tparam T Scalar type (e.g., float, double).
 * @tparam DistributionType Type of random number distribution.
 * @tparam DimArgs Variadic template for dimensions (1 for vector, 2 for matrix).
 * @param generator Mersenne Twister random number generator.
 * @param distribution Distribution object used to generate samples.
 * @param dims_args Dimensions of the output (size or rows, cols).
 * @return An Eigen vector or matrix filled with samples.
 */

template<typename T = traits::DataType::PolynomialField, typename DistributionType, typename... DimArgs>
auto sampler(
    std::mt19937& generator,          // Mersenne Twister engine (passed by reference)
    DistributionType& distribution,   // Generic distribution (passed by reference)
    DimArgs... dims_args              // Variadic template for dimension arguments
) {
    // Determine the number of dimension arguments at compile time
    constexpr size_t number_of_dimensions = sizeof...(dims_args);

    if constexpr (number_of_dimensions == 1) {
        // Case 1: Single dimension argument, implies a Vector
        auto dimensions_tuple = std::make_tuple(dims_args...);
        // Extract the vector size from the tuple
        typename std::tuple_element<0, std::tuple<std::decay_t<DimArgs>...>>::type vector_size = std::get<0>(dimensions_tuple);

        // Use Eigen's NullaryExpr to fill the vector with random samples
        return traits::DataType::StoringVector::NullaryExpr(vector_size, [&]() -> T {
            return static_cast<T>(distribution(generator)); // Generate one random number per element
        });

    } else if constexpr (number_of_dimensions == 2) {
        // Case 2: Two dimension arguments, implies a Matrix
        auto dimensions_tuple = std::make_tuple(dims_args...);
        // Extract matrix rows and columns from the tuple
        typename std::tuple_element<0, std::tuple<std::decay_t<DimArgs>...>>::type matrix_rows = std::get<0>(dimensions_tuple);
        typename std::tuple_element<1, std::tuple<std::decay_t<DimArgs>...>>::type matrix_cols = std::get<1>(dimensions_tuple);

        // Use Eigen's NullaryExpr to fill the matrix with random samples
        return traits::DataType::StoringMatrix::NullaryExpr(matrix_rows, matrix_cols, [&]() -> T {
            return static_cast<T>(distribution(generator)); // Generate one random number per element
        });

    } else {
        // Compile-time error for an unsupported number of dimension arguments
        static_assert(number_of_dimensions == 1 || number_of_dimensions == 2,
            "sample_any_distribution_eigen expects 1 argument for a Vector (size) "
            "or 2 arguments for a Matrix (rows, cols).");
        // This part should never be reached due to static_assert
    }
}


/**
 * @brief Finds the column of a matrix closest (in L2 norm) to a target vector.
 *
 * @tparam T Numeric type for distance.
 * @param matrix Matrix where each column represents a point.
 * @param target_vector Target vector to compare against.
 * @return Tuple of (index of closest column, minimum L2 distance, vector of all distances).
 */

template<typename T = traits::DataType::PolynomialField>
std::tuple<int, T, traits::DataType::StoringVector> argmin(
    const traits::DataType::StoringMatrix& matrix,
    const traits::DataType::StoringVector& target_vector) {

    // --- Input Validations ---
    if (matrix.cols() == 0) {
        std::cerr << "Error: Matrix has no columns." << std::endl;
        return {-1, std::numeric_limits<T>::infinity(), traits::DataType::StoringVector()};
    }
    if (matrix.rows() != target_vector.size()) {
        std::cerr << "Error: Number of rows in matrix (" << matrix.rows()
                  << ") does not match size of target vector (" << target_vector.size()
                  << ")." << std::endl;
        return {-1, std::numeric_limits<T>::infinity(), traits::DataType::StoringVector()};
    }

    // Compute the L2 distances between each column and the target vector
    traits::DataType::StoringVector l2_distances = (matrix.colwise() - target_vector).colwise().norm();

    // Find the minimum L2 distance and its index
    Eigen::Index min_col_index;
    T min_distance_value = l2_distances.minCoeff(&min_col_index);

    return {static_cast<int>(min_col_index), min_distance_value, l2_distances};
}



/**
 * @brief Computes average distortion (root mean squared error) between random samples and nearest centroids.
 *
 * @tparam T Numeric type.
 * @tparam Dim Dimensionality of the samples and centroids.
 * @param current_centroids Matrix of centroids (each column is a centroid).
 * @param num_test_samples Number of random test samples to generate.
 * @param generator Random number generator.
 * @param distribution Distribution used to generate test samples.
 * @return Root mean squared error between samples and nearest centroid.
 */

template<typename T = traits::DataType::PolynomialField, int Dim>
T calculate_overall_distortion(
    const traits::DataType::StoringMatrix& current_centroids,
    int num_test_samples, // Number of random samples to generate
    std::mt19937& generator,
    std::normal_distribution<T>& distribution) {

    // Validate input
    if (current_centroids.cols() == 0 || num_test_samples == 0) {
        if (current_centroids.cols() == 0) std::cerr << "Distortion calc error: No centroids." << std::endl;
        return std::numeric_limits<T>::infinity();
    }
    if (current_centroids.rows() != Dim) {
        std::cerr << "Distortion calc error: Centroid dimension mismatch." << std::endl;
        return std::numeric_limits<T>::infinity();
    }

    T total_squared_error = static_cast<T>(0.0);
    int valid_samples_for_distortion = 0;

    // Generate random samples and accumulate squared error to closest centroid
    for (int i = 0; i < num_test_samples; ++i) {
        // Generate a single, fresh test sample
        traits::DataType::StoringVector test_sample =
            sampler<T>(generator, distribution, Dim);

        // Find the closest centroid and its L2 distance
        auto closest_info_for_test_sample = argmin<T>(current_centroids, test_sample);

        if (std::get<0>(closest_info_for_test_sample) != -1) { // Valid centroid found
            T min_l2_distance = std::get<1>(closest_info_for_test_sample);
            total_squared_error += (min_l2_distance * min_l2_distance); // Accumulate squared L2 distance
            valid_samples_for_distortion++;
        }
    }

    // Compute RMSE if there are valid samples
    if (valid_samples_for_distortion > 0) {
        return std::sqrt(total_squared_error / static_cast<T>(valid_samples_for_distortion));
    }

    return std::numeric_limits<T>::infinity(); // Return infinity if no valid samples
}


/**
 * @section Matrix Utilities
 * @brief Provides utilities for matrix operations, including enumeration of polynomial basis indices and Kronecker products.
 */
using StoringMatrix = traits::DataType::StoringMatrix;
using StoringVector = traits::DataType::StoringVector;
/**
 * @brief Enumerates all pairs (m, n) such that m + n <= N.
 * 
 * This function generates a vector of pairs representing the indices of the basis functions
 * for a polynomial basis of degree N. Each pair corresponds to the indices of the monomials
 * in the polynomial expansion.
 *
 * @param N The maximum degree of the polynomial basis.
 * @return A vector of pairs (m, n) where m + n <= N.
 */
std::vector<std::pair<int,int>> enumerate_basis(int N) {
    std::vector<std::pair<int,int>> E;
    E.reserve((N+1)*(N+2)/2);
    for (int m = 0; m <= N; ++m) {
        for (int n = 0; n <= N - m; ++n) {
            E.emplace_back(m, n);
        }
    }
    return E;
}


/**
 * @brief Builds the representation matrix of the first monomial derivative of dimension N.
 * 
 * This function constructs a diagonal matrix where the diagonal entries correspond to the first derivative of the monomial basis functions.
 * The diagonal entries are filled with the values from 1 to N-1, representing the coefficients of the first derivative.
 * @param N The size of the matrix (number of monomial basis functions).
 * @return A StoringMatrix representing the first monomial derivative.
 */
template<typename T = traits::DataType::PolynomialField>
[[nodiscard]] inline StoringMatrix build_Dmono(int N) {
    StoringMatrix D = StoringMatrix::Zero(N, N);
    if (N > 1) {
        D.diagonal(1) = StoringVector::LinSpaced(N - 1, T(1), T(N - 1));
    }
    return D;
}

/**
 * @brief Builds the representation matrix of the second monomial derivative of dimension N.
 * 
 * This function constructs a diagonal matrix where the diagonal entries correspond to the second derivative of the monomial basis functions.
 * The diagonal entries are filled with the values from 2 to N-1, representing the coefficients of the second derivative.
 * @param N The size of the matrix (number of monomial basis functions).
 * @return A StoringMatrix representing the second monomial derivative.
 */
template<typename T = traits::DataType::PolynomialField>
[[nodiscard]] inline StoringMatrix build_D2mono(int N) {
    StoringMatrix D2 = StoringMatrix::Zero(N, N);
    if (N > 2) {
        StoringVector j = StoringVector::LinSpaced(N - 2, T(2), T(N - 1));
        D2.diagonal(2) = j.array() * (j.array() - T(1));
    }
    return D2;
}

/**
 * @brief Converts a polynomial vector to a diagonal matrix representation.
 *
 * This function takes a vector of polynomial coefficients and constructs a diagonal matrix where each diagonal entry corresponds to a coefficient.
 * The diagonal is shifted by the specified index, allowing for flexible placement of the coefficients.
 * @param coeffs Vector of polynomial coefficients.
 * @param Nv Size of the diagonal matrix (number of rows/columns).
 * @return A StoringMatrix representing the polynomial coefficients as a diagonal matrix.
 */
template<typename T = traits::DataType::PolynomialField>
[[nodiscard]] inline StoringMatrix poly_to_M(const StoringVector& coeffs, int Nv) {
    StoringMatrix R = StoringMatrix::Zero(Nv, Nv);
    const int L = std::min<int>(coeffs.size(), Nv);
    for (int r = 0; r < L; ++r) {
        const T c = coeffs[r];
        if (c != T(0)) {
            R.diagonal(-r).array() += c;
        }
    }
    return R;
}


/**
 * @brief Builds the G representation matrix of the generator of a stochastic volatility model.
 *
 * This function constructs the representation matrix G of the generator for a stochastic volatility model.
 * It uses the provided parameters to compute the derivatives in the H basis and constructs the G matrix using Kronecker products.
 * The resulting matrix is structured to represent the interactions between the volatility and the underlying asset.
 * @param H The matrix representing the H basis.
 * @param bx, axx, bv, axv, avv Vectors representing the coefficients of the generator.
 * @param Nv The size of the volatility dimension.
 * @return A StoringMatrix representing the G matrix of the generator.
 *
 */

template<typename T = traits::DataType::PolynomialField>
[[nodiscard]] inline StoringMatrix build_G_full(
    const StoringMatrix& H,
    const StoringVector& bx,
    const StoringVector& axx,
    const StoringVector& bv,
    const StoringVector& axv,
    const StoringVector& avv,
    int Nv
) {
    const int Nx = H.cols();

    // Derivatives in H basis
    const StoringMatrix Dmono  = build_Dmono<T>(Nx);
    const StoringMatrix D2mono = build_D2mono<T>(Nx);

    auto dec = H.colPivHouseholderQr();
    const StoringMatrix D_H  = dec.solve(Dmono  * H);
    const StoringMatrix D_H2 = dec.solve(D2mono * H);

    // v-side operators
    const StoringMatrix Bx   = poly_to_M<T>(bx,  Nv);
    const StoringMatrix Bxx  = poly_to_M<T>(axx, Nv);
    const StoringMatrix Bv   = poly_to_M<T>(bv,  Nv);
    const StoringMatrix Bxv  = poly_to_M<T>(axv, Nv);
    const StoringMatrix Bvv  = poly_to_M<T>(avv, Nv);

    const StoringMatrix Dvmono  = build_Dmono<T>(Nv);
    const StoringMatrix D2vmono = build_D2mono<T>(Nv);

    StoringMatrix G_full = StoringMatrix::Zero(Nv * Nx, Nv * Nx);

    // Operators
    G_full.noalias() += Eigen::kroneckerProduct(Bx, D_H).eval();
    G_full.noalias() += 0.5 * Eigen::kroneckerProduct(Bxx, D_H2).eval();
    G_full.noalias() += Eigen::kroneckerProduct((Bv * Dvmono).eval(), StoringMatrix::Identity(Nx, Nx)).eval();
    G_full.noalias() += Eigen::kroneckerProduct((Bxv * Dvmono).eval(), D_H).eval();
    G_full.noalias() += 0.5 * Eigen::kroneckerProduct((Bvv * D2vmono).eval(), StoringMatrix::Identity(Nx, Nx)).eval();

    return G_full;
}

/**
 * @brief Projects the full G matrix to a triangular form based on the provided edges.
 * 
 * This function constructs a triangular matrix representation of the G matrix by selecting only the entries corresponding to the specified edges.
 * The edges are provided as a vector of pairs (m, n), where m and n are indices in the full G matrix.
 * The resulting triangular matrix is structured such that it contains only the entries corresponding to the specified edges.
 * 
 * @param G_full The full G matrix from which to extract the triangular representation.
 * @param E_tri Vector of pairs representing the edges to include in the triangular matrix.
 * @param Nx The size of the x dimension (number of rows/columns in the full G matrix).
 * @return A StoringMatrix representing the projected triangular form of G.
 * 
 * @note The function assumes that the edges are provided in a format compatible with the full G matrix, and that Nx corresponds to the number of x dimensions in the full G matrix.
 */
[[nodiscard]] inline StoringMatrix project_to_triangular(
    const StoringMatrix& G_full,
    const std::vector<std::pair<int,int>>& E_tri,
    int Nx
) {
    const int M = static_cast<int>(E_tri.size());
    StoringMatrix G_tri = StoringMatrix::Zero(M, M);

    // Flatten indices (v-major: idx = v*Nx + x)
    Eigen::VectorXi flat(M);
    for (int k = 0; k < M; ++k) {
        flat[k] = E_tri[k].first * Nx + E_tri[k].second;
    }

    // Gather into G_tri
    for (int c = 0; c < M; ++c) {
        const int ic = flat[c];
        for (int r = 0; r < M; ++r) {
            G_tri(r, c) = G_full(flat[r], ic);
        }
    }
    return G_tri;
}

/**
 * @brief Expands the Orthonormal Basis to include the volatility dimension.
 * 
 * This function constructs the Hermite basis matrix H for a polynomial of degree N, expanded to include the volatility dimension.
 * The Hermite basis is represented as a matrix where each column corresponds to a polynomial basis function evaluated at the specified points.
 * The resulting matrix is structured to represent the polynomial basis functions in both the x and v dimensions.
 * 
 * @param H Representation matrix of the Orthonormal Basis.
 * @param E Vector of pairs (m, n) representing the polynomial basis indices.
 * @param N The degree of the polynomial basis.
 * @param X0 The initial value of the x dimension (e.g., asset price).
 * @param V0 The initial value of the v dimension (e.g., volatility).
 * 
 * @return A StoringMatrix representing the Hermite basis matrix H.
 */
template<typename Scalar = traits::DataType::PolynomialField>
StoringVector build_h_vals(const StoringMatrix& H,               // (N+1)x(N+1) Hermite basis matrix
             const std::vector<std::pair<int,int>>& E,                // vector of (m,n) pairs
             unsigned int N,                // polynomial base degree
             Scalar X0, Scalar V0){
    const int M = static_cast<int>(E.size());

    // --- Step 1: monomials of X0 up to N
    StoringVector monoms(N+1);
    monoms(0) = Scalar(1);
    for (unsigned int k = 1; k <= N; ++k) {
        monoms(k) = monoms(k-1) * X0;
    }

    // --- Step 2: Hermite evaluation using H matrix
    // H is (N+1)x(N+1), monoms is (N+1)x1
    // → Hvec = H * monoms, size (N+1)x1
    StoringVector Hvec = H.transpose() * monoms;

    // --- Step 3: powers of V0 up to max m in E
    unsigned int max_m = 0;
    for (auto [m, n] : E) if ((unsigned int)m > max_m) max_m = m;
    StoringVector Vpowers(max_m+1);
    Vpowers(0) = Scalar(1);
    for (unsigned int k = 1; k <= max_m; ++k) {
        Vpowers(k) = Vpowers(k-1) * V0;
    }

    // --- Step 4: assemble h_vals
    StoringVector h_vals(M);
    for (int i = 0; i < M; ++i) {
        const auto [m, n] = E[i];
        h_vals(i) = Vpowers(m) * Hvec(n);
    }

    return h_vals;
}



} // namespace Utils

#endif // UTILS_HPP











./include/stats/DensityBase.hpp

/**
 * @file DensityBase.hpp
 * @brief Provides a generic base class for probability density functions using Boost.Math distributions.
 *
 * This header defines a flexible template class `BoostBaseDensity` that wraps Boost.Math distributions,
 * providing a unified interface for PDF, CDF, quantile, and parameter access, as well as domain support.
 * It uses SFINAE to enable property accessors only for distributions that support them.
 * 
 * Dependencies:
 * - Boost.Math for distribution implementations.
 * - traits/OPOE_traits.hpp for type definitions and concepts.
 *
 * Main Components:
 * - SFINAE detection helpers: Traits to detect if a Boost distribution supports mean, stddev, shape, scale, alpha, beta.
 * - DensityInterval: Represents the support (domain) of a distribution, with bounds checking.
 * - BoostBaseDensity: Template class that wraps a Boost distribution, providing PDF, CDF, quantile, and parameter access.
 *   - Stores the constructed Boost distribution and its support interval.
 *   - Provides exception-safe access to PDF, CDF, and quantile.
 *   - SFINAE-enabled getters for distribution parameters (mean, stddev, etc.).
 *   - Stores the original constructor arguments for introspection or serialization.
 * - Factory functions: Helper functions to create densities for normal, gamma, and beta distributions.
 *
 * Usage Example:
 * @code
 * auto norm = stats::make_normal_density(0.0, 1.0);
 * double p = norm.pdf(0.5);
 * double mu = norm.getMu();
 * @endcode
 */

#ifndef DENSITY_BASE_HPP
#define DENSITY_BASE_HPP
#include <stdexcept>
#include <type_traits> 
#include <limits>      
#include <utility>     
#include <tuple>      
#include <vector>      
#include <numeric>     
#include <iostream>    
#include <typeinfo>   
#include <boost/math/distributions/normal.hpp>
#include <boost/math/distributions/gamma.hpp>
#include <boost/math/distributions/beta.hpp>
#include <boost/math/distributions/complement.hpp> 
#include <boost/math/policies/policy.hpp>         
#include "../traits/OPOE_traits.hpp"

// --- SFINAE detection helpers (Using generic Boost functions) ---
namespace stats {

/**
 * @brief Trait to detect if a Boost distribution supports `boost::math::mean`.
 * 
 * @tparam T Distribution type
 * @tparam R Result type (typically double)
 */
template<typename T, typename R, typename = void>
struct has_boost_mean : std::false_type {};
template<typename T, typename R>
struct has_boost_mean<T, R, std::void_t<decltype(boost::math::mean(std::declval<const T&>()))>> : std::true_type {};
template<typename T, typename R>
inline constexpr bool has_boost_mean_v = has_boost_mean<T, R>::value;

/**
 * @brief Trait to detect if a Boost distribution supports `boost::math::standard_deviation`.
 * 
 * @tparam T Distribution type
 * @tparam R Result type (typically double)
 */
template<typename T, typename R, typename = void>
struct has_boost_stddev : std::false_type {};
template<typename T, typename R>
struct has_boost_stddev<T, R, std::void_t<decltype(boost::math::standard_deviation(std::declval<const T&>()))>> : std::true_type {};
template<typename T, typename R>
inline constexpr bool has_boost_stddev_v = has_boost_stddev<T, R>::value;

/**
 * @brief Trait to detect if a Boost distribution possesses shape parameter.
 * 
 * @tparam T Distribution type
 * @tparam R Result type (typically double)
 */
template<typename T, typename R, typename = void>
struct has_boost_shape : std::false_type {};
template<typename T, typename R>
struct has_boost_shape<T, R, std::void_t<decltype(std::declval<const T&>().shape())>> : std::true_type {};
template<typename T, typename R>
inline constexpr bool has_boost_shape_v = has_boost_shape<T, R>::value;

/**
 * @brief Trait to detect if a Boost distribution possesses scale parameter.
 * 
 * @tparam T Distribution type
 * @tparam R Result type (typically double)
 */
template<typename T, typename R, typename = void>
struct has_boost_scale : std::false_type {};
template<typename T, typename R>
struct has_boost_scale<T, R, std::void_t<decltype(std::declval<const T&>().scale())>> : std::true_type {};
template<typename T, typename R>
inline constexpr bool has_boost_scale_v = has_boost_scale<T, R>::value;


/**
 * @brief Trait to detect if a Boost distribution possesses alpha parameter.
 * 
 * @tparam T Distribution type
 * @tparam R Result type (typically double)
 */
// Note: Boost doesn't have generic alpha/beta accessors.
// These traits check for the *member* functions specific to beta_distribution.
// If other distributions provided these members, they would also work.
template<typename T, typename R, typename = void>
struct has_boost_alpha : std::false_type {};
template<typename T, typename R>
struct has_boost_alpha<T, R, std::void_t<decltype(std::declval<const T&>().alpha())>> : std::true_type {};
template<typename T, typename R>
inline constexpr bool has_boost_alpha_v = has_boost_alpha<T, R>::value;

/**
 * @brief Trait to detect if a Boost distribution possesses beta parameter.
 * 
 * @tparam T Distribution type
 * @tparam R Result type (typically double)
 */
template<typename T, typename R, typename = void>
struct has_boost_beta_param : std::false_type {};
template<typename T, typename R>
struct has_boost_beta_param<T, R, std::void_t<decltype(std::declval<const T&>().beta())>> : std::true_type {};
template<typename T, typename R>
inline constexpr bool has_boost_beta_param_v = has_boost_beta_param<T, R>::value;



/**
 * @brief Represents a valid interval over which a density is defined.
 * 
 * @tparam R Numeric type (e.g., float or double).
 */
template<typename R>
struct DensityInterval {
    R lower = -std::numeric_limits<R>::infinity();
    R upper = std::numeric_limits<R>::infinity();

    /**
     * @brief Constructs a DensityInterval with explicit bounds.
     * @param l Lower bound
     * @param u Upper bound
     * @throws std::invalid_argument if l > u and neither bound is NaN.
     */
    DensityInterval(R l, R u) : lower(l), upper(u) {
        if (l > u && !(std::isnan(l) || std::isnan(u))) { // Allow NaN bounds? Maybe not.
             throw std::invalid_argument("Lower bound cannot be greater than upper bound in DensityInterval.");
        }
    }
    /**
     * @brief Default constructor creating interval (-inf, +inf).
     */
    DensityInterval() = default; // Default interval is (-inf, +inf)
};

/**
 * @brief Generic wrapper for Boost continuous probability distributions.
 * 
 * Provides a uniform interface for PDF, CDF, quantile, and parameter access.
 * Uses SFINAE to enable distribution-specific properties (e.g., mean, stddev).
 * 
 * @tparam BoostDist The specific Boost distribution type (e.g., boost::math::normal_distribution).
 * @tparam R Numeric type (defaults to double).
 * @tparam ConstructorArgs Constructor argument types used to instantiate BoostDist.
 */
template<typename BoostDist, typename R, typename... ConstructorArgs>
class BoostBaseDensity {
private:
    /**
     * @brief Determines the support of the distribution using boost::math::support.
     * @param dist The distribution object.
     * @return The inferred support interval or (-inf, inf) if inference fails.
     */    
    static DensityInterval<R> get_safe_support(const BoostDist& dist) {
        try {
            // Use boost::math::support to get the theoretical support interval
            auto support_pair = boost::math::support(dist);
            R lower = support_pair.first;
            R upper = support_pair.second;
            return DensityInterval<R>(lower, upper);

        } catch (const std::exception& e) {
            // If boost::math::support fails (e.g., Cauchy distribution), default to (-inf, inf)
            std::cerr << "Warning: Could not determine finite support for distribution "
                      << typeid(dist).name() << ". Using (-inf, inf). Reason: " << e.what() << std::endl;
            return DensityInterval<R>(); // Default constructor gives (-inf, inf)
        } catch (...) {
             std::cerr << "Warning: Unknown error determining support for distribution "
                      << typeid(dist).name() << ". Using (-inf, inf)." << std::endl;
            return DensityInterval<R>();
        }
    }

    // --- Helper trait to distinguish constructors from copy/move ---
    // Checks if ArgTypes... is exactly one type which decays to BoostBaseDensity itself.
    template <typename... ArgTypes>
    struct is_this_class_signature : std::false_type {};

    template <typename SingleArg> // Specialization for a single argument
    struct is_this_class_signature<SingleArg> : std::is_same<
                                                    std::decay_t<SingleArg>,
                                                    BoostBaseDensity<BoostDist, R, ConstructorArgs...>
                                                > {};

protected:
    BoostDist dist_;
    DensityInterval<R> domain_;
    std::tuple<ConstructorArgs...> constructor_params_; // Store original constructor args

public:
   /**
     * @brief Constructs the Boost distribution using forwarded arguments.
     * 
     * Enabled only if BoostDist is constructible from Args, and Args is not copy/move.
     * 
     * @tparam Args Argument types
     * @param args Arguments to construct the BoostDist
     */
    template <typename... Args,
              std::enable_if_t<
                  std::is_constructible_v<BoostDist, Args...> &&
                  !is_this_class_signature<Args...>::value
              , int> = 0>
    explicit BoostBaseDensity(Args&&... args) // Use 'explicit' to prevent unintended conversions
        : dist_(std::forward<Args>(args)...)             // Construct the distribution
        , domain_(get_safe_support(dist_))               // Determine its domain
        , constructor_params_(std::forward<Args>(args)...) // Store the arguments used
    {}

    /// @name Rule of Five
    /// @{
    BoostBaseDensity(const BoostBaseDensity& other) = default;
    BoostBaseDensity& operator=(const BoostBaseDensity& other) = default;
    BoostBaseDensity(BoostBaseDensity&& other) noexcept = default; // Ensure noexcept if members are
    BoostBaseDensity& operator=(BoostBaseDensity&& other) noexcept = default;
    ~BoostBaseDensity() = default;
     /// @}

    /**
     * @brief Probability density function.
     * @param x Point at which to evaluate the PDF.
     * @return Value of the PDF or 0 if x is outside domain.
     */
    R pdf(R x) const {
        if (!isInDomain(x)) {
             // Return 0 for points outside the domain, common convention
             return R(0.0);
        }
        try {
            return boost::math::pdf(dist_, x);
        } catch (const std::exception& e) {
            // Handle potential boost errors (e.g., pdf at boundary for some distributions)
             std::cerr << "Warning: boost::math::pdf failed for " << typeid(dist_).name()
                       << " at x=" << x << ". Returning 0. Error: " << e.what() << std::endl;
             return R(0.0); // Or NaN: std::numeric_limits<R>::quiet_NaN();
        }
    }
    /**
     * @brief Cumulative distribution function.
     * @param x Point at which to evaluate the CDF.
     * @return Value in [0,1], or NaN if Boost call fails.
     */
    R cdf(R x) const {
        if (x <= domain_.lower) return R(0.0);
        if (x >= domain_.upper) return R(1.0);
        try {
            return boost::math::cdf(dist_, x);
        } catch (const std::exception& e) {
            std::cerr << "Warning: boost::math::cdf failed for " << typeid(dist_).name()
                      << " at x=" << x << ". Returning NaN. Error: " << e.what() << std::endl;
            return std::numeric_limits<R>::quiet_NaN(); 
        }
    }
    
    /**
     * @brief Computes the quantile (inverse CDF).
     * @param p Probability in [0, 1].
     * @return Quantile value or throws if p is invalid.
     */
    R quantile(R p) const {
        if (p < 0 || p > 1) {
            throw std::domain_error("Quantile probability p must be in [0, 1].");
        }
        // Handle exact boundaries to avoid potential issues with Boost functions
        if (p == 0) return domain_.lower;
        if (p == 1) return domain_.upper;
        try {
            R result = boost::math::quantile(dist_, p);
            // Clamped result to domain to handle potential numerical inaccuracies near boundaries
            return std::max(domain_.lower, std::min(domain_.upper, result));
        } catch (const std::exception& e) {

            throw std::runtime_error("Boost::math::quantile failed for " + std::string(typeid(dist_).name()) +
                                     " at p=" + std::to_string(p) + ". Reason: " + e.what());
        }
    }

   /**
     * @brief Checks if a value lies within the domain.
     * @param x Value to check.
     * @return True if in domain, false otherwise.
     */    
    bool isInDomain(R x) const noexcept { // Mark noexcept since comparisons/infinity checks don't throw
       if (std::isnan(x)) return false; // NaN is not in any valid domain
       bool lower_ok = (x >= domain_.lower);
       bool upper_ok = (x <= domain_.upper);
       // Explicit check for infinite bounds needed because standard comparisons with infinity work as expected
       return lower_ok && upper_ok;
    }

    /// @name Accessors
    /// @{
    const DensityInterval<R>& getDomain() const noexcept { return domain_; }
    const BoostDist& getDistribution() const noexcept { return dist_; }
    const std::tuple<ConstructorArgs...>& getConstructorParameters() const noexcept {
        return constructor_params_;
    }
    /// @}

    /// @name Distribution Properties (SFINAE-enabled)
    /// @{
    /** @brief Mean (if supported). */     
    template <typename D = BoostDist, typename = std::enable_if_t<has_boost_mean_v<D, R>>>
    R getMu() const { try { return boost::math::mean(dist_); } catch(...) { return std::numeric_limits<R>::quiet_NaN(); } }

    /** @brief Standard deviation (if supported). */
    template <typename D = BoostDist, typename = std::enable_if_t<has_boost_stddev_v<D, R>>>
    R getSigma() const { try { return boost::math::standard_deviation(dist_); } catch(...) { return std::numeric_limits<R>::quiet_NaN(); } }

    /** @brief Shape parameter (if supported). */
    template <typename D = BoostDist, typename = std::enable_if_t<has_boost_shape_v<D, R>>>
    R getShape() const { try { return dist_.shape(); } catch(...) { return std::numeric_limits<R>::quiet_NaN(); } }

    /** @brief Scale parameter (if supported). */
    template <typename D = BoostDist, typename = std::enable_if_t<has_boost_scale_v<D, R>>>
    R getScale() const { try { return dist_.scale(); } catch(...) { return std::numeric_limits<R>::quiet_NaN(); } }

    /** @brief Alpha parameter (if supported). */
    template <typename D = BoostDist, typename = std::enable_if_t<has_boost_alpha_v<D, R>>>
    R getAlpha() const { try { return dist_.alpha(); } catch(...) { return std::numeric_limits<R>::quiet_NaN(); } }

    /** @brief Beta parameter (if supported). */
    template <typename D = BoostDist, typename = std::enable_if_t<has_boost_beta_param_v<D, R>>>
    R getBeta() const { try { return dist_.beta(); } catch(...) { return std::numeric_limits<R>::quiet_NaN(); } }
    /// @}
};


/**
 * @brief Factory for a BoostBaseDensity using normal_distribution.
 * @tparam R Numeric type
 * @param args Parameters to construct boost::math::normal_distribution
 * @return Wrapped normal distribution
 */
template<typename R = traits::DataType::PolynomialField, typename... Args>
auto make_normal_density(Args&&... args) {
    using Dist = boost::math::normal_distribution<R>;
    // Correctly passes R and the decayed types of constructor args
    return BoostBaseDensity<Dist, R, std::decay_t<Args>...>(std::forward<Args>(args)...);
}

/**
 * @brief Factory for a BoostBaseDensity using gamma_distribution.
 * @tparam R Numeric type
 * @param args Parameters to construct boost::math::gamma_distribution
 * @return Wrapped gamma distribution
 */
template<typename R = traits::DataType::PolynomialField, typename... Args>
auto make_gamma_density(Args&&... args) {
    using Dist = boost::math::gamma_distribution<R>;
    return BoostBaseDensity<Dist, R, std::decay_t<Args>...>(std::forward<Args>(args)...);
}

/**
 * @brief Factory for a BoostBaseDensity using beta_distribution.
 * @tparam R Numeric type
 * @param args Parameters to construct boost::math::beta_distribution
 * @return Wrapped beta distribution
 */
template<typename R = traits::DataType::PolynomialField, typename... Args>
auto make_beta_density(Args&&... args) {
    using Dist = boost::math::beta_distribution<R>;
    return BoostBaseDensity<Dist, R, std::decay_t<Args>...>(std::forward<Args>(args)...);
}

} // namespace stats


#endif // DENSITY_BASE_HPP./include/stats/Quantization.hpp
/**
 * @file Quantization.hpp
 * @brief Implements quantization algorithms for vector quantization, including Newton's method (1D) and Competitive Learning Vector Quantization (CLVQ) for arbitrary dimensions.
 *
 * This header defines the `stats::Quantizer` class template and its specializations for different quantization procedures.
 * It provides a flexible framework for optimal quantizer design, supporting both batch (Newton's method for 1D) and online (CLVQ) learning.
 *
 * Main Components:
 * - `QuantizerBase`: Base class providing storage and access for quantizer centroids (hints) and the final quantization grid.
 * - `Quantizer<T, N_points, 1, QuantizationProcedure::Newton>`: Specialization for 1D quantization using Newton's method, optimized for the standard normal distribution.
 *   - Initializes centroids on a uniform grid.
 *   - Iteratively updates centroids using Newton's method, computing gradients and Hessians based on the quantization distortion for the normal distribution.
 * - `Quantizer<T, N_points, Dim_val, QuantizationProcedure::CLVQ>`: Specialization for arbitrary dimension using Competitive Learning Vector Quantization (CLVQ).
 *   - Initializes centroids by sampling from the standard normal distribution.
 *   - Performs online updates of centroids using a learning rate schedule and a winner-takes-all update rule.
 *   - Maintains and updates centroid weights (frequency of selection).
 *   - Tracks and reports distortion estimates during training.
 * 
 * Dependencies:
 * - OpenMP for parallelization.
 * - DensityBase.hpp for density functions.
 * - Utils.hpp for utility functions (e.g., sampling, distortion calculation).
 * 
 * Usage:
 * - Instantiate the appropriate `Quantizer` specialization with desired parameters.
 * - Call `run()` to perform quantization.
 * - Access the resulting quantization grid via `getQuantization()`.
 *
 * References:
 * - Optimal quantizers for standard Gaussian distribution (Printems, Paige)
 * - Optimal quadratic quantization for a Gauss-Markov source (Paige/Printems)
 *
 */
#ifndef QUANTIZATION_HPP
#define QUANTIZATION_HPP

#include <iostream>
#include <vector>
#include <array>
#include <cmath>        // For std::pow, std::abs
#include <algorithm>
#include <random>
#include <limits>       // For std::numeric_limits
#include <iomanip>      // For std::fixed, std::setprecision
#include <tuple>        // For std::tuple from Utils::argmin
#include <omp.h>        // OpenMP for parallelization
#include "../traits/OPOE_traits.hpp"
#include "../stats/DensityBase.hpp" // For OPOE::make_normal_density
#include "../utils/Utils.hpp"       // For Utils::argmin, Utils::sample_standard_normal_eigen, Utils::calculate_overall_distortion


// --- Namespace for Quantization ---
namespace stats {

/// @brief Type alias for quantization procedures defined in traits.
using QuantizationProcedure = traits::QuantizationProcedure;using StoringVector = traits::DataType::StoringVector;

/// @brief Type alias for vector storage type used in quantization.
using StoringVector = traits::DataType::StoringVector;

/// @brief Type alias for vector storage type used in quantization.
using QuantizerGrid = traits::DataType::StoringMatrix; // Eigen::Matrix<T, Dim, N> or Dynamic

/**
 * @brief Forward declaration of Quantizer class.
 * 
 * @tparam T Scalar type used (e.g., float, double).
 * @tparam N_points Number of quantization points (centroids).
 * @tparam Dim_val Dimension of the input space.
 * @tparam Procedure Quantization procedure strategy (e.g., Lloyd, Random).
 */
template <std::size_t N_points, std::size_t Dim_val, QuantizationProcedure Procedure, typename T = traits::DataType::PolynomialField>
class Quantizer;

/**
 * @brief Base class template for quantizer implementations.
 * 
 * This class provides a generic interface and common storage for quantization algorithms.
 * It defines and manages the quantizer grid (centroids) and hints (initial positions).
 * 
 * @tparam T Scalar type (e.g., float or double).
 * @tparam N_points Number of quantization points (must be > 0).
 * @tparam Dim_val Dimensionality of the input space (must be > 0).
 */
template <std::size_t N_points, std::size_t Dim_val, typename T = traits::DataType::PolynomialField>
class QuantizerBase {
public:
    static_assert(N_points > 0, "Number of quantization points (N_points) must be greater than 0.");
    static_assert(Dim_val > 0, "Dimension (Dim_val) must be greater than 0.");

    /**
     * @brief Default constructor for the base quantizer.
     * 
     * Initializes the `hints` and `quantization` matrices to zero-filled matrices
     * with dimensions Dim_val × N_points.
     */
    explicit QuantizerBase()
        : hints(Dim_val, N_points),      // Dim x N matrix
          quantization(Dim_val, N_points) {} // Dim x N matrix

    /**
     * @brief Virtual destructor.
     */
    virtual ~QuantizerBase() = default;

    /**
     * @brief Retrieves the current quantization grid (centroids).
     * 
     * @return const QuantizerGrid& Reference to the quantization matrix (Dim × N).
     */
    [[nodiscard]] const QuantizerGrid& getQuantization() const noexcept { return quantization; }

    /**
     * @brief Gets the number of quantization points.
     * 
     * @return std::size_t Number of quantizer centroids (N_points).
     */
    [[nodiscard]] std::size_t getNumPoints() const noexcept { return N_points; }

    /**
     * @brief Gets the dimensionality of the quantization space.
     * 
     * @return std::size_t Dimension of each quantization point (Dim_val).
     */
    [[nodiscard]] std::size_t getDim() const noexcept { return Dim_val; }

    /**
     * @brief Retrieves the initialization hints for the quantizer.
     * 
     * @return const QuantizerGrid& Reference to the hint matrix (Dim × N).
     */
    [[nodiscard]] const QuantizerGrid& getHints() const noexcept { return hints; }

protected:
    QuantizerGrid hints;         ///< Hint matrix (initial centroids) of size Dim × N_points.
    QuantizerGrid quantization;  ///< Final optimized quantizer grid of size Dim × N_points.
};

/**
 * @brief Specialization of Quantizer for 1D using Newton's method.
 * 
 * This class implements a 1D quantizer using Newton's method to minimize the distortion function
 * for a Gaussian distribution. It inherits from QuantizerBase and provides an optimization routine
 * based on analytical gradients and Hessians.
 * 
 * @tparam T Scalar type (e.g., float or double).
 * @tparam N_points Number of quantization points.
 */
template <std::size_t N_points, typename T>
class Quantizer< N_points, 1, QuantizationProcedure::Newton, T> : public QuantizerBase<N_points, 1, T> {
private:
    static constexpr std::size_t Dim = 1; // Explicitly state Dim for this specialization
public:
    /**
     * @brief Parameters for controlling Newton's method.
     */
    struct Params {
        T tolerance{1e-6};            ///< Convergence threshold for gradient norm.
        std::size_t max_iter{100};    ///< Maximum allowed iterations for optimization.

        /**
         * @brief Constructor for custom parameters.
         * 
         * @param tol Desired tolerance for convergence.
         * @param max_it Maximum number of iterations.
         */
        Params(T tol = 1e-5, std::size_t max_it = 1000)
            : tolerance(tol), max_iter(max_it) {}
    };

    /**
     * @brief Constructor for the 1D Newton quantizer.
     * 
     * Initializes the hint values and stores user-specified parameters.
     * 
     * @param params Parameters for the Newton optimization routine.
     */
    explicit Quantizer(const Params& params = Params{})
        : QuantizerBase<N_points, Dim, T>(), params_(params) {
        initializeHints();
    }

    /**
     * @brief Initializes hints using a uniform grid over [-4, 4].
     * 
     * The hints provide starting centroids for the optimization, evenly spaced in 1D.
     */
    void initializeHints() {
        constexpr T a_range = -4.0; // Range for uniform initialization [-4, 4]
        constexpr T b_range = 4.0;

        #pragma omp parallel for schedule(static)
        for (std::size_t i = 0; i < N_points; ++i) {
            // Uniform grid logic for Dim = 1
            // i-th point (0-indexed) value: a + (b-a) * (2*(i+1) - 1) / (2*N)
            // or more simply: a + (b-a) * (i + 0.5) / N
            this->hints(0, i) = a_range + (b_range - a_range) * (static_cast<T>(i) + static_cast<T>(0.5)) / static_cast<T>(N_points);
        }

    }

    /**
     * @brief Runs Newton's method to optimize quantizer centroids.
     * 
     * Uses analytical gradients and diagonal Hessian approximation to iteratively update centroids.
     * Updates the `quantization` matrix in the base class with the final result.
     */
    void run() {
        StoringVector x = this->hints.row(0).transpose(); ///< Current quantizer positions.
        StoringVector grad(N_points);                     ///< Gradient vector.
        StoringVector hessian_diag(N_points);             ///< Diagonal of Hessian matrix.

        std::cout << "[Info] Newton: Starting optimization for " << N_points << " points." << std::endl;

        for (std::size_t iter = 0; iter < params_.max_iter; ++iter) {
            computeGradientAndHessian(x, grad, hessian_diag);

            T grad_norm = grad.template lpNorm<Eigen::Infinity>(); // Max absolute gradient component
            // std::cout << "[Debug] Newton Iter " << iter << ": Grad Norm = " << grad_norm << std::endl;

            if (grad_norm < params_.tolerance) {
                std::cout << "[Info] Newton: Converged after " << iter << " iterations." << std::endl;
                break;
            }

            // Newton step: delta = -H^{-1} * grad. For diagonal H, H_ii^{-1} = 1/H_ii
            // Ensure no division by zero in hessian_diag before this step
            StoringVector delta = -grad.array() / hessian_diag.array();
            x += delta;

            if (iter == params_.max_iter - 1) {
                std::cout << "[Warning] Newton: Reached max iterations (" << params_.max_iter << ")." << std::endl;
            }
        }
        this->quantization.row(0) = x.transpose(); // Store result
     }

private:
    Params params_; ///< Newton method parameters.

    /**
     * @brief Computes the gradient and diagonal Hessian of the distortion function.
     * 
     * Uses Gaussian PDF and CDF to evaluate analytical expressions for each quantizer point.
     * 
     * @param q_points Current positions of quantizer centroids.
     * @param grad Output: gradient vector (N_points).
     * @param hess_diag Output: diagonal of Hessian matrix (N_points).
     */

    void computeGradientAndHessian(const StoringVector& q_points, // q_points is N_points x 1
                                   StoringVector& grad,
                                   StoringVector& hess_diag) {
        // grad and hess_diag should be N_points x 1
        grad.setZero();
        hess_diag.setConstant(static_cast<T>(1e-9)); // Small positive for stability

        auto normal_density = stats::make_normal_density(static_cast<T>(0.0), static_cast<T>(1.0));

        StoringVector a_boundaries(N_points), b_boundaries(N_points);

        // Voronoi boundaries: a_i = (q_{i-1} + q_i)/2, b_i = (q_i + q_{i+1})/2
        a_boundaries(0) = -std::numeric_limits<T>::infinity();
        if (N_points > 1) {
            for (std::size_t i = 1; i < N_points; ++i) {
                a_boundaries(i) = static_cast<T>(0.5) * (q_points(i - 1) + q_points(i));
            }
        }

        b_boundaries(N_points - 1) = std::numeric_limits<T>::infinity();
        if (N_points > 1) {
            for (std::size_t i = 0; i < N_points - 1; ++i) {
                b_boundaries(i) = static_cast<T>(0.5) * (q_points(i) + q_points(i + 1));
            }
        }
        
        // This is the formulation from "Optimal quantizers for standard Gaussian distribution" by Printems (2001) 
        // grad_i = 2 * ( q_i * (cdf(b_i) - cdf(a_i)) - (pdf(b_i) - pdf(a_i)) )  -- this formula seems reversed from a minimization perspective
        // Or from "Optimal quadratic quantization for a gauss Markov source" (Paige/Printems) where dD/dx_i is given
        // dD/dx_i = 2 * integral_{x_i in V_i} (x_i - y) phi(y) dy
        // For 1D, integral (x_i - y)phi(y)dy = x_i * (F(b_i)-F(a_i)) - (phi(a_i)-phi(b_i)) (using -phi'(y)=y*phi(y) so integral y*phi(y) = -phi(y))
        // The gradient of D = sum_i integral_{y in V_i} (y - q_i)^2 phi(y) dy w.r.t q_i is -2 * integral_{y in V_i} (y - q_i) phi(y) dy
        // = -2 * [ integral y*phi(y)dy - q_i * integral phi(y)dy ]
        // = -2 * [ (-phi(b_i) - (-phi(a_i))) - q_i * (F(b_i) - F(a_i)) ]
        // = -2 * [ phi(a_i) - phi(b_i) - q_i * (F(b_i) - F(a_i)) ]
        // =  2 * [ q_i * (F(b_i) - F(a_i)) - (phi(a_i) - phi(b_i)) ]
        // The Hessian (diagonal elements for 1D Lloyd-Max type problem) is d^2D/dq_i^2 = 2 * (F(b_i) - F(a_i))

        #pragma omp parallel for schedule(static)
        for (std::size_t i = 0; i < N_points; ++i) {
            T Fa = normal_density.cdf(a_boundaries(i));
            T Fb = normal_density.cdf(b_boundaries(i));
            T pdf_a = normal_density.pdf(a_boundaries(i));
            T pdf_b = normal_density.pdf(b_boundaries(i));

            T Z_i = Fb - Fa; // Probability mass in Voronoi cell i

            if (Z_i > std::numeric_limits<T>::epsilon()) { // Avoid division by zero or instability
                // Gradient component for q_i
                grad(i) = static_cast<T>(2.0) * (q_points(i) * Z_i - (pdf_a - pdf_b));
                // Hessian diagonal component for q_i
                hess_diag(i) = static_cast<T>(2.0) * Z_i;
                if (hess_diag(i) < static_cast<T>(1e-9)) { // Floor hessian component
                     hess_diag(i) = static_cast<T>(1e-9);
                }
            } else {
                grad(i) = static_cast<T>(0.0);
                hess_diag(i) = static_cast<T>(1.0); // Or a small stable value if Z_i is effectively zero
            }
        }
    }
};


/**
 * @brief Specialization of Quantizer using the Competitive Learning Vector Quantization (CLVQ) algorithm.
 * 
 * This implementation performs unsupervised quantization using a stochastic online learning procedure
 * where centroids (hints) are updated based on sampled data points and a dynamic learning rate schedule.
 * 
 * @tparam T           Scalar type (e.g., float, double).
 * @tparam N_points    Number of centroids (quantization points).
 * @tparam Dim_val     Dimensionality of the input space.
 */
template <std::size_t N_points, std::size_t Dim_val, typename T>
class Quantizer<N_points, Dim_val, QuantizationProcedure::CLVQ, T> : public QuantizerBase<N_points, Dim_val, T> {
public:
    /**
     * @brief Parameters for CLVQ quantizer training.
     */
    struct Params {
        T initial_gamma_0_base{0.1};               ///< Base learning rate scale factor.
        std::size_t epochs{10000};                 ///< Number of training iterations (samples processed).
        T convergence_tolerance{1e-5};             ///< Convergence threshold for distortion improvement.
        int distortion_check_interval{1000};       ///< Frequency (in iterations) to evaluate distortion.
        int num_samples_for_distortion_eval{5000}; ///< Number of samples used for evaluating distortion.

        /**
         * @brief Constructor for CLVQ parameters.
         * 
         * @param gamma_base   Base learning rate.
         * @param ep           Total epochs (iterations).
         * @param tol          Convergence tolerance.
         * @param dist_interval Distortion check frequency.
         * @param dist_samples Number of samples for distortion computation.
         */
        Params(T gamma_base = 0.1, std::size_t ep = 10000, T tol = 1e-5, int dist_interval = 1000, int dist_samples = 5000)
            : initial_gamma_0_base(gamma_base), epochs(ep), convergence_tolerance(tol),
              distortion_check_interval(dist_interval), num_samples_for_distortion_eval(dist_samples) {}
    };

    /**
     * @brief Constructor for the CLVQ Quantizer.
     * 
     * @param params Optional parameter struct for training configuration.
     */
    explicit Quantizer(const Params& params = Params{})
        : QuantizerBase<N_points, Dim_val, T>(), params_(params),
          weights_(StoringVector::Constant(N_points, static_cast<T>(1.0) / static_cast<T>(N_points))) {
        initializeHints();
    }

    /**
     * @brief Initializes centroids (hints) with samples from a standard normal distribution.
     */
    void initializeHints() {
        std::random_device rd;
        std::mt19937 gen(rd());
        std::normal_distribution<T> dist(static_cast<T>(0.0), static_cast<T>(1.0));

        // this->hints is Dim_val x N_points
        this->hints = Utils::sampler<T>(gen, dist, Dim_val, N_points);
    }

    /**
     * @brief Runs the CLVQ training loop.
     * 
     * Samples data points from a standard normal distribution, updates centroids using a
     * soft competitive learning rule, and monitors convergence via distortion.
     */
    void run() {
        std::random_device rd_train, rd_dist;
        std::mt19937 training_generator(rd_train());
        std::mt19937 distortion_eval_generator(rd_dist());
        std::normal_distribution<T> standard_normal_dist(static_cast<T>(0.0), static_cast<T>(1.0));

        // --- Initial Overall Distortion ---
        T last_overall_distortion = Utils::calculate_overall_distortion<T, Dim_val>(
            this->hints, params_.num_samples_for_distortion_eval, distortion_eval_generator, standard_normal_dist
        );
        std::cout << "[Info] CLVQ Initial Overall Distortion: " << last_overall_distortion << std::endl;

        // --- Learning Rate (gamma) Parameters ---
        const T initial_gamma_0 = params_.initial_gamma_0_base; // Simpler: use base directly

        const T K_centroids = static_cast<T>(N_points);

        const T const_a_lr = 4.0 * std::pow(K_centroids, 1.0 / static_cast<T>(Dim_val));
        const T const_b_lr = M_PI * M_PI * std::pow(K_centroids, -2.0 / static_cast<T>(Dim_val));

        // --- Online Distortion Estimate (EMA) ---
        T online_distortion_estimate_ema = last_overall_distortion; // Initialize with the first true calculation

        std::cout << "[Info] CLVQ: Starting training for " << params_.epochs << " samples." << std::endl;
        std::cout << "[Info] CLVQ: Centroid matrix dimensions: " << this->hints.rows() << "x" << this->hints.cols() << std::endl;

        for (std::size_t iter_idx = 0; iter_idx < params_.epochs; ++iter_idx) {
            // 1. Sample a data point (eta)
            StoringVector eta = Utils::sampler<T>(
                training_generator, standard_normal_dist, Dim_val // Dim_val for dimension, 1 sample
            );

            // 2. Find the winning centroid for eta
            auto argmin_result = Utils::argmin<T>(this->hints, eta); // Returns std::tuple<int, T, RowVector>
            int winner_index = std::get<0>(argmin_result);
            T l2_dist_eta_to_winner = std::get<1>(argmin_result);

            if (winner_index == -1) {
                std::cerr << "[Warning] CLVQ Iter " << iter_idx << ": No winning centroid found. Skipping update." << std::endl;
                continue;
            }

            // 3. Calculate learning rate (gamma)
            T time_step_t = static_cast<T>(iter_idx + 1);
            T gamma = initial_gamma_0 * const_a_lr / (time_step_t * const_b_lr * initial_gamma_0 + const_a_lr);



            // 4. Update centroid
            this->hints.col(winner_index) += gamma * (eta - this->hints.col(winner_index));

            // 5. Update weights (conscience mechanism / frequency counting)
            if (this->weights_.size() == N_points) { // Safety check
                 this->weights_ *= (static_cast<T>(1.0) - gamma); // Decay all
                 this->weights_(winner_index) += gamma;         // Increment winner
            }


            // 6. Update online distortion estimate (EMA)
            T squared_l2_dist_eta_to_winner = l2_dist_eta_to_winner * l2_dist_eta_to_winner;
            online_distortion_estimate_ema = (static_cast<T>(1.0) - gamma) * online_distortion_estimate_ema + gamma * squared_l2_dist_eta_to_winner;

            
        }

        // --- Final Evaluation & Printouts ---
        T final_overall_distortion = Utils::calculate_overall_distortion<T, Dim_val>(
            this->hints, params_.num_samples_for_distortion_eval * 2, // Use more samples for final
            distortion_eval_generator, standard_normal_dist
        );
        this->quantization = this->hints; // Store the final learned hints as the quantization result

        std::cout << "[Info] CLVQ training finished." << std::endl;
        std::cout << "[Info] CLVQ Final Overall Distortion: " << std::fixed << std::setprecision(6) << final_overall_distortion << std::endl;
        if (this->weights_.size() > 0) {
             std::cout << "[Info] CLVQ Sum of final weights: " << this->weights_ << std::endl;
             // std::cout << "[Info] CLVQ Final weights (transpose):\n" << this->weights_.transpose() << std::endl;
        }
    }

private:
    Params params_;
    StoringVector weights_; // StoringVector should be N_points x 1
};

} // namespace stats
#endif  // QUANTIZATION_HPP./include/stats/MixtureDensity.hpp

/**
 * @file MixtureDensity.hpp
 * @brief Defines the MixtureDensity class template for representing and manipulating mixtures of probability density functions (PDFs) with orthogonal polynomial bases.
 *
 * Dependencies:
 * - DensityBase.hpp: Base class for probability density functions.
 * - OrthogonalPolynomials.hpp: For polynomial operations and orthogonal polynomial bases.
 * @details
 * This header provides a flexible framework for constructing mixtures of various probability distributions (e.g., Normal, Gamma, Beta) and associating each component with its corresponding orthogonal polynomial basis (e.g., Hermite, Laguerre, Jacobi).
 * The MixtureDensity class supports:
 *   - Validation and storage of mixture weights and component densities.
 *   - Automatic selection and construction of the appropriate polynomial basis for each component via DensityToPolyTraits.
 *   - Computation of recursion coefficients for orthonormal polynomial basis construction using the mixture's weighted inner product.
 *   - Construction of the orthonormal polynomial basis for the mixture, including storage of polynomial coefficients and function representations.
 *   - Calculation of the mixture's PDF and CDF at arbitrary points.
 *   - Access to component parameters, polynomial bases, Jacobi matrices, and projection matrices.
 *   - Prevention of copy semantics for safety, with move semantics enabled.
 *
 * @note
 * - Requires C++17 or later for features such as std::variant, std::apply, and fold expressions.
 * - Relies on Eigen for matrix and vector operations, and OpenMP for parallelization.
 * - Assumes that DensityType classes provide methods: pdf(x), cdf(x), getMu(), getSigma(), getAlpha(), getBeta(), getShape(), getScale(), getDomain(), getDistribution(), and getConstructorParameters().
 * - The polynomial basis construction is tailored to the type of each component via DensityToPolyTraits specializations.
 *
 * @section MixtureDensity_Usage Usage Example
 * @code
 * using Mixture = stats::MixtureDensity<3, stats::NormalDensity>;
 * std::vector<double> weights = {0.5, 0.5};
 * std::vector<stats::NormalDensity> components = {stats::make_normal_density(0.0, 1.0), stats::make_normal_density(2.0, 1.0)};
 * Mixture mixture(weights, components);
 * mixture.constructOrthonormalBasis();
 * double value = mixture.pdf(1.0);
 * @endcode
 *
 *  */
#ifndef MIXTURE_DENSITY_HPP
#define MIXTURE_DENSITY_HPP



#include <vector>
#include <variant>
#include <numeric>      
#include <stdexcept>
#include <limits>
#include <iostream>
#include <typeinfo>     
#include <tuple>        
#include <utility>      
#include <functional>  
#include "DensityBase.hpp" 
#include "../polynomials/OrthogonalPolynomials.hpp"

namespace stats {
/// @brief Alias for a normal distribution wrapped in BoostBaseDensity.
/// @note Uses example parameters (mean = 0.0, stddev = 1.0).
using NormalDensity = decltype(stats::make_normal_density(0.0, 1.0)); 

/// @brief Alias for a gamma distribution wrapped in BoostBaseDensity.
/// @note Uses example parameters (shape = 1.0, scale = 1.0).
using GammaDensity  = decltype(stats::make_gamma_density(1.0, 1.0));  

/// @brief Alias for a beta distribution wrapped in BoostBaseDensity.
/// @note Uses example parameters (alpha = 1.0, beta = 1.0).
using BetaDensity   = decltype(stats::make_beta_density(1.0, 1.0));   

/**
 * @brief Alias for a compile-time polynomial type.
 * 
 * @tparam N Degree of the polynomial.
 * @tparam R Real number type (default: double).
 */
template <unsigned int N, typename R = traits::DataType::PolynomialField>
using Polynomial = polynomials::Polynomial<N, R>;

/// @brief A variant type that can hold any supported Boost density type.
using DensityVariant = std::variant<
        NormalDensity,
        GammaDensity,
        BetaDensity>;  
/**
 * @brief Traits class mapping a Density type to its associated orthogonal polynomial type.
 * 
 * This base template is used to generate a meaningful static_assert failure for unsupported types.
 * 
 * @tparam Density The density distribution type.
 * @tparam N Degree of the polynomial.
 * @tparam R Real number type.
 */
template<typename Density, unsigned int N, typename R>
struct DensityToPolyTraits {
    // Error for unsupported types
    static_assert(!std::is_same_v<Density, Density>, "Unsupported DensityType for MixtureDensity");
};

/**
 * @brief Specialization mapping NormalDensity to HermitePolynomial.
 * 
 * @tparam N Degree of the polynomial.
 * @tparam R Real number type.
 */
template<unsigned int N, typename R>
struct DensityToPolyTraits<NormalDensity, N, R> {
    using PolyType = polynomials::HermitePolynomial<N, R>; 

    /**
     * @brief Creates a Hermite polynomial associated with the given normal density.
     * 
     * @param density_component The normal distribution component.
     * @return HermitePolynomial initialized with mean and stddev.
     */
    static PolyType create(const NormalDensity& density_component) {
    
        return PolyType(density_component.getMu(), density_component.getSigma());
    }
};

/**
 * @brief Specialization mapping BetaDensity to JacobiPolynomial.
 * 
 * @tparam N Degree of the polynomial.
 * @tparam R Real number type.
 */
template<unsigned int N, typename R>
struct DensityToPolyTraits<BetaDensity, N, R> {
    using PolyType = polynomials::JacobiPolynomial<N, R>;
    /**
     * @brief Specialization mapping BetaDensity to JacobiPolynomial.
     * 
     * @tparam N Degree of the polynomial.
     * @tparam R Real number type.
     */

    static PolyType create(const BetaDensity& density_component) {
        
        return PolyType(density_component.getAlpha(), density_component.getBeta());
    }
};

/**
 * @brief Specialization mapping GammaDensity to LaguerrePolynomial.
 * 
 * @tparam N Degree of the polynomial.
 * @tparam R Real number type.
 */

template<unsigned int N, typename R>
struct DensityToPolyTraits<GammaDensity, N, R> {
    using PolyType = polynomials::LaguerrePolynomial<N, R>; 
    
    /**
     * @brief Creates a Laguerre polynomial associated with the given gamma density.
     * 
     * @param density_component The gamma distribution component.
     * @return LaguerrePolynomial initialized with shape - 1 and scale.
     */
    static PolyType create(const GammaDensity& density_component) {

        return PolyType(density_component.getShape() - 1, 
                        density_component.getScale()); 
    }
};


/**
 * @brief MixtureDensity class template for polynomial-based mixture density estimation.
 * 
 * @tparam PolynomialBaseDegree Degree of the polynomial basis.
 * @tparam DensityType Type of the density components (e.g., NormalDensity, GammaDensity).
 * @tparam R Floating-point type used for calculations (default is double).
 * 
 * This class represents a mixture model composed of weighted density components.
 * It supports polynomial basis construction for density approximation and
 * provides methods for computing PDF, CDF, and orthonormal polynomial bases.
 */
template<unsigned int PolynomialBaseDegree, typename DensityType, typename R = traits::DataType::PolynomialField>
class MixtureDensity{

public:
    using PolyType = Polynomial<PolynomialBaseDegree, R>;  // Polynomial class/type
    using StoringArray = traits::DataType::StoringArray;  // Storage for polynomials
    using StoringVector = traits::DataType::StoringVector;  // Storage for polynomials
    using JacobiMatrixType = traits::DataType::SparseStoringMatrix;  // Storage for matrix J
    using StoringMatrix = traits::DataType::StoringMatrix;  // Storage for matrix J

protected: // Protected so derived classes can potentially access if needed
    std::vector<R> weights_;                   // Weights for each component in the mixture
    std::vector<DensityType> components_;      // Density components of the mixture
    std::vector<JacobiMatrixType> Js;          // Jacobi matrices for polynomial evaluation
    StoringArray a;                            // Coefficients for polynomial evaluation
    StoringArray b;                            // Coefficients for polynomial evaluation
    std::vector<PolyType> polynomials;         // Precomputed polynomial solutions
    StoringMatrix H;                           // Matrix for polynomial coefficients (H matrix)
    std::vector<StoringMatrix> Hs;             // Vector of H matrices for each component
    std::vector<std::vector<std::function<R(R)>>> HPol_components; // Vector of function pointers for each mixture component
    std::vector<std::function<R(R)>> HPol_mixture;                  // Vector of function pointers for the overall mixture
    std::vector<StoringMatrix> Qs;                                 // Projection matrices for each component

public:

    /**
     * @brief Constructor initializing the mixture density with given weights and components.
     * 
     * @param weights Vector of component weights. Must be non-empty and sum to 1.
     * @param components Vector of density components, must match size of weights.
     * 
     * @throws std::invalid_argument if weights are empty, do not sum to 1, contain negatives,
     *         or if size mismatch with components.
     */    
    MixtureDensity(std::vector<R> weights, std::vector<DensityType> components)
        : weights_(std::move(weights)), components_(std::move(components)), a(PolynomialBaseDegree + 1), b(PolynomialBaseDegree), polynomials(PolynomialBaseDegree + 2), H(PolynomialBaseDegree + 1, PolynomialBaseDegree + 1)
 
    {
        if (weights_.empty()) {
             throw std::invalid_argument("Mixture Density cannot be empty (no weights).");
        }
        if (weights_.size() != components_.size()) {
            throw std::invalid_argument("Number of weights must match the number of components.");
        }

        // Validate weights sum to approximately 1
        R sum_weights = std::accumulate(weights_.begin(), weights_.end(), R(0.0));
        constexpr R epsilon_multiplier = 100;
        if (std::abs(sum_weights - R(1.0)) > std::numeric_limits<R>::epsilon() * epsilon_multiplier) {
             throw std::invalid_argument("Component weights must sum to 1. Current sum: " + std::to_string(sum_weights));
        }

        // Ensure no negative weights
        for(const auto& w : weights_) {
            if (w < R(0.0)) {
                 throw std::invalid_argument("Component weights cannot be negative.");
            }
        }

        Js.reserve(components.size());
        for (const auto& component : components_) {
    
            // 1. Create the polynomial traits for the current component
            using PolyTraits = DensityToPolyTraits<DensityType, PolynomialBaseDegree, R>;

            auto curr_comp_poly = PolyTraits::create(component); 
        
            // 2. Get the Jacobi matrix (assuming it's available)
            Js.push_back(curr_comp_poly.getJacobiMatrix());
            Hs.push_back(curr_comp_poly.getHMatrix());
            std::vector<std::function<R(R)>> curr_vec;
            curr_vec.reserve(PolynomialBaseDegree + 1);

            for (unsigned int idx = 0; idx <= PolynomialBaseDegree; ++idx) {
                auto temp_poly = Polynomial<PolynomialBaseDegree, R>(curr_comp_poly.getHMatrix().col(idx));

                curr_vec.push_back(temp_poly.as_function());
            }
            HPol_components.push_back(curr_vec);

        }

    }

    
    /**
     * @brief Computes the combined support interval of the mixture density.
     * 
     * @return stats::DensityInterval<R> representing the overall support covering all components.
     * @throws std::runtime_error if no components exist.
     */
    stats::DensityInterval<R> getSupport() const {
        // Assuming all components have the same support
        if (components_.empty()) {
            throw std::runtime_error("No components available to determine support.");
        }
    
        stats::DensityInterval<R> overall_support = components_[0].getDomain(); // Assumes components_[0] exists due to the check above

        // Iterate through the rest of the components to find the min lower and max upper bounds
        for (size_t i = 1; i < components_.size(); ++i) {
            stats::DensityInterval<R> component_support = components_[i].getDomain();
            
            if (component_support.lower < overall_support.lower) {
                overall_support.lower = component_support.lower;
            }
            if (component_support.upper > overall_support.upper) {
                overall_support.upper = component_support.upper;
            }
        }
    
        // The DensityInterval constructor already checks if lower > upper.
        // If overall_support.lower ended up > overall_support.upper (e.g., if components_
        // had disjoint and strangely ordered supports, which shouldn't happen for typical densities),
        // the DensityInterval constructor will throw.
        return overall_support;
    }
    
    /**
     * @brief Computes the recursion coefficients (a, b) for the orthonormal polynomial basis.
     * 
     * This method calculates the three-term recurrence coefficients
     * for the polynomial basis constructed from the mixture components.
     * 
     * @throws std::runtime_error on numerical instability or invalid inputs.
     */

    void computeRecursionCoeffs() {
        unsigned int N_J = PolynomialBaseDegree + 1; // Number of basis elements (0 to N) -> Size of vectors/coeffs
        unsigned int N_K = weights_.size();          // Number of mixture components
        StoringArray csi = StoringArray::Zero(N_J);  // Intermediate norm^2 values (psi in paper notation) 

        if (N_K == 0) {
             throw std::runtime_error("Cannot construct basis with zero components.");
        }
         if (N_J == 0) {
             // Handle degree 0 case: basis is just H_0(x) = 1.
             a.setZero(); // Size 1
             b.setZero(); // Size 1 or 0 depending on convention
             csi.setOnes(); // csi[0] = <1,1>_w = 1
             return;
         }


        // --- Initialization ---
        std::vector<StoringVector> z_prev(N_K); // Stores z_{i-1} for component j
        std::vector<StoringVector> z_curr(N_K); // Stores z_i for component j

        #pragma omp parallel for
        for (size_t j = 0; j < N_K; ++j) {
            z_prev[j] = StoringVector::Zero(N_J);
            z_curr[j] = StoringVector::Zero(N_J);
            if (N_J > 0) {
               z_curr[j](0) = R(1.0); // H_0 = 1, so initial vector is e_1
            }
        }

        constexpr R tolerance = std::numeric_limits<R>::epsilon() * 100;

        // Temporary storage for the next iteration's vectors (for parallel update)
        std::vector<StoringVector> z_next(N_K);
        #pragma omp parallel for
        for(size_t j=0; j< N_K; ++j) {
             z_next[j].resize(N_J); // Pre-allocate
        }

        // --- Main Recurrence Loop (over degree i) ---
        for (size_t i = 0; i < N_J; ++i) {
            R phi_i_local = R(0.0); // Accumulator for <z_i, J z_i>_w for this iteration
            R csi_i_local = R(0.0); // Accumulator for <z_i, z_i>_w for this iteration

            // --- Parallel Calculation of phi_i and csi_i ---
            #pragma omp parallel for reduction(+:phi_i_local, csi_i_local) schedule(static)
            for (size_t j = 0; j < N_K; ++j) {
                // Ensure Js[j] and z_curr[j] are valid
                 if (z_curr[j].size() != N_J || Js[j].rows() != N_J || Js[j].cols() != N_J) {
                     #pragma omp critical
                     {
                         throw std::runtime_error("Dimension mismatch inside parallel loop at i="
                            + std::to_string(i) + ", j=" + std::to_string(j));
                     }
                 }

                // Weighted inner product for phi: w_j * z_curr[j]^T * Js[j] * z_curr[j]
                R contribution_phi = (z_curr[j].transpose() * Js[j] * z_curr[j]).value();
                phi_i_local += weights_[j] * contribution_phi;

                // Weighted squared norm for csi: w_j * ||z_curr[j]||^2
                R contribution_csi = z_curr[j].squaredNorm();
                csi_i_local += weights_[j] * contribution_csi;
            } // End parallel reduction loop

            // Store result in the variable `csi`
            csi[i] = csi_i_local;


            // --- Compute Recurrence Coefficients a[i] and b[i] ---
            if (std::abs(csi[i]) < tolerance) {
                 // Handling of potential division by zero or instability
                 throw std::runtime_error("Numerical instability: csi[" + std::to_string(i) + "] is near zero.");
            }

            a[i] = phi_i_local / csi[i];

            // Calculate b coefficient needed for the *next* step's z update
            // (This loop computes up to a_N, b_{N-1}, csi_N based on i < N_J)
            // We actually need b[i] based on csi[i+1] for updating z_{i+1} later.

            // The update formula is: z_{k+1} = (J_k - a_k I)z_k - b_{k-1}^2 z_{k-1} 


            R b_im1_sq = R(0.0);
            if (i > 0) {
                 // We need b[i-1], which depends on csi[i] / csi[i-1]
                 if (std::abs(csi[i - 1]) < tolerance) {
                    throw std::runtime_error("Numerical instability: csi[" + std::to_string(i-1) + "] is near zero when calculating b[" + std::to_string(i-1) + "].");
                 }
                 R ratio = csi[i] / csi[i - 1];
                 if (ratio < -tolerance) { // Check for significant negativity
                    throw std::runtime_error("Numerical instability: Negative ratio csi["+std::to_string(i)+"]/csi["+std::to_string(i-1)+"] for b[" + std::to_string(i-1) + "] calculation.");
                 }
                 ratio = std::max(R(0.0), ratio); // Clamp near-zero negative due to precision
                 b[i - 1] = std::sqrt(ratio); // Store b[i-1]
                 b_im1_sq = ratio;            // Use the ratio (b[i-1]^2) for the update step
            } 

            // --- Parallel Update of z vectors ---
            // Calculate z_{next} = (J - a[i] * I) * z_curr - b[i-1]^2 * z_prev
            // If i == N_J - 1 (last iteration), this step might be skippable unless z vectors are needed later.
             if (i < PolynomialBaseDegree) // Only need to update z if we haven't reached the max degree
             {
                 #pragma omp parallel for schedule(static)
                 for(size_t j = 0; j < N_K; ++j) {
                     // Compute (Js[j] - a[i] * I) * z_curr[j]
                     z_next[j].noalias() = Js[j] * z_curr[j]; // Sparse matrix-vector product is efficient
                     z_next[j].noalias() -= a[i] * z_curr[j]; // Scale and subtract

                     // Subtract term involving z_prev if i > 0
                     if (i > 0) {
                         z_next[j].noalias() -= b_im1_sq * z_prev[j]; // Use precomputed square b[i-1]^2
                     }
                 } // End parallel update loop

                 // --- Update z_prev and z_curr for the next iteration (Serial) ---
                 // Using swap is often robust for parallel temporary storage patterns
                 for(size_t j = 0; j < N_K; ++j) {
                     z_prev[j] = std::move(z_curr[j]); // Old z_curr becomes z_prev
                     z_curr[j] = std::move(z_next[j]); // Result from z_next becomes new z_curr
                     // z_next[j] is now in a moved-from state, ready for reallocation/reuse
                     // For Eigen, resize might be needed if move semantics empty it:
                     z_next[j].resize(N_J); // Ensure it's ready for the next iteration's write
                 }
            } // end if (i < PolynomialBaseDegree)

        } // End i loop (main recurrence)

    } // End computeRecursionCoeffs
    
    /**
     * @brief Constructs the orthonormal polynomial basis for the mixture density.
     * 
     * Calls computeRecursionCoeffs() internally and then builds the polynomial
     * basis up to the specified PolynomialBaseDegree.
     */
    void constructOrthonormalBasis() {
        computeRecursionCoeffs();
        
        #pragma omp parallel for simd
        for (unsigned int i = 0; i < PolynomialBaseDegree + 2; ++i) {
            polynomials[i] = PolyType(StoringArray::Zero(PolynomialBaseDegree + 1));
        }
        
        // P₀(x) is implicitly zero.
        // P₁(x) = 1 (coefficient of x⁰ is 1)
        if (PolynomialBaseDegree + 1 > 0) {
            polynomials[1].get_coeff()(0) = 1.0;
        }
        H.col(0) = polynomials[1].get_coeff();
        HPol_mixture.push_back(polynomials[1].as_function()); // Store the first polynomial as a function
        if constexpr (PolynomialBaseDegree == 0) {
            
                return;
        }
    
    
        // --- Sequential Recurrence Calculation ---
    
        StoringArray P_kp1_coeffs(PolynomialBaseDegree + 1);
  
        for (unsigned int k = 1; k <= PolynomialBaseDegree; ++k) {

    
            // Get references to coefficients of P_k and P_{k-1}
            const auto& P_k_coeffs = polynomials[k].get_coeff();
            const auto& P_km1_coeffs = polynomials[k - 1].get_coeff();
            const auto& beta_kp = b[k - 1]; // beta_k+1
            const auto& alpha_k = a[k - 1]; // alpha_k-1
            const auto& beta_k = (k == 1) ?  0 : b[k - 2];

    
            // 1. Compute x * P_k (results in higher degree, store temporarily)
            P_kp1_coeffs.setZero(); // Clear previous iteration's result
            // Shift P_k's coefficients: P_k[i] -> (x*P_k)[i+1]
            // Copies P_k[0..N-1] to P_kp1_coeffs[1..N]
            P_kp1_coeffs.segment(1, PolynomialBaseDegree) = P_k_coeffs.head(PolynomialBaseDegree);
    
            // 2. Subtract alpha_km1 * P_k
            P_kp1_coeffs -= alpha_k * P_k_coeffs;
    
            // 3. Subtract beta_km1 * P_{k-1}
            // P_kp1_coeffs -= beta_km1 * P_km1_coeffs;

            P_kp1_coeffs -= beta_k* P_km1_coeffs;
            P_kp1_coeffs /= beta_kp; // Normalize by sqrt(beta_k)
            // --- End of Eigen calculation ---
    
            // Store the final coefficients for P_{k+1}
            H.col(k) = P_kp1_coeffs;
            polynomials[k + 1].set_coeff(P_kp1_coeffs);
            HPol_mixture.push_back(polynomials[k + 1].as_function()); 
        }


        } // End constructOrthonormalBasis
    

    /**
     * @brief Constructs the Q-projection matrices for the mixture.
     * 
     * Placeholder function to compute Q matrices based on H matrices of components.
     * Implementation depends on specific application needs.
     */
    void constructQProjectionMatrix() {
        // This function implements the logic to construct the Q-projection matrix
        // based on the orthonormal basis and other relevant parameters.

        for (const auto & hk : Hs) {
            Qs.push_back(hk.triangularView<Eigen::Upper>().solve(getHMatrix())); 
        }
    }

    /**
     * @brief Virtual destructor.
     */
    virtual ~MixtureDensity() = default;

    /**
     * @brief Evaluates the probability density function (PDF) of the mixture at a given point.
     * 
     * @param x The point at which to evaluate the PDF.
     * @return R The PDF value at x.
     */  
    R pdf(R x) const {
        R total_pdf = R(0.0);
        for (size_t i = 0; i < components_.size(); ++i) {
             // Directly call pdf on the known component type
            total_pdf += weights_[i] * components_[i].pdf(x);
        }
        return total_pdf;
    }

    /**
     * @brief Evaluates the cumulative distribution function (CDF) of the mixture at a given point.
     * 
     * @param x The point at which to evaluate the CDF.
     * @return R The CDF value at x, clamped between 0 and 1.
     */
    R cdf(R x) const {
        R total_cdf = R(0.0);
        for (size_t i = 0; i < components_.size(); ++i) {
            // Directly call cdf on the known component type
            total_cdf += weights_[i] * components_[i].cdf(x);
        }
        // Clamp CDF result
        return std::max(R(0.0), std::min(R(1.0), total_cdf));
    }

    /**
     * @brief Computes the mean of the mixture density.
     * 
     * @return R The weighted mean of the mixture components.
     */
    R mean() const {
        R total_mean = R(0.0);
        for (size_t i = 0; i < components_.size(); ++i) {
            total_mean += weights_[i] * components_[i].getMu();
        }
        return total_mean;
    }

    /** * @brief Computes the variance of the mixture density.
     * 
     * @return R The weighted variance of the mixture components.
     */
    R variance() const {
        R total_variance = R(0.0);
        for (size_t i = 0; i < components_.size(); ++i) {
            R mu = components_[i].getMu();
            R sigma = components_[i].getSigma();
            total_variance += weights_[i] * (sigma * sigma + mu * mu);
        }
        return total_variance - mean() * mean();
    }
    

    /**
     * @brief Prints the parameters of each component in the mixture to standard output.
     * 
     * Assumes DensityType provides getDistribution() and getConstructorParameters().
     */



    void printComponentParameters() const {
        std::cout << "--- Mixture Components ---\n";
        if (components_.empty()) {
            std::cout << "  (No components)\n";
            std::cout << "------------------------------------\n";
            return;
        }

        // Print overall type once (assuming all components have same underlying Boost type)
         const auto& first_comp_dist = components_[0].getDistribution();
         std::cout << "  Mixture Type: " << typeid(first_comp_dist).name() << "\n"; // Might be mangled

        for (size_t i = 0; i < components_.size(); ++i) {
            std::cout << "  Component " << i << " (Weight: " << weights_[i] << "): ";

            // Get the tuple containing the original constructor parameters
            const auto& params_tuple = components_[i].getConstructorParameters();

            // Use std::apply and a fold expression (C++17) to print tuple elements
            std::cout << "Params=(";
            std::apply([](const auto&... args){
                bool first = true;
                auto print_arg = [&](const auto& arg){
                    if (!first) std::cout << ", ";
                    std::cout << arg;
                    first = false;
                };
                (print_arg(args), ...);
            }, params_tuple);
            std::cout << ")" << std::endl;
        }
         std::cout << "------------------------------------\n";
    }

    /**
     * @brief Retrieves the orthonormal polynomial of a specified degree.
     * 
     * @param degree Degree of the polynomial requested (0-based).
     * @return const PolyType& Reference to the polynomial of the requested degree.
     * @throws std::out_of_range if degree exceeds PolynomialBaseDegree.
     */
    const PolyType& getPolynomial(unsigned int degree) const {
        if (degree > PolynomialBaseDegree) {
            throw std::out_of_range("Requested degree exceeds max polynomial degree.");
        }
        return polynomials[degree + 1];
    }

    /**
     * @brief Retrieves the matrix H storing polynomial coefficients.
     * 
     * @return StoringMatrix Matrix H.
     */
    StoringMatrix getHMatrix() const noexcept {
        return H;
    }

    /**
     * @brief Retrieves the vector of Q projection matrices.
     * 
     * @return auto Vector of Q matrices.
     */
    const auto getQProjectionMatrix() const noexcept {
        return Qs;
    }

    /**
     * @brief Retrieves the vector of H matrices for each component.
     * 
     * @return auto Vector of H matrices.
     */
    const auto getHMatrixs() const noexcept {
        return Hs;
    }

    /**
     * @brief Retrieves the vector of Jacobi matrices for each component.
     * 
     * @return auto Vector of Jacobi matrices.
     */
    const auto getJacobiMatrix() const noexcept {
        return Js;
    }

    /**
     * @brief Retrieves the vector of orthonormal polynomial functions for each component.
     * 
     * @return auto Vector of function pointers for each component's polynomial.
     */

    const auto getHFunctionsComponents() const noexcept {
        return HPol_components;
    }

    /**
     * @brief Retrieves the vector of orthonormal polynomial functions for the mixture.
     * 
     * @return auto Vector of function pointers for the mixture's polynomial.
     */
    const auto getHFunctionsMixture() const noexcept {
        return HPol_mixture;
    }

    /// @name Accessors
    /// @{
    /**
     * @brief Retrieves the mixture's components, weights, Jacobi matrices, and coefficients.
     * 
     * @return const std::vector<DensityType>& Reference to the vector of density components.
     */
    const std::vector<DensityType>& getComponents() const noexcept { return components_; }
    const std::vector<R>& getWeights() const noexcept { return weights_; }
    const std::vector<JacobiMatrixType>& getMatrices() const noexcept { return Js; }
    const StoringArray& getA() const noexcept { return a; }
    const StoringArray& getB() const noexcept { return b; }
    /// @}

    /**
     * @brief Returns the number of components in the mixture.
     * 
     * @return size_t Number of components.
     */
    size_t size() const noexcept { return components_.size(); }

    /**
     * @brief Checks if the mixture is empty (no components).
     * 
     * @return true if the mixture has no components, false otherwise.
     */
    bool empty() const noexcept { return components_.empty(); }
    
    /// Prevent copy semantics for safety
    // Copy constructor and assignment operator are deleted to prevent copying
    // This is to ensure that the MixtureDensity object is not copied, which could lead to issues
    // with shared ownership of components and weights.
    // Move semantics are allowed for efficiency
    // This is to ensure that the MixtureDensity object can be moved, which is efficient and safe.
    MixtureDensity(const MixtureDensity&) = delete;
    MixtureDensity& operator=(const MixtureDensity&) = delete;
    MixtureDensity(MixtureDensity&&) = default;
    MixtureDensity& operator=(MixtureDensity&&) = default;


}; // End class MixtureDensity


} // End namespace stats

#endif // MIXTURE_DENSITY_HPP


./include/traits/OPOE_traits.hpp
/** \mainpage OPE Library Documentation
 * 
 * The OPE (Orthonormal Polynomial Expansion) library provides a comprehensive framework for option pricing and financial modeling using orthonormal polynomial expansions and stochastic differential equations (SDEs).
 * It includes various financial models, numerical integration techniques, and polynomial manipulation utilities.
 * 
 * It provides tools to price options using MonteCarlo simulations, closed formulae and Fourier-based methods.
 * 
 */


/*!
 * @file OPOE_traits.hpp
 * @brief Defines core type traits, enumerations, and data structures for the OPOE library.
 *
 * This header provides essential type definitions and enumerations used throughout the OPOE library,
 * including matrix and vector types based on Eigen, polynomial field types, and various enums for
 * evaluation, integration, and quantization methods.
 * 
 * Dependencies:
 * - Eigen library for matrix and vector operations.
 * - Standard library features (e.g., std::complex, std::vector, std::array).
 * - C++20 concepts for type constraints.
 */

#ifndef OPOE_TRAITS_HPP
#define OPOE_TRAITS_HPP

#include <Eigen/Dense>
#include <Eigen/Sparse>
#include <tuple>
#include <vector>
#include <array>
#include <variant>
#include <type_traits>
#include <cmath>
#include <string>
#include <complex>

namespace traits
/*!
 * @namespace traits
 * @brief Contains all type traits, type aliases, and enumerations used across the OPOE library.
 */
{

// Forward Declaration of Polynomial
class Polynomial;

/*!
 * @struct DataType
 * @brief Central container of type aliases for commonly used matrix/vector structures in OPOE.
 *
 * These types are based on Eigen and are designed for dynamic sizing and numerical efficiency,
 * targeting polynomial manipulation and high-dimensional vector/matrix operations.
 */
struct DataType
{
public:
    using PolynomialField = double;  ///< Scalar field used for all polynomial operations (default: double).

    using StoringMatrix = Eigen::Matrix<PolynomialField, Eigen::Dynamic, Eigen::Dynamic, Eigen::RowMajor>; ///< Dynamic-size matrix type.
    
    using StoringVector = Eigen::Matrix<PolynomialField, Eigen::Dynamic, 1>; ///< Dynamic-size column vector type.

    using ComplexStoringVector = Eigen::Matrix<std::complex<PolynomialField>, Eigen::Dynamic, 1>; ///< Dynamic-size complex column vector type.
    
    using StoringArray  = Eigen::Array<PolynomialField, Eigen::Dynamic, 1>; ///< Dynamic-size array for element-wise operations.
    
    using ComplexArray  = Eigen::Array<std::complex<PolynomialField>, Eigen::Dynamic, 1>; ///< Array of complex numbers for advanced operations.

    using SparseStoringMatrix = Eigen::SparseMatrix<PolynomialField>; ///< Sparse matrix type for memory-efficient storage of large, sparse data.
    
    using Triplet = Eigen::Triplet<PolynomialField>; ///< Triplet structure for building sparse matrices.
    
    using Triplets = std::vector<Triplet>; ///< Collection of triplets used for sparse matrix assembly.
};

/*!
 * @brief Converts an integer to a type at compile time.
 * @tparam N The unsigned integer to wrap in a type.
 * 
 * This is a meta-programming utility useful for compile-time dispatch based on integer constants.
 */
template <unsigned int N> 
using IntToType = std::integral_constant<unsigned int, N>;

/*!
 * @enum EvalMethod
 * @brief Enumeration of available methods for evaluating polynomials.
 */
enum class EvalMethod
{
    Horner, ///< Use Horner's method: efficient nested multiplication.
    Direct  ///< Use direct evaluation (less efficient, straightforward).
};

/*!
 * @enum PochammerType
 * @brief Types of Pochhammer symbol (factorial-like product).
 */
enum class PochammerType
{
    Rising,  
    Falling  
};

/*!
 * @enum QuadratureMethod
 * @brief Advanced numerical integration techniques.
 */
enum class QuadratureMethod
{
    TanhSinh, ///< Tanh-Sinh quadrature for handling endpoint singularities.
    QAGI      ///< Infinite interval integration using QAGI (from QUADPACK).
};

/*!
 * @enum OptionType
 * @brief Financial option types.
 */
enum class OptionType
{
    Call, ///< Call option: right to buy.
    Put   ///< Put option: right to sell.
};

/*!
 * @enum QuantizationProcedure
 * @brief Enumerates different quantization strategies.
 */
enum class QuantizationProcedure
{
    Newton, ///< Quantization using Newton-based optimization.
    CLVQ    ///< Competitive Learning Vector Quantization.
};

/**
 * @enum
 * @brief Enumerates the different solvers. 
 */
 
enum class SolverType {
    EulerMaruyama,
    Milstein,
    IJK
};



} // namespace traits

#endif // OPOE_TRAITS_HPP
./include/polynomials/Polynomials.hpp
/*!
 * @file Polynomials.hpp
 * @brief Defines the polynomials::Polynomial template class and related polynomial operations.
 *
 * This header provides a generic, fixed-degree polynomial class template with support for
 * various arithmetic operations, evaluation methods, and utilities. The implementation
 * leverages Eigen/Armadillo for efficient array operations and supports both Horner's
 * and direct evaluation methods. Additional features include conversion to std::function,
 * pretty-printing, and compile-time degree information.
 *
 * 
 * Dependencies:
 * - Armadillo/Eigen for array operations.
 * - C++17 or later (C++20 for comparison operators).
 * - Custom traits and utility headers.
 * 
 * @details
 * Main features:
 * - Template class `Polynomial<N, R>` for polynomials of degree N over field R.
 * - Supports construction from coefficient arrays, copy/move semantics, and assignment from
 *   polynomials of lower degree.
 * - Evaluation via operator() with selectable method (Horner/direct).
 * - Conversion to std::function for functional programming use cases.
 * - Arithmetic operations: addition, subtraction, multiplication (including FFT-based),
 *   and scalar operations.
 * - Derivative computation via the `der<M>(p)` template function.
 * - Pretty-printing via operator<<.
 * - C++20 three-way comparison operator (if available).
 *
 *
 * Usage example:
 * @code
 * using Poly = polynomials::Polynomial<3, double>;
 * Poly p({1.0, 2.0, 3.0, 4.0});
 * double val = p(2.0); // Evaluate at x=2
 * auto dp = polynomials::der<1>(p); // First derivative
 * std::cout << p << std::endl;
 * @endcode
 */
#ifndef HH_POLYNOMIALS_HH
#define HH_POLYNOMIALS_HH

#include <algorithm>
#include <array>
#include <exception>
#include <iostream>
#include <type_traits>
#include <utility>
#include <ranges>
#include <cmath>
#include <armadillo>
#include <functional>
#include "../traits/OPOE_traits.hpp"
#include "../utils/Utils.hpp"
#include "../utils/FFTW.hpp"

#if __cplusplus >= 202002L
#include <compare> // for c++20 style comparison operators
#endif

namespace polynomials {
/*!
* @class Polynomial
* @brief Template class for polynomials
* @tparam N Polynomial degree
* @tparam R Polynomial field
*/

template <unsigned int N, class R = traits::DataType::PolynomialField>
class Polynomial
{
public:
   
    Polynomial() { M_coeff.setZero(); }

    //! Constructor taking coefficients
    Polynomial(const traits::DataType::StoringArray &c) : M_coeff{c} {}

    //! Constructor with evaluation method
    Polynomial(const traits::DataType::StoringArray &c, traits::EvalMethod method) : M_coeff{c}, eval_method{method} {}

    //! I can initialize with another polynomial, but only if Degree<=
    template <unsigned int M>
    Polynomial(Polynomial<M, R> const &right) noexcept
    {
        static_assert(M <= N, "Cannot assign a polynomial of higher degree");
        M_coeff.setZero();
        M_coeff.head(M + 1) = right.get_coeff().head(M + 1);      
    }

    //! For polynomial of the same type I use the implicit copy-constructor
    Polynomial(Polynomial<N, R> const &) = default;

    //! Move constructor is the implicit one
    Polynomial(Polynomial<N, R> &&) = default;

    //! I can also assign a polynomial of smaller degree
    template <unsigned int M>
    Polynomial &operator=(Polynomial<M, R> const &right) noexcept
    {
        static_assert(M <= N, "Cannot assign a polynomial of higher degree");
        M_coeff.setZero();
        M_coeff.head(M + 1) = right.get_coeff().head(M + 1);
        return *this;
    }

    //! Copy assignment is the synthesized one
    Polynomial &operator=(Polynomial<N, R> const &) = default;

    //! Move assignment is the synthesized one
    Polynomial &operator=(Polynomial<N, R> &&) = default;

    /*!
     * Relational operators among polynomials of same type and order (C++20)
     *
     * It relies on the fact that <=> operator is defined for std::array<R,M>
     */
#if __cplusplus >= 202002L
    friend auto operator<=>(Polynomial<N, R> const &, Polynomial<N, R> const &) = default;
#endif

    //! Set coefficients
    void set_coeff(const traits::DataType::StoringArray &c)
    {
        M_coeff = c;
    }

    //! Get coefficients
    auto get_coeff() const noexcept
    {
        return M_coeff;
    }

    //! Get coefficient as reference (a nicer alternative to setter).
    auto &get_coeff() noexcept
    {
        return M_coeff;
    }

    //! Evaluate polynomial with selected method
    //! @param x The evaluation point
    auto constexpr operator()(R const &x) const noexcept
    {
        return std::visit([this, &x](auto &&method) { return evaluate(x, method); }, eval_method);
    }

    /*!
     * @brief Returns a std::function representing the polynomial evaluation.
     *
     * The returned function captures a *copy* of the polynomial's state
     * (coefficients and evaluation method) at the time this method is called.
     * It remains valid even if the original Polynomial object is modified or destroyed.
     *
     * @return std::function<R(R)> A function object that takes an argument of type R
     *         and returns the polynomial evaluated at that argument.
     */
    std::function<R(R)> as_function() const {
        // Capture a copy of the current polynomial object state by value.
        // This ensures the lambda is self-contained.
        auto captured_poly_copy = *this;

        auto evaluator_lambda =
            // Move the captured copy into the lambda's state
            [poly_copy = std::move(captured_poly_copy)](R x) -> R {
            // Call the operator() of the captured copy.
            // This automatically uses the evaluation method stored in the copy.
            return poly_copy(x);
        };
        // The lambda is implicitly converted to std::function
        return evaluator_lambda;
    }
    // --- END NEW METHOD ---

    //! Unary minus
    auto operator-() noexcept
    {
        M_coeff = -M_coeff;
        return *this;
    }
    
    //! Unary minus (returns a new polynomial with inverted sign)
    auto operator-() const noexcept
    {
        Polynomial<N, R> result = *this;
        result.get_coeff() = -result.get_coeff();
        return result;
    }
    

    //! Unary plus
    auto operator+() noexcept
    {
        return *this;
    }

    //! The polynomial degree
    /*!
     *  implemented as a constexpr function since the degree is
     *  here a constant expression. It must be static since
     *  constexpr methods should be static methods.
     */
    static constexpr unsigned int degree()
    {
        return N;
    }

private:
    //! Coefficients a_0---a_n
    traits::DataType::StoringArray M_coeff;

    //! Evaluation method
    std::variant<traits::EvalMethod> eval_method = traits::EvalMethod::Horner;

    /*!
    * @brief Evaluates the polynomial at a given point x using the specified method.
    * @param x The point at which to evaluate the polynomial.
    * @param method The evaluation method to use (Horner or Direct).
    * @return The evaluated polynomial value at x.
    * @note This method uses Horner's method for efficient evaluation if the method is set to Horner.
    *       If the method is set to Direct, it computes powers of x and sums the products with coefficients.
    */
    auto constexpr evaluate(R const &x, traits::EvalMethod method) const noexcept
    {
        if (method == traits::EvalMethod::Horner){

        return M_coeff.reverse().redux([&](R a, R b) { return a * x + b; });

        }
        else // Direct evaluation
        {
            traits::DataType::StoringArray x_powers(N + 1);
            x_powers.setOnes();  // Set all elements to 1


            for (unsigned int i = 1; i <= N; ++i) {
                x_powers[i] = x_powers[i - 1] * x; 
            }
            
        return (M_coeff*x_powers).sum();
        }
    };
    
  

};

/*!
 * Outputs the polynomial in a pretty-print way
 * @tparam N The degree
 * @tparam R The field
 * @param out The output stream
 * @param p The polynomial
 * @return The stream
 */
template <unsigned int N, typename R>
std::ostream &operator<<(std::ostream &out, Polynomial<N, R> const &p)
{
    const auto &coeffs = p.get_coeff();  // Avoid multiple function calls
    out << coeffs[0];  // Print the constant term

    for (unsigned int i = 1; i <= N; ++i)
    {
        if (coeffs[i] != 0)  // Avoid printing zero terms
        {
            out << (coeffs[i] > 0 ? " + " : " - ") << std::abs(coeffs[i]) << "x^" << i;
        }
    }

    return out;
}



/*!
* Polynomial subtraction
 * @tparam LDegree The degree of the left polynomial
 * @tparam RDegree The degree of the right polynomial
 * @tparam R The scalar field
 * @param left The left polynomial
 * @param right The right polynomial
 * @return The subtraction of the two polynomials
*/
template <unsigned int LDegree, unsigned int RDegree, typename R>
auto
operator-(Polynomial<LDegree, R> const &left,
          Polynomial<RDegree, R> const &right) noexcept
{
  constexpr unsigned int NMAX = (LDegree > RDegree) ? LDegree : RDegree;
  Polynomial<NMAX, R> res;
  
  if constexpr (LDegree > RDegree) {
    res.get_coeff() = left.get_coeff();
    res.get_coeff() -= right.get_coeff();
  } else {
    res.get_coeff() = -right.get_coeff();
    res.get_coeff() += left.get_coeff();
  }
  
  return res;
}

/*!
* Polynomial subtraction with scalar (polynomial - scalar)
 * @tparam N The degree of the polynomial
 * @tparam R The scalar field
 * @param left The polynomial
 * @param right The scalar
 * @return The result of subtracting the scalar from the polynomial
*/
template <unsigned int N, typename R>
auto operator-(const Polynomial<N, R>& left, const R& right) noexcept
{
    Polynomial<N, R> res(left);  // Create copy of left polynomial
    res.get_coeff()[0] -= right; // Subtract scalar from constant term
    return res;
}

/*!
* Polynomial subtraction with scalar (scalar - polynomial)
 * @tparam N The degree of the polynomial
 * @tparam R The scalar field
 * @param left The scalar
 * @param right The polynomial
 * @return The result of subtracting the polynomial from the scalar
*/
template <unsigned int N, typename R>
auto operator-(const R& left, const Polynomial<N, R>& right) noexcept
{
    Polynomial<N, R> res(-right);  // Create negated copy of right polynomial
    res.get_coeff()[0] += left;    // Add scalar to constant term
    return res;
}

/*!
*Polynomial multiplication
 * @tparam LDegree The degree of the left polynomial
 * @tparam RDegree The degree of the right polynomial
 * @tparam R The scalar field
 * @param left The left polynomial
 * @param right The right polynomial
 * @return The product of the two polynomials
*/
template <unsigned int LDegree, unsigned int RDegree, typename R>
auto operator*(Polynomial<LDegree, R> const &left, Polynomial<RDegree, R> const &right) noexcept
{
    constexpr unsigned int NRES = LDegree + RDegree;
    Polynomial<NRES, R> res;

    // Perform FFT-based multiplication
    res.get_coeff() = Utils::fftMultiply(left.get_coeff(), right.get_coeff());

    // Logging or debugging mechanism can be added here if needed
    // std::cout << "Multiplication result: " << res << std::endl;

    return res;
}


/*!
* Multiplication of a polynomial with a scalar
 * @tparam RDegree The degree of the polynomial
 * @tparam R The scalar field
 * @param scalar The scalar
 * @param right The polynomial
 * @return The polynomial multiplied by the scalar
*/
template <unsigned int RDegree, typename R>
auto operator*(R const &scalar, Polynomial<RDegree, R> const &right) noexcept
{
    Polynomial<RDegree, R> res;
    res.get_coeff() = scalar * right.get_coeff();
    return res;
}

/*!
* Multiplication of a polynomial with a scalar
 * This is the same as the previous one, but with the arguments swapped.
 * It is here to allow for a more natural syntax.
 * @tparam RDegree The degree of the polynomial
 * @tparam R The scalar field
 * @param left The polynomial
 * @param scalar The scalar
 * @return The polynomial multiplied by the scalar
*/
template <unsigned int RDegree, typename R>
auto operator*( Polynomial<RDegree, R> const &left, R const &scalar) noexcept
{
    Polynomial<RDegree, R> res;
    res.get_coeff() = scalar * left.get_coeff();
    return res;
}





/*!
 * Derivative of a Polynomial
 * Usage: der<M>(p) (M>=0)
 *
 * @tparam M The derivative order
 * @tparam RDegree The degree of the polynomial
 * @tparam R The scalar field
 * @param p The polynomial
 * @return \f$\frac{d^{M}(p)}{dx^{M}}\f$
 */
template <unsigned M, unsigned RDegree, typename R>
auto
der(Polynomial<RDegree, R> const &p)
{
  if constexpr(M == 0u)
    return p;
  else if constexpr(RDegree < M)
    return Polynomial<0u, R>{{R(0)}};
  else
{
    // Create a vector containing [1, 2, 3, ..., RDegree]
    traits::DataType::StoringArray multipliers = traits::DataType::StoringArray::LinSpaced(RDegree, 1, RDegree);

    // Perform element-wise multiplication with the polynomial coefficients (ignoring the constant term)
    traits::DataType::StoringArray C = multipliers * p.get_coeff().segment(1, RDegree);

      return der<M - 1>(Polynomial<RDegree - 1, R>{C});
    }
};

}; // namespace polynomials


#endif // HH_POLYNOMIALS_HH./include/polynomials/OrthogonalValidator.cpp
/**
 * @brief Validates and debugs polynomial domain parameters.
 *
 * This file contains the implementation of member functions for the
 * PolynomialDomainValidator class template, which is responsible for
 * validating the parameters of a polynomial domain and providing
 * debugging information.
 * 
 * Dependencies:
 * - OrthogonalValidator.hpp: Header file for the PolynomialDomainValidator class.
 *
 * @tparam R The return type or result type associated with the validator.
 * @tparam Params Variadic template parameters representing the types of the parameters to validate.
 *
 * Member Functions:
 * - validateParameters(): Checks if all parameters are valid according to their domain.
 *   Throws a std::runtime_error with a detailed error message if any parameter is invalid.
 * - debugParameters(): Outputs the name and value of each parameter to std::cout for debugging purposes.
 * - buildErrorMessage(): Constructs a detailed error message listing all invalid parameters,
 *   their values, and the expected domain.
 *
 * Usage:
 *   Instantiate PolynomialDomainValidator with the appropriate parameter types,
 *   then call validateParameters() to ensure all parameters are valid before proceeding.
 */
#include <iostream>
#include <sstream>
#include "OrthogonalValidator.hpp"

namespace polynomials {

// PolynomialDomainValidator member functions
template<typename R, typename... Params>
void PolynomialDomainValidator<R, Params...>::validateParameters() const {
    // Check if all parameters are valid using fold expression
    // This checks if each parameter's isValid() method returns true
    // If any parameter is invalid, it throws an exception with a detailed message
    // Using std::apply to unpack the tuple and check each parameter
    bool allValid = std::apply([](const auto&... params) {
        return (params.isValid() && ...);
    }, parameters_);

    if (!allValid) {
        std::string errorMessage = buildErrorMessage();
        throw std::runtime_error(errorMessage);
    }
}

template<typename R, typename... Params>
void PolynomialDomainValidator<R, Params...>::debugParameters() const {
    // Print each parameter's name and value to standard output
    // Using std::apply to unpack the tuple and print each parameter
    // This uses a fold expression to iterate over each parameter in the tuple
    std::apply([](const auto&... params) {
        ((std::cout << "Parameter " << params.name << ": " << params.value << "\n"), ...);
    }, parameters_);
}

template<typename R, typename... Params>
std::string PolynomialDomainValidator<R, Params...>::buildErrorMessage() const {
    // Build a detailed error message listing all invalid parameters
    // Using std::apply to unpack the tuple and check each parameter
    // This constructs a string that includes the name, value, and expected domain for each invalid parameter
    std::string errorDetail = "Parameter validation failed:\n";

    std::apply([&errorDetail](const auto&... params) {
        (
            [&]() {
                if (!params.isValid()) {
                    errorDetail += " - Parameter \"" + std::string(params.name) + "\" is invalid (value: " 
                                   + std::to_string(params.value) + "). Expected: " + std::string(params.getDomain()) + ".\n";
                }
            }(),
            ...
        );
    }, parameters_);

    return errorDetail;
} }./include/polynomials/OrthogonalValidator.hpp
/**
 * @file OrthogonalValidator.hpp
 * @brief Provides utilities for validating domains and parameters of orthogonal polynomials.
 *
 * This header defines concepts, structures, and classes to facilitate the validation of
 * parameters and domains for various families of orthogonal polynomials (e.g., Jacobi, Laguerre, Hermite, Gegenbauer).
 * 
 * 
 * It includes:
 *   - Function type alias for recurrence coefficients.
 *   - DomainInterval for interval validation (with floating-point support).
 *   - Exception types for domain violations.
 *   - Parameter base structure and specific parameter types for common polynomial families.
 *   - PolynomialDomainValidator class template for parameter validation and access.
 *
 */
#ifndef ORTHOGONAL_VALIDATOR_HPP
#define ORTHOGONAL_VALIDATOR_HPP
#include <stdexcept>
#include <limits>
#include <type_traits>
#include <cmath>
#include <concepts>

namespace polynomials{

/**
 * @brief A callable function taking and returning a scalar value.
 * 
 * @tparam R Scalar type.
 */
template <typename R>
using Function = std::function<R(R)>;

/**
 * @brief Structure for defining recurrence coefficients of orthogonal polynomials.
 * 
 * The recurrence takes the form:
 *     P_{k+1}(x) = (x - alpha_k(x)) * P_k(x) - beta_k(x) * P_{k-1}(x)
 * 
 * @tparam R Scalar type.
 */
template <typename R>
struct RecurrenceCoefficients {
    Function<R> alpha_k;
    Function<R> beta_k;
    Function<R> beta_0;
};

/**
 * @brief Concept restricting T to arithmetic types.
 */
template<typename T>
concept Numeric = std::is_arithmetic_v<T>;

/**
 * @brief Represents a closed numeric interval [lower, upper].
 * 
 * @tparam T Type of the interval endpoints.
 */
template<typename T>
struct DomainInterval {
    T lower; ///< Lower bound of the interval
    T upper; ///< Upper bound of the interval

    /**
     * @brief Checks if a value lies within the interval.
     * 
     * @param x The value to check.
     * @return true if x is in [lower, upper], false otherwise.
     */
    constexpr bool contains(T x) const noexcept {
        return x >= lower && x <= upper;
    }
    
    /**
     * @brief Approximate check for floating-point values using epsilon.
     * 
     * @tparam U Type, must be floating-point.
     * @param x Value to test.
     * @param epsilon Tolerance (default: machine epsilon).
     * @return true if x lies approximately within [lower, upper].
     */    template<typename U = T>
    requires std::is_floating_point_v<U>
    bool contains_approx(U x, U epsilon = std::numeric_limits<U>::epsilon()) const noexcept {
        return x >= (lower - epsilon) && x <= (upper + epsilon);
    }
};

/**
 * @brief Base class for all domain-related exceptions.
 */
class DomainError : public std::runtime_error {
    using std::runtime_error::runtime_error;
};

/**
 * @brief Exception for parameter validation errors.
 */
class ParameterDomainError : public DomainError {
    using DomainError::DomainError;
};

/**
 * @brief Exception for evaluation input errors.
 */
class EvaluationDomainError : public DomainError {
    using DomainError::DomainError;
};

/**
 * @brief A generic parameter with value range validation.
 * 
 * @tparam R Scalar type.
 */
template<typename R>
struct Parameter {
    R value;                ///< The parameter's current value.
    std::pair<R, R> range;  ///< The valid domain for the parameter.
    const char* name;       ///< Human-readable name for error messages.

    /**
     * @brief Constructs a named parameter with range.
     * 
     * @param val Initial value.
     * @param range Valid (exclusive-inclusive) interval.
     * @param name Name for display/debugging.
     */
    Parameter(R val, std::pair<R, R> range, const char* name)
        : value(val), range(range), name(name) {}

    /**
     * @brief Validates if the value lies in (range.first, range.second].
     * 
     * @return true if valid, false otherwise.
     */
    bool isValid() const {
        return value > range.first && value <= range.second;
    }

    /**
     * @brief Returns the domain constraint as a human-readable string.
     */
    std::string getDomain() const {
        return std::to_string(range.first) + " < " + name + " <= " + std::to_string(range.second);
    }
};

// -----------------------------------------------------------------------------
// Specific parameter type definitions for common orthogonal polynomials
// -----------------------------------------------------------------------------

/// @brief α parameter for Jacobi polynomials: α > -1
template<typename R>
struct JacobiAlpha : Parameter<R> {
    JacobiAlpha(R val) : Parameter<R>{val, {-1, std::numeric_limits<R>::infinity()}, "alpha"} {}
};

/// @brief β parameter for Jacobi polynomials: β > -1
template<typename R>
struct JacobiBeta : Parameter<R> {
    JacobiBeta(R val) : Parameter<R>{val, {-1, std::numeric_limits<R>::infinity()}, "beta"} {}
};

/// @brief α parameter for Laguerre polynomials: α > -1
template<typename R>
struct LaguerreAlpha : Parameter<R> {
    LaguerreAlpha(R val) : Parameter<R>{val, {-1, std::numeric_limits<R>::infinity()}, "alpha"} {}
};

/// @brief θ (scale) parameter for Generalized Laguerre: θ ≥ 0
template<typename R>
struct LaguerreTheta : Parameter<R> {
    LaguerreTheta(R val) : Parameter<R>{val, {0, std::numeric_limits<R>::infinity()}, "theta"} {}
};

/// @brief μ parameter for Hermite polynomials: unbounded
template<typename R>
struct HermiteMu : Parameter<R> {
    HermiteMu(R val) : Parameter<R>{val, {-std::numeric_limits<R>::infinity(), std::numeric_limits<R>::infinity()}, "mu"} {}
};

/// @brief σ (scale) parameter for Hermite: σ > 0
template<typename R>
struct HermiteSigma : Parameter<R> {
    HermiteSigma(R val) : Parameter<R>{val, {0.0, std::numeric_limits<R>::infinity()}, "sigma"} {}
};

/// @brief μ parameter for Gegenbauer polynomials: μ > -0.5
template<typename R>
struct GegenbauerLambda : Parameter<R> {
    GegenbauerLambda(R val) : Parameter<R>{val, {-0.5, std::numeric_limits<R>::infinity()}, "mu"} {}
};


// -----------------------------------------------------------------------------
// Validator for parameter tuples
// -----------------------------------------------------------------------------

/**
 * @brief Utility to validate multiple parameters for a polynomial family.
 * 
 * @tparam R Scalar type
 * @tparam Params List of parameter types (must be derived from Parameter<R>)
 */
template<typename R, typename... Params>
class PolynomialDomainValidator {
private:
    std::tuple<Params...> parameters_;

public:
    /**
     * @brief Constructs the validator and performs initial validation.
     * 
     * @param params Variadic list of parameter values.
     */
    explicit PolynomialDomainValidator(Params... params)
        : parameters_(std::make_tuple(params...)) {
        validateParameters();
    }

    /**
     * @brief Throws if any parameter is out of domain.
     */
    void validateParameters() const;

    /**
     * @brief Gets a reference to a specific parameter by type.
     * 
     * @tparam P Parameter type to extract.
     * @return const P& Reference to the parameter.
     */    template<typename P>
    const P& getParameter() const {
        return std::get<P>(parameters_);
    }

    /**
     * @brief Gets the scalar value of a parameter.
     * 
     * @tparam P Parameter type to extract.
     * @return Value of the parameter.
     */
    template<typename P>
    auto getValue() const {
        return std::get<P>(parameters_).value;
    }

    /**
     * @brief Prints parameters to standard output (for debugging).
     */
    void debugParameters() const;

private:
    /**
     * @brief Builds a string message listing invalid parameters.
     * 
     * @return std::string Message for exception.
     */
    std::string buildErrorMessage() const;
};



}

#endif // ORTHOGONAL_VALIDATOR_HPP./include/polynomials/OrthogonalPolynomials.hpp
/**
 * @file OrthogonalPolynomials.hpp
 * @brief Defines a generic CRTP-based framework for orthogonal polynomials and their specializations.
 *
 * This header provides a base class template, `OrthogonalPolynomialBase`, for constructing and working with
 * families of orthogonal polynomials using recurrence relations, weight functions, and domain validation.
 * It also provides concrete implementations for several classical orthogonal polynomial families:
 * Legendre, Hermite, Chebyshev, Laguerre, Jacobi, and Gegenbauer polynomials.
 *
 * Dependencies:
 * - Polynomials.hpp: For the base polynomial class.
 * - OrthogonalValidator.cpp: For parameter validation of orthogonal polynomials.
 * - Eigen library: For matrix and vector operations.
 * - OpenMP: For parallelization of polynomial generation and evaluation.
 * ## Main Components
 *
 * - **OrthogonalPolynomialBase**: 
 *   - CRTP base class for orthogonal polynomials of degree N, with support for custom weight functions,
 *     recurrence coefficients, domain intervals, and parameter validation.
 *   - Handles polynomial generation, evaluation, and construction of the Jacobi matrix.
 *   - Provides access to recurrence coefficients, weight function, and precomputed polynomials.
 *
 * - **Specializations**:
 *   - `LegendrePolynomial`: Legendre polynomials on [-1, 1] with weight 1.
 *   - `HermitePolynomial`: Hermite polynomials with configurable mean and variance.
 *   - `ChebychevPolynomial`: Chebyshev polynomials of the first kind on [-1, 1].
 *   - `LaguerrePolynomial`: Generalized Laguerre polynomials with parameters alpha and theta.
 *   - `JacobiPolynomial`: Jacobi polynomials with parameters alpha and beta.
 *   - `GegenbauerPolynomial`: Gegenbauer polynomials with parameter mu.
 *
 *
 *
 * ## Usage Example
 * @code
 * polynomials::LegendrePolynomial<5> legendre;
 * double value = legendre.evaluate(0.5, 3); // Evaluate P_3(0.5)
 * auto J = legendre.getJacobiMatrix();      // Get Jacobi matrix
 * @endcode
 *
 * @note Requires Eigen for matrix/vector types and OpenMP for parallelization.
 * @note All polynomials are normalized according to their respective weight functions.
 *
 */
#ifndef HH_ORTHOGONAL_POLYNOMIALS_HH
#define HH_ORTHOGONAL_POLYNOMIALS_HH

#include "Polynomials.hpp"
#include "OrthogonalValidator.cpp"
#include <functional>
#include <memory>


namespace polynomials {

/**
 * @brief Base class for orthogonal polynomials using CRTP.
 * 
 * @tparam Derived Derived class (e.g., LegendrePolynomial)
 * @tparam N Degree of polynomial
 * @tparam R Floating point type (e.g., float, double)
 * @tparam Params Variadic template for parameter validation (e.g., α, β)
 */
template<typename Derived, unsigned int N, typename R, typename... Params>
requires std::floating_point<R> 
class OrthogonalPolynomialBase {
public:
    using PolyType = Polynomial<N, R>;  // Polynomial class/type
    using ValidatorType = PolynomialDomainValidator<R, Params...>; // Variadic validator type
    using StoringArray = traits::DataType::StoringArray;  // Storage for polynomials
    using JacobiMatrixType = traits::DataType::SparseStoringMatrix;  // Storage for matrix J
    using HMatrixType = traits::DataType::StoringMatrix;  // Storage for matrix J
    using Triplets = traits::DataType::Triplets;  // Triplet type for sparse matrix construction
    using Triplet = traits::DataType::Triplet;  // Triplet type for sparse matrix construction


protected:
    Function<R> weight_function;                          // Weight function for the polynomial
    RecurrenceCoefficients<R> recurrence_coeffs;          // Recurrence coefficient system
    DomainInterval<R> evaluation_domain;                  // Valid domain for evaluation
    std::unique_ptr<ValidatorType> domain_validator;      // Parameter domain validator
    std::vector<PolyType> polynomials;                    // Precomputed polynomial solutions
    StoringArray alphas;                                  // Coefficients for polynomial evaluation
    StoringArray betas;                                   // Coefficients for polynomial evaluation
    JacobiMatrixType J;                                   // Jacobi matrix for polynomial evaluation
    HMatrixType H;

    // Access the derived class
    Derived& derived() { return static_cast<Derived&>(*this); }
    const Derived& derived() const { return static_cast<const Derived&>(*this); }

public:
    /**
     * @brief Construct base class with weight function, recurrence coefficients, domain, and validator.
     * 
     * @param weight Weight function
     * @param coeffs Recurrence coefficients
     * @param domain Evaluation domain
     * @param validator Parameter validator
     */
    OrthogonalPolynomialBase(
        const Function<R>& weight,
        const RecurrenceCoefficients<R>& coeffs,
        const DomainInterval<R>& domain,
        ValidatorType&& validator // Forwarding the validator instance
    )
        : weight_function(weight)
        , recurrence_coeffs(coeffs)
        , evaluation_domain(domain)
        , domain_validator(std::make_unique<ValidatorType>(std::move(validator)))
        , polynomials(N + 2)
        , alphas(N + 1)
        , betas(N + 1)
        , J(N + 1, N + 1),
        H(N + 1, N + 1)	
    {
        // Validate parameters directly upon construction
        domain_validator->validateParameters();
        generatePolynomials();
        buildJacobiMatrix();
    }

     /**
     * @brief Validate polynomial domain parameters.
     * @throws ParameterDomainError if parameters are invalid.
     */    void validateDomains() const {
        if (!domain_validator->validateParameters()) {
            throw ParameterDomainError("Domain validation failed: Parameters are out of bounds.");
        }
    }

    /**
     * @brief Evaluate polynomial at given point x and degree.
     * 
     * @param x Input point
     * @param degree Degree of polynomial
     * @return Polynomial value at x
     * @throws EvaluationDomainError if x is outside domain.
     * @throws std::out_of_range if degree > N
     */
    constexpr R evaluate(R x, unsigned int degree) const {
        if (!evaluation_domain.contains(x)) {
            throw EvaluationDomainError("Evaluation point outside valid domain.");
        }
        if (degree > N) {
            throw std::out_of_range("Requested degree exceeds max polynomial degree.");
        }

        return derived().getPolynomial(degree).operator()(x); 
    }

    /**
     * @brief Generate orthogonal polynomials up to degree N+1 using recurrence relations.
     */
    void generatePolynomials() {
        #pragma omp parallel for simd
        for (unsigned int i = 0; i < N + 2; ++i) {
            polynomials[i] = PolyType(StoringArray::Zero(N + 1));
        }
    
        // P₀(x) is implicitly zero.
        // P₁(x) = 1 (coefficient of x⁰ is 1)
        if (N + 1 > 0) {
            polynomials[1].get_coeff()(0) = 1.0/std::sqrt(recurrence_coeffs.beta_0(0.0));
            //polynomials[1].get_coeff()(0) = 1.0;
        }
        H.col(0) = polynomials[1].get_coeff();

        if constexpr (N == 0) {
             // Pre-calculate and store alpha_0 and beta_0 if needed elsewhere
             if (N + 1 > 0) { // Need alpha_0 for J matrix
                alphas[0] = recurrence_coeffs.alpha_k(0);
                // beta_0 is often special or not used directly in J matrix
                // betas[0] = recurrence_coeffs.beta_0(0.0); // Store if needed
             }
             return;
        }
    
    
        // --- Sequential Recurrence Calculation ---
    
        // Temporary storage for the coefficients of P_{k+1}
        // Allocated once outside the loop to avoid repeated allocations.
        StoringArray P_kp1_coeffs(N + 1);
    
        // Calculate P₂, P₃, ..., P_{N+1} sequentially
        for (unsigned int k = 1; k <= N; ++k) {
            // Calculate recurrence coefficients for this step
            const R alpha_km1 = recurrence_coeffs.alpha_k(k - 1); // α_{k-1}
            const R beta_km1 = (k == 1) ? recurrence_coeffs.beta_0(0.0)  // β₀
                                       : recurrence_coeffs.beta_k(k - 1); // β_{k-1}
            const R beta_kp1 = recurrence_coeffs.beta_k(k); // β_{k}
    
            // Store coefficients for later use (e.g., Jacobi matrix, evaluation)
            alphas[k - 1] = alpha_km1;
            betas[k - 1] = beta_km1; // Store β₀, β₁, ..., β_{N-1}
    
            // Get references to coefficients of P_k and P_{k-1}
            const auto& P_k_coeffs = polynomials[k].get_coeff();
            const auto& P_km1_coeffs = polynomials[k - 1].get_coeff();
    
            // --- Calculation using Eigen's vectorized operations ---
            // P_kp1 = (x * P_k) - alpha_km1 * P_k - beta_km1 * P_km1
    
            // 1. Compute x * P_k (results in higher degree, store temporarily)
            P_kp1_coeffs.setZero(); // Clear previous iteration's result
            // Shift P_k's coefficients: P_k[i] -> (x*P_k)[i+1]
            // Copies P_k[0..N-1] to P_kp1_coeffs[1..N]
            P_kp1_coeffs.segment(1, N) = P_k_coeffs.head(N);
    
            // 2. Subtract alpha_km1 * P_k
            P_kp1_coeffs -= alpha_km1 * P_k_coeffs;
    
            // 3. Subtract beta_km1 * P_{k-1}
            // P_kp1_coeffs -= beta_km1 * P_km1_coeffs;

            P_kp1_coeffs -= std::sqrt(beta_km1) * P_km1_coeffs;
            P_kp1_coeffs /= std::sqrt(beta_kp1); // Normalize by sqrt(beta_k)
            // --- End of Eigen calculation ---
    
            // Store the final coefficients for P_{k+1}
            H.col(k) = P_kp1_coeffs;
            polynomials[k + 1].set_coeff(P_kp1_coeffs);
        }


        // Store coefficients for later use (e.g., Jacobi matrix, evaluation)
        alphas[N] = recurrence_coeffs.alpha_k(N);
        betas[N] = recurrence_coeffs.beta_k(N);
            }
        
    
    /// @name Accessors for α and β recurrence coefficients
    /// @{
    auto getAlpha(unsigned int k) const noexcept {
        return alphas[k];
    }

    auto getBeta(unsigned int k) const noexcept {
        return betas[k];
    }
    
    auto getAlphas() const noexcept {
        return alphas;
    }
    auto getBetas() const noexcept {
        return betas;
    }
    /// @}

    /**
     * @brief Retrieve the polynomial of given degree.
     * 
     * @param degree Degree of polynomial
     * @return Const reference to polynomial
     * @throws std::out_of_range if degree > N
     */
    const PolyType& getPolynomial(unsigned int degree) const {
        if (degree > N) {
            throw std::out_of_range("Requested degree exceeds max polynomial degree.");
        }
        return polynomials[degree + 1];
    }

    /**
     * @brief Evaluate the weight function at point x.
     * @param x Point at which to evaluate
     * @return Value of weight function
     * @throws EvaluationDomainError if x is outside valid domain
     */
    R getWeight(R x) const {

        if (!evaluation_domain.contains(x)) {

            throw EvaluationDomainError("Evaluation point outside valid domain");

        }

        return derived().weight_function(x);

    }

    /**
     * @brief Retrieve recurrence coefficients object.
     * @return RecurrenceCoefficients<R>
     */
    RecurrenceCoefficients<R> getRecurrenceCoefficients() const {

        return recurrence_coeffs;
    }

    /**
     * @brief Build Jacobi matrix used in spectral methods and eigenvalue problems.
     */
    void buildJacobiMatrix() {
        // Fill the Jacobi matrix with recurrence coefficients
        Triplets triplets(N + 1);        
        const int expectedNonZeros = 3 * N + 1;  // Main diagonal + upper + lower
        triplets.reserve(expectedNonZeros);
         

        #pragma omp parallel
        {
        // Each thread maintains its own local vector of triplets
        Triplets localTriplets;
        localTriplets.reserve(expectedNonZeros / omp_get_num_threads());

        #pragma omp for nowait
        for(unsigned int i = 0; i < N + 1; ++i) {
            // Main diagonal
            localTriplets.emplace_back(i, i, alphas[i]);
            
            // Lower and upper diagonals
            if(i > 0) {
                localTriplets.emplace_back(i, i-1, std::sqrt(betas[i]));    // Lower
                localTriplets.emplace_back(i-1, i, std::sqrt(betas[i]));    // Upper
            }
        }

        // Merge local triplets into global vector
        #pragma omp critical
        {
            triplets.insert(triplets.end(), 
                          localTriplets.begin(), 
                          localTriplets.end());
        }
    }

    // Set matrix from triplets
    J.resize(N + 1, N + 1);
    J.setFromTriplets(triplets.begin(), triplets.end());
    J.makeCompressed();
    };

    /**
     * @brief Get the constructed Jacobi matrix.
     * @return Sparse Jacobi matrix
     */
    JacobiMatrixType getJacobiMatrix() const noexcept {
        return J;
    }
    
    /**
     * @brief Get matrix of polynomial coefficients.
     * @return Dense matrix of polynomial coefficients
     */
    HMatrixType getHMatrix() const noexcept {
        return H;
    }
};

/**
 * @brief Legendre polynomials on [-1, 1] with uniform weight.
 */
template<unsigned int N, class R = traits::DataType::PolynomialField>
class LegendrePolynomial
    : public OrthogonalPolynomialBase<LegendrePolynomial<N, R>, N, R> {

public:
    using Base = OrthogonalPolynomialBase<LegendrePolynomial<N, R>, N, R>;

    LegendrePolynomial()
        : Base(
            [](R x) { return 1.0; }, // Weight function
            RecurrenceCoefficients<R>{
                [](R n) { return (void)n; 0.0; },                           // alpha_k
                [](R n) { return 1.0 / (4 - std::pow(n, -2)); },  // beta_k
                [](R n) { return (void)n; 2.0; }                           // beta_0
            },
            DomainInterval<R>{-1, 1}, // Valid domain for Legendre polynomials
            PolynomialDomainValidator<R>() // No additional parameter validation required
        ) {}
};

/**
 * @brief Hermite polynomials with parameters μ and σ.
 */
template<unsigned int N, class R = traits::DataType::PolynomialField>
class HermitePolynomial
    : public OrthogonalPolynomialBase<HermitePolynomial<N, R>, N, R, HermiteMu<R>, HermiteSigma<R>> {

private:
    R mu_; // Parameter specific to Hermite polynomials
    R sigma_; // Parameter specific to Hermite polynomials

public:
    using Base = OrthogonalPolynomialBase<HermitePolynomial<N, R>, N, R, HermiteMu<R>, HermiteSigma<R>>;

    HermitePolynomial(R mu = 0, R sigma = M_SQRT2)
        : Base(
            [mu, sigma](R x) { return 1/(sigma*std::sqrt(M_PI*2)) * std::exp(-std::pow(x-mu, 2)/(2*sigma*sigma)); }, // Weight function
            RecurrenceCoefficients<R>{
                [mu](R n) { (void)n; return mu; },                  // alpha_k
                [sigma](R n) { return n*sigma*sigma; },             // beta_k
                [sigma](R n) { (void)n; return sigma; }             // beta_0
            },
            DomainInterval<R>{std::numeric_limits<R>::lowest(), 
                              std::numeric_limits<R>::max()}, // Valid domain for Hermite
            PolynomialDomainValidator<R, HermiteMu<R>, HermiteSigma<R>>(HermiteMu<R>(mu), HermiteSigma<R>(sigma)) // Parameter validator
        ),
        mu_(mu),
        sigma_(sigma) 
    {
        // Core parameter validation happens automatically in Base class validator
    }
};

/**
 * @brief Chebyshev polynomials of the first kind.
 */
template<unsigned int N, class R = traits::DataType::PolynomialField>
class ChebychevPolynomial
    : public OrthogonalPolynomialBase<ChebychevPolynomial<N, R>, N, R> {

public:
    using Base = OrthogonalPolynomialBase<ChebychevPolynomial<N, R>, N, R>;

    ChebychevPolynomial()
        : Base(
            [](R x) { return std::pow(1 - x * x, -0.5); }, // Weight function
            RecurrenceCoefficients<R>{
                [](R n) { (void)n; return 0.0; },                  // alpha_k
                [](R n) { return n == 1 ? 0.5 : 0.25; },           // beta_k
                [](R n) { (void)n; return M_PI; }                  // beta_0
            },
            DomainInterval<R>{-1, 1}, // Valid domain for Chebyshev polynomials
            PolynomialDomainValidator<R>() // No additional parameter validation required
        ) {}
};

/**
 * @brief Generalized Laguerre polynomials with parameters α and θ.
 */
template<unsigned int N, class R = traits::DataType::PolynomialField>
class LaguerrePolynomial 
    : public OrthogonalPolynomialBase<LaguerrePolynomial<N, R>, N, R, LaguerreAlpha<R>, LaguerreTheta<R>> {
private:
    R alpha_;   // Parameter specific to Laguerre polynomials
    R theta_;   // Parameter specific to Laguerre polynomials

public:
    using Base = OrthogonalPolynomialBase<LaguerrePolynomial<N, R>, N, R, LaguerreAlpha<R>, LaguerreTheta<R>>;
    
    LaguerrePolynomial(R alpha, R theta = 1) 
        : Base(
            [alpha, theta](R x) { return std::exp(-x/theta)*std::pow(x, alpha)/(std::pow(theta, alpha + 1)*std::tgamma(1 + alpha)); },
            RecurrenceCoefficients<R>{
            [alpha, theta](R n){ return (2*n + alpha + 1)*theta;},              // alpha_k
            [alpha, theta](R n){ return n*(n + alpha)*theta*theta;},            // beta_k
            [alpha](R n){ (void)n;return 1;}},                                  // beta_0
            DomainInterval<R>{0.0, std::numeric_limits<R>::max()},
            PolynomialDomainValidator<R, LaguerreAlpha<R>, LaguerreTheta<R>>(LaguerreAlpha<R>(alpha), LaguerreTheta<R>(theta))
            ), alpha_(alpha), theta_(theta)
            {    }



};

/**
 * @brief Jacobi polynomials with parameters α and β.
 * 
 */
template<unsigned int N, class R = traits::DataType::PolynomialField>
class JacobiPolynomial
    : public OrthogonalPolynomialBase<JacobiPolynomial<N, R>, N, R, JacobiAlpha<R>, JacobiBeta<R>> {

private:
    R alpha_; // Alpha parameter specific to Jacobi polynomials
    R beta_;  // Beta parameter specific to Jacobi polynomials

public:
    using Base = OrthogonalPolynomialBase<JacobiPolynomial<N, R>, N, R, JacobiAlpha<R>, JacobiBeta<R>>;

    JacobiPolynomial(R alpha, R beta)
        : Base(
            [alpha, beta](R x) { 
                return std::pow(1 - x, alpha) * std::pow(1 + x, beta); 
            }, // Weight function
            RecurrenceCoefficients<R>{
                [alpha, beta](R n) { 
                    return (beta * beta - alpha * alpha) / 
                           ((2 * n + alpha + beta) * (2 * n + alpha + beta + 2)); 
                }, // alpha_k
                [alpha, beta](R n) { 
                    return 4 * n * (n + beta) * (n + alpha) * (n + alpha + beta) /
                           ((2 * n + alpha + beta) * (2 * n + alpha + beta) * 
                            (2 * n + alpha + beta - 1) * (2 * n + alpha + beta + 1)); 
                }, // beta_k
                [alpha, beta](R n) {
                    (void)n; 
                    return std::pow(2, alpha + beta + 1) * 
                           std::tgamma(alpha + 1) * std::tgamma(beta + 1) / 
                           std::tgamma(alpha + beta + 1); 
                } // beta_0
            },
            DomainInterval<R>{-1, 1}, // Valid domain
            PolynomialDomainValidator<R, JacobiAlpha<R>, JacobiBeta<R>>(
                JacobiAlpha<R>(alpha),
                JacobiBeta<R>(beta)
            ) // Parameter validator
        ),
        alpha_(alpha), 
        beta_(beta) 
    {
        // Validation happens automatically in the base class
    }
};

/**
 * @brief Gegenbauer polynomials with parameter λ (lambda).
 * 
 * Gegenbauer polynomials are a generalization of Legendre polynomials and are orthogonal on the interval [-1, 1]
 * with respect to the weight function (1 - x^2)^(λ - 0.5).
 */
template<unsigned int N, class R = traits::DataType::PolynomialField>
class GegenbauerPolynomial
    : public OrthogonalPolynomialBase<GegenbauerPolynomial<N, R>, N, R, GegenbauerLambda<R>> {

private:
    R lambda_; // Lambda parameter specific to Gegenbauer polynomials

public:
    using Base = OrthogonalPolynomialBase<GegenbauerPolynomial<N, R>, N, R, GegenbauerLambda<R>>;

    GegenbauerPolynomial(R lambda)
        : Base(
            [lambda](R x) { 
                return std::pow(1 - x * x, lambda - 0.5); 
            }, // Weight function
            RecurrenceCoefficients<R>{
                [](R n) { 
                    (void)n;
                    return 0.0; 
                }, // alpha_k
                [lambda](R n) { 
                    return n * (n + 2 * lambda - 1) / 
                           (4 * (n + lambda) * (n + lambda - 1)); 
                }, // beta_k
                [lambda](R n) { 
                    (void)n;
                    return 2 / M_2_SQRTPI * std::tgamma(lambda + 0.5) / 
                           std::tgamma(lambda + 1.0); 
                } // beta_0
            },
            DomainInterval<R>{-1, 1}, // Valid domain
            PolynomialDomainValidator<R, GegenbauerLambda<R>>(GegenbauerLambda<R>(lambda)) // Validator
        ),
        lambda_(lambda)
    {
        // Validation happens automatically in the base class
    }
};



};// namespace OPOE

#endif // HH_ORTHOGONAL_POLYNOMIALS_HH

./include/polynomials/Monomials.hpp

/**
 * @file Monomials.hpp
 * @brief Provides constexpr functions to compute monomials of a given degree.
 *
 * This header defines a set of template functions in the `polynomials` namespace
 * for evaluating monomials (i.e., powers of a variable) at compile time.
 * The functions use template metaprogramming and type traits to recursively
 * compute x^N for a given value x and non-negative integer N. 
 * 
* Dependencies:
 * - traits/OPOE_traits.hpp: For the default type of R.
 * 
 * Templates:
 * - R: The type of the variable and result (defaults to traits::DataType::PolynomialField).
 * - N: The degree of the monomial (unsigned int).
 *
 * Functions:
 * - monomial(const R, traits::IntToType<0>): Base case, returns 1 for x^0.
 * - monomial(const R x, traits::IntToType<N>): Recursive case, computes x^N as x * x^(N-1).
 * - monomial(const R x): Convenience function to compute x^N using IntToType.
 *
 * Requirements:
 * - The type R must support multiplication and construction from integer 1.
 * 

 * *
 * Example usage:
 * @code
 * constexpr auto result = polynomials::monomial<3>(2); // Computes 2^3 = 8 at compile time
 * @endcode
 */
#ifndef HH_MONOMIALS_HPP
#define HH_MONOMIALS_HPP    
#include "../traits/OPOE_traits.hpp"

namespace polynomials {

template <class R=traits::DataType::PolynomialField>
constexpr R
monomial(const R, traits::IntToType<0>)
{
  return 1;
}

template <unsigned int N, class R=traits::DataType::PolynomialField>
constexpr R
monomial(const R x, traits::IntToType<N>)
{
  return monomial(x, traits::IntToType<N - 1>()) * x;
}

template <unsigned int N, class R=traits::DataType::PolynomialField>
constexpr R 
monomial(const R x)
{
  return monomial(x, traits::IntToType<N>());
}

}
#endif // HH_MONOMIALS_HPP./include/quadrature/QuadratureRuleAbstract.hpp
/**
 * @file QuadratureRuleAbstract.hpp
 * @brief Defines the abstract interface for numerical quadrature rules.
 *
 * This file declares the IQuadratureRule interface, which provides a common
 * abstraction for implementing numerical integration rules.
 * The interface supports integration of single-variable functions over a
 * specified interval and enables polymorphic copying of rule objects.
 * 
 *
 */
#ifndef I_QUADRATURE_RULE_HPP
#define I_QUADRATURE_RULE_HPP

#include <functional>
#include <memory> 

namespace quadrature {

/**
 * @brief Abstract interface for numerical quadrature rules.
 * 
 * This interface defines the contract for numerical integration rules,
 * allowing for flexible and extensible integration methods.
 * It supports both finite and infinite bounds, and provides a method
 * to integrate a function with specified error tolerances.
 *
 * @tparam NumericType The numeric type used for integration (e.g., double, float).
 */
template<typename NumericType>
class IQuadratureRule {
public:
    virtual ~IQuadratureRule() = default;

    /**
     * @brief Integrates the given function over the specified interval.
     * @param integrand A callable function object taking NumericType, returning NumericType.
     * @param lower_bound The lower integration limit.
     * @param upper_bound The upper integration limit.
     * @return The approximate value of the definite integral.
     */
    virtual NumericType integrate(
        const std::function<NumericType(NumericType)>& integrand,
        NumericType lower_bound,
        NumericType upper_bound) const = 0;

    /**
     * @brief Creates a copy of the underlying rule object.
     * Needed for value semantics of the QuadratureRuleHolder.
     * @return A std::unique_ptr to the new IQuadratureRule object.
     */
    virtual std::unique_ptr<IQuadratureRule<NumericType>> clone() const = 0;
};
} // namespace quadrature
#endif // I_QUADRATURE_RULE_HPP
./include/quadrature/Projector.hpp
/**
 * @file Projector.hpp
 * @brief Defines the Projector class template for weighted integration of products of functions using quadrature.
 *
 * The Projector class template enables the computation of integrals of the form:
 *   Integral(lower, upper, weight_fn(x) * f1(x) * f2(x) * ... * fn(x) dx)
 * where the user supplies a quadrature rule, a weight function, and a variadic list of input functions.
 * 
 * Dependencies:
 * - QuadratureRuleHolder.hpp: For the quadrature rule implementation.
 *
 */

#ifndef PROJECTOR_HPP
#define PROJECTOR_HPP

#include <functional>                 // For std::function
#include <tuple>                      // For std::tuple to store Args...
#include <vector>                     // Potentially useful, though tuple is primary storage
#include <utility>                    // For std::forward, std::move, std::index_sequence
#include <stdexcept>                  // For exceptions
#include <type_traits>                // For std::decay_t
#include "QuadratureRuleHolder.hpp" 


namespace quadrature {
// Forward declaration if needed, or include necessary headers for R type traits
/**
 * @brief Computes the weighted integral of the product of multiple functions.
 *
 * Accepts a variable number of input functions via its constructor.
 * Calculates Integral( lower, upper, weight_fn(x) * f1(x) * f2(x) * ... * fn(x) dx )
 * using a provided quadrature rule.
 *
 * @tparam R The numeric type for calculations (e.g., double, float).
 * @tparam FuncTypes The types of the input functions (f1, f2, ... fn).
 *         All must be callable with signature R(R).
 */
template <typename R, typename... FuncTypes>
class Projector {
private:
    // Store the input functions using a tuple. std::decay_t ensures copies/values.
    std::tuple<std::decay_t<FuncTypes>...> input_functions_;

    // Store the weight function
    std::function<R(R)> weight_function_;

    // Store the integration engine (holds its own copy)
    quadrature::QuadratureRuleHolder<R> integrator_;

    // --- Helper for evaluating the product using fold expression (C++17) ---
    R evaluate_product(R x) const {
        // Use std::apply to pass the functions in the tuple as arguments to the lambda
        return std::apply(
            [x](const auto&... funcs) -> R {
                // Compile-time check: Ensure all provided types are callable as R(R)
                static_assert((std::is_invocable_r_v<R, decltype(funcs), R> && ...),
                              "All input functions must be callable with signature R(R)");

                // Fold expression to multiply the results of calling each function with x
                if constexpr (sizeof...(funcs) > 0) {
                    // (func1(x) * func2(x) * ... * funcN(x))
                    return (funcs(x) * ...);
                } else {
                    // If FuncTypes... is empty, the product is 1.0
                    return R(1.0);
                }
            },
            input_functions_ // Pass the tuple holding the functions
        );
    }

public:
    /**
     * @brief Constructor for the Projector class accepting variadic functions.
     * @param integrator An initialized QuadratureRuleHolder (passed by const ref, will be copied).
     * @param weight_fn The weighting function std::function<R(R)>.
     * @param funcs Variadic arguments representing the functions whose product (with weight_fn) will be integrated. Must be callable as R(R).
     */
    Projector(
        const quadrature::QuadratureRuleHolder<R>& integrator, // Pass integrator by const reference
        std::function<R(R)> weight_fn,
        FuncTypes&&... funcs // Use forwarding references for input functions
    ) : input_functions_(funcs...), // Perfectly forward functions into the tuple
        weight_function_(std::move(weight_fn)),           // Move the weight function
        integrator_(integrator)                           // Initialize member by COPYING from the const reference
    {
        if (!integrator_.is_initialized()) {
             throw std::invalid_argument("Projector requires an initialized QuadratureRuleHolder.");
        }
        if (!weight_function_) {
            throw std::invalid_argument("Projector requires a valid weight function.");
        }
    }

    /**
     * @brief Computes the integral of weight_fn(x) * product(input_functions(x)) dx.
     * @param lower_bound The lower limit of integration.
     * @param upper_bound The upper limit of integration.
     * @return The computed integral value.
     * @throws std::runtime_error if the integrator fails or functions are invalid at runtime.
     */
    R compute_integral(R lower_bound, R upper_bound) const {
        // Define the full integrand: weight_fn(x) * product(input_funcs(x))
        auto full_integrand = [this](R x) -> R {
            R product = evaluate_product(x);
             if (!weight_function_) [[unlikely]] { // Should have been caught in ctor
                 throw std::runtime_error("Weight function became invalid after construction.");
            }
            return weight_function_(x) * product;
        };

        // Use the integrator from the QuadratureRuleHolder
        return integrator_.integrate(full_integrand, lower_bound, upper_bound);
    }

    const std::function<R(R)>& get_weight_function() const { return weight_function_; }
    const std::tuple<std::decay_t<FuncTypes>...>& get_input_functions() const { return input_functions_; }
    size_t get_num_input_functions() const { return sizeof...(FuncTypes); }
    const quadrature::QuadratureRuleHolder<R>& get_integrator() const { return integrator_; } // Returns const ref to the internal copy
};


// --- Deduction Guide (C++17) ---
template<typename R, typename... FuncTypes>
Projector(const quadrature::QuadratureRuleHolder<R>&, std::function<R(R)>, FuncTypes...)
    -> Projector<R, FuncTypes...>;

} // namespace quadrature
#endif // PROJECTOR_HPP
./include/quadrature/QuadratureRule.hpp
/**
 * @file QuadratureRule.hpp
 * @brief Provides generic quadrature (numerical integration) adapters for Boost and GSL libraries.
 *
 * This header defines two main quadrature classes:
 * - quadrature::BoostTanhSinhQuadrature: Adapter for Boost.Math's tanh_sinh quadrature, supporting finite and infinite bounds.
 * - quadrature::GSLQuadrature: Adapter for GSL's adaptive quadrature routines, supporting finite and infinite bounds with workspace management.
 *
 * Dependencies:
 * - Boost.Math for tanh_sinh quadrature.
 * - GSL (GNU Scientific Library) for adaptive quadrature.
 * - traits/OPOE_traits.hpp for type definitions.
 * 
 * Features:
 * - Type-generic (templated on floating-point type R).
 * - Handles both finite and infinite integration limits.
 * - Error control via absolute and relative tolerances.
 * - Exception-safe resource management for GSL workspaces.
 * - C++11/14 compatible, uses std::function for integrands.
 *
 *
 * Usage Example:
 * @code
 * #include "QuadratureRule.hpp"
 * 
 * quadrature::BoostTanhSinhQuadrature<double> boost_quad;
 * double result = boost_quad.integrate([](double x) { return std::exp(-x*x); }, -std::numeric_limits<double>::infinity(), std::numeric_limits<double>::infinity());
 * 
 * quadrature::GSLQuadrature<double> gsl_quad;
 * double gsl_result = gsl_quad.integrate([](double x) { return std::sin(x); }, 0.0, M_PI);
 * @endcode
 *
 */
#ifndef QUADRATURE_RULE_HPP
#define QUADRATURE_RULE_HPP

#include <stdexcept>
#include <limits>
#include <cmath> 
#include <string>
#include <vector> 
#include <boost/math/quadrature/tanh_sinh.hpp>
#include <boost/math/special_functions/fpclassify.hpp> 
#include <gsl/gsl_integration.h>
#include <gsl/gsl_errno.h> 
#include "traits/OPOE_traits.hpp" // Assuming this contains the DataType definition

namespace quadrature {

/**
 * @brief BoostTanhSinhQuadrature class for numerical integration using Boost's tanh_sinh quadrature.
 *
 * This class provides an adapter for Boost's tanh_sinh quadrature method, allowing for numerical integration
 * over finite and infinite bounds with specified error tolerances.
 *
 * @tparam R The floating-point type used for calculations (default: traits::DataType::PolynomialField).
 *
 * Features:
 * - Handles both finite and infinite bounds.
 * - Provides a method to integrate a function with specified absolute and relative error tolerances.
 * - Uses Boost's tanh_sinh quadrature internally for efficient integration.
 */
template<typename R = traits::DataType::PolynomialField>
class BoostTanhSinhQuadrature {
    R target_relative_error_;
    // tanh_sinh internally handles max levels, etc.

public:
    /**
     * @brief Constructor for Boost tanh_sinh adapter.
     * @param relative_error Target relative error for the integration.
     */
    explicit BoostTanhSinhQuadrature(R relative_error = std::sqrt(std::numeric_limits<R>::epsilon()))
        : target_relative_error_(relative_error) {}

    /**
     * @brief Integrates using Boost.Math's tanh_sinh quadrature.
     * @param integrand The function to integrate.
     * @param lower_bound Lower integration limit (-inf allowed).
     * @param upper_bound Upper integration limit (+inf allowed).
     * @return The approximate value of the definite integral.
     */
    R integrate(
        const std::function<R(R)>& integrand,
        R lower_bound,
        R upper_bound) const
    {
        if (!(boost::math::isfinite)(lower_bound) && !(boost::math::isfinite)(upper_bound)) {
             if (lower_bound > 0 || upper_bound < 0) { // e.g., integrate from inf to inf
                 return static_cast<R>(0.0);
             }
             // Default: -inf to +inf handled directly
        } else if (lower_bound >= upper_bound) {
             return static_cast<R>(0.0);
        }

        boost::math::quadrature::tanh_sinh<R> integrator(15); // Max level refinement (adjust if needed)

        R result = 0;
        R error_estimate = 0;
        R L1_norm = 0; // Estimate of L1 norm for error scaling

        try {
             // Boost's integrate handles finite and infinite bounds automatically
             result = integrator.integrate(integrand, lower_bound, upper_bound, target_relative_error_, &error_estimate, &L1_norm);


        } catch (const std::exception& e) {
             // Handle Boost exceptions (e.g., max levels reached, convergence issues)
             throw std::runtime_error(std::string("Boost quadrature failed: ") + e.what());
        }

        return result;
    }
};


/**
 * @brief GSLQuadrature class for numerical integration using GSL's adaptive quadrature.
 *
 * This class provides an adapter for GSL's adaptive quadrature routines, allowing for numerical integration
 * over finite and infinite bounds with specified absolute and relative error tolerances.
 * 
 * @tparam R The floating-point type used for calculations (default: traits::DataType::PolynomialField).
 */
template<typename R = traits::DataType::PolynomialField>
struct GSLIntegrationWrapper {
    // Must be static or a non-capturing lambda convertible to function pointer
    static R gsl_func_adapter(R x, void* params) {
        auto* func_ptr = static_cast<std::function<R(R)>*>(params);
        try {
            // GSL works with double, cast result if R is different (e.g., float)
            return static_cast<R>((*func_ptr)(static_cast<R>(x)));
        } catch (...) {
             // GSL doesn't handle C++ exceptions well across the C boundary.
             gsl_error("Caught C++ exception in GSL function adapter", __FILE__, __LINE__, GSL_FAILURE);
             return std::numeric_limits<R>::quiet_NaN();
        }
    }
};

/**
 * @brief GSLQuadrature class for numerical integration using GSL's adaptive quadrature.
 * 
 * This class provides an adapter for GSL's adaptive quadrature routines, allowing for numerical integration
 * over finite and infinite bounds with specified absolute and relative error tolerances.
 * 
 * @tparam R The floating-point type used for calculations (default: traits::DataType::PolynomialField).
 */
template<typename R = traits::DataType::PolynomialField>
class GSLQuadrature {
private:
    size_t workspace_size_;
    R target_absolute_error_;
    R target_relative_error_;

    // RAII wrapper for gsl_integration_workspace
    // Ensures workspace is freed even if exceptions occur
    using GSLWorkspacePtr = std::unique_ptr<gsl_integration_workspace, decltype(&gsl_integration_workspace_free)>;

     // Function to create a workspace (needed if allocation is per-call)
    GSLWorkspacePtr create_workspace() const {
        gsl_integration_workspace* ws = gsl_integration_workspace_alloc(workspace_size_);
        if (!ws) {
            throw std::runtime_error("Failed to allocate GSL workspace");
        }
        return GSLWorkspacePtr(ws, gsl_integration_workspace_free);
    }


public:
    /**
     * @brief Constructor for GSL adaptive quadrature adapter.
     * @param absolute_error Target absolute error.
     * @param relative_error Target relative error.
     * @param workspace_limit Max number of subintervals for the workspace.
     */
    explicit GSLQuadrature(
        R absolute_error = 1e-6,
        R relative_error = 1e-6,
        size_t workspace_limit = 1000)
        :
        workspace_size_(workspace_limit),
        target_absolute_error_(absolute_error),
        target_relative_error_(relative_error)
    {
        
    }

    /**
     * @brief Integrates using GSL's adaptive quadrature. Selects routine based on bounds.
     * @param integrand The function to integrate.
     * @param lower_bound Lower integration limit.
     * @param upper_bound Upper integration limit.
     * @return The approximate value of the definite integral.
     */
    R integrate(
        const std::function<R(R)>& integrand,
        R lower_bound,
        R upper_bound) const
    {
        // GSL functions predominantly work with double
        R lb = static_cast<R>(lower_bound);
        R ub = static_cast<R>(upper_bound);

        if (lb >= ub) return static_cast<R>(0.0);

        // Need a non-const copy of the integrand to get a non-const pointer for GSL params
        auto non_const_integrand = integrand;
        gsl_function F;
        F.function = &GSLIntegrationWrapper<R>::gsl_func_adapter;
        F.params = &non_const_integrand;

        R result = 0.0;
        R error_estimate = 0.0;

        int status = GSL_SUCCESS;

        // Allocate workspace per call for thread safety
        GSLWorkspacePtr workspace = create_workspace();


        // Choose GSL routine based on bounds
        bool upper_inf = (ub > std::numeric_limits<R>::max() / 2);
        bool lower_inf = (lb < -std::numeric_limits<R>::max() / 2);


        if (lower_inf && upper_inf) {
            // QAGI: Integrate over (-inf, +inf)
             status = gsl_integration_qagi(&F,
                                           target_absolute_error_,
                                           target_relative_error_,
                                           workspace_size_,
                                           workspace.get(),
                                           &result, &error_estimate);
        } else if (lower_inf) {
             // QAGIL: Integrate over (-inf, b)
            status = gsl_integration_qagil(&F, ub,
                                           target_absolute_error_,
                                           target_relative_error_,
                                           workspace_size_,
                                           workspace.get(),
                                           &result, &error_estimate);
        } else if (upper_inf) {
             // QAGIU: Integrate over (a, +inf)
             status = gsl_integration_qagiu(&F, lb,
                                           target_absolute_error_,
                                           target_relative_error_,
                                           workspace_size_,
                                           workspace.get(),
                                           &result, &error_estimate);
        } else {
             // QAGS: Integrate over (a, b) - general adaptive strategy

             status = gsl_integration_qags(&F, lb, ub,
                                          target_absolute_error_,
                                          target_relative_error_,
                                          workspace_size_,
                                          workspace.get(),
                                          &result, &error_estimate);
        }

        // --- GSL Error Handling ---
        if (status != GSL_SUCCESS) {
             throw std::runtime_error(std::string("GSL integration failed: ") + gsl_strerror(status));
        }

        return static_cast<R>(result); // Cast back to original R
    }
};

} // namespace quadrature
#endif // QUADRATURE_RULE_HPP
./include/quadrature/QuadratureRuleHolder.hpp
/**
 * @file QuadratureRuleHolder.hpp
 * @brief Defines the QuadratureRuleHolder class, a type-erased holder for various quadrature rule implementations.
 *
 * This header provides the QuadratureRuleHolder template class, which acts as a runtime-polymorphic wrapper
 * for different quadrature rule implementations (e.g., Boost Tanh-Sinh, GSL QAGI). The holder enables
 * selection and usage of a quadrature rule via a common interface, supporting both default and parameterized
 * construction. Deep copy and move semantics are implemented, and integration is performed via a uniform method.
 * 
 * Dependencies:
 * - QuadratureWrappers.hpp: Contains concrete wrapper implementations for specific quadrature rules.
 * - traits/OPOE_traits.hpp: Defines the QuadratureMethod enum and other type traits.
 */
#ifndef QUADRATURE_RULE_HOLDER_HPP
#define QUADRATURE_RULE_HOLDER_HPP


#include <memory>
#include <stdexcept>
#include <utility> // For std::move
#include "QuadratureWrappers.hpp" // Include concrete wrappers
#include "../traits/OPOE_traits.hpp" // Include abstract interface

namespace quadrature {
using QuadratureType = traits::QuadratureMethod; 

/**
 * @brief A holder class for different numerical quadrature rules.
 * 
 * This class encapsulates various quadrature rules through runtime polymorphism.
 * It enables selection and usage of a rule at runtime, while maintaining a consistent interface.
 * 
 * @tparam R The floating-point type used for integration (e.g., float, double).
 */
template<typename R>
class QuadratureRuleHolder {
private:
    std::unique_ptr<IQuadratureRule<R>> p_rule_;

public:
/**
     * @brief Constructor selecting rule based on enum. Uses default parameters for rules.
     * 
     * @param type The enum value specifying which quadrature rule to use.
     * @throws std::invalid_argument If an unsupported quadrature type is specified.
     */
    explicit QuadratureRuleHolder(QuadratureType type = QuadratureType::TanhSinh) {
        switch (type) {
            case QuadratureType::TanhSinh:
                // Create the Boost wrapper using its default parameters
                p_rule_ = std::make_unique<BoostQuadratureWrapper<R>>();
                break;
            case QuadratureType::QAGI:
                 // Create the GSL wrapper using its default parameters
                p_rule_ = std::make_unique<GSLQuadratureWrapper<R>>();
                break;            
            default:
                throw std::invalid_argument("Unsupported QuadratureType specified.");
        }
    }

    /**
     * @brief Constructor for Boost quadrature with a custom tolerance.
     * 
     * @param type Must be QuadratureType::TanhSinh.
     * @param boost_tolerance Desired error tolerance for Boost quadrature.
     * @throws std::invalid_argument If the type is not TanhSinh.
     */
    QuadratureRuleHolder(QuadratureType type, R boost_tolerance) {
         if (type != QuadratureType::TanhSinh)
            throw std::invalid_argument("Tolerance parameter constructor only valid for BOOST_TANH_SINH");
         p_rule_ = std::make_unique<BoostQuadratureWrapper<R>>(boost_tolerance);
    }
    /**
     * @brief Constructor for GSL quadrature with custom absolute/relative tolerances and workspace size.
     * 
     * @param type Must be QuadratureType::QAGI.
     * @param gsl_abs_tol Absolute error tolerance for GSL quadrature.
     * @param gsl_rel_tol Relative error tolerance for GSL quadrature.
     * @param gsl_ws_size Workspace size for the GSL integrator.
     * @throws std::invalid_argument If the type is not QAGI.
     */
    QuadratureRuleHolder(QuadratureType type, double gsl_abs_tol, double gsl_rel_tol, size_t gsl_ws_size) {
         if (type != QuadratureType::QAGI)
             throw std::invalid_argument("GSL parameter constructor only valid for GSL_ADAPTIVE");
         p_rule_ = std::make_unique<GSLQuadratureWrapper<R>>(gsl_abs_tol, gsl_rel_tol, gsl_ws_size);
    }


    /**
     * @brief Copy constructor. Performs a deep copy using the clone interface.
     * 
     * @param other The other QuadratureRuleHolder to copy from.
     */   

    QuadratureRuleHolder(const QuadratureRuleHolder& other)
        : p_rule_(other.p_rule_ ? other.p_rule_->clone() : nullptr) {}

    /**
     * @brief Copy assignment operator. Performs a deep copy using the clone interface.
     * 
     * @param other The other QuadratureRuleHolder to assign from.
     * @return Reference to this object.
     */    
    QuadratureRuleHolder& operator=(const QuadratureRuleHolder& other) {
        if (this != &other) {
             // Clone before releasing the old pointer
             p_rule_ = other.p_rule_ ? other.p_rule_->clone() : nullptr;
        }
        return *this;
    }

    /**
     * @brief Move constructor. Transfers ownership of the held rule.
     * 
     * @param other The other QuadratureRuleHolder to move from.
     */
    QuadratureRuleHolder(QuadratureRuleHolder&& other) noexcept = default;

    /**
     * @brief Move assignment operator. Transfers ownership of the held rule.
     * 
     * @param other The other QuadratureRuleHolder to move-assign from.
     * @return Reference to this object.
     */    
    QuadratureRuleHolder& operator=(QuadratureRuleHolder&& other) noexcept = default;
   
    /**
     * @brief Default constructor. Leaves the internal rule uninitialized.
     */
    QuadratureRuleHolder() = default;


    /**
     * @brief Integrates the given function over the specified interval using the held quadrature rule.
     * 
     * @param integrand The function to integrate. Should be callable as f(x) -> R.
     * @param lower_bound Lower limit of integration.
     * @param upper_bound Upper limit of integration.
     * @return The computed integral value.
     * @throws std::runtime_error If no quadrature rule has been initialized.
     */
    R integrate(
        const std::function<R(R)>& integrand,
        R lower_bound,
        R upper_bound) const
    {
        if (!p_rule_) {
            throw std::runtime_error("QuadratureRuleHolder is not initialized with a rule.");
        }
        return p_rule_->integrate(integrand, lower_bound, upper_bound);
    }

    /**
     * @brief Checks whether a quadrature rule is currently initialized.
     * 
     * @return True if a rule is initialized, false otherwise.
     */
    bool is_initialized() const {
        return p_rule_ != nullptr;
    }
};

} // namespace quadrature
#endif // QUADRATURE_RULE_HOLDER_HPP
./include/quadrature/QuadratureWrappers.hpp

/**
 * @file QuadratureWrappers.hpp
 * @brief Provides wrapper classes for different quadrature (numerical integration) backends.
 *
 * This header defines wrapper classes for Boost and GSL quadrature rules, allowing them to be used
 * through a common interface. The wrappers manage the underlying rule objects
 * and provide methods for integration and cloning.
 * 
 * Dependencies:
 * - QuadratureRule.hpp: Base class for quadrature rules.
 * - QuadratureRuleAbstract.hpp: Abstract interface for quadrature rules.
 *
 */
#ifndef QUADRATURE_WRAPPERS_HPP
#define QUADRATURE_WRAPPERS_HPP

#include <memory>
#include "QuadratureRule.hpp"
#include "QuadratureRuleAbstract.hpp"

namespace quadrature {
/**
 * @class BoostQuadratureWrapper
 * @tparam R The floating-point type used for integration (e.g., double).
 * @brief Wrapper for the Boost Tanh-Sinh quadrature rule.
 *
 * This class wraps a `BoostTanhSinhQuadrature` instance and exposes it through the `IQuadratureRule` interface.
 * It supports construction from an existing rule or by specifying the desired relative error.
 *
 * - `integrate`: Performs numerical integration using the wrapped Boost rule.
 * - `clone`: Creates a deep copy of the wrapper and its underlying rule.
 *
 * 
 */
template<typename R = traits::DataType::PolynomialField>
class BoostQuadratureWrapper final : public IQuadratureRule<R> {
    BoostTanhSinhQuadrature<R> rule_;
public:
    // Constructor taking the specific rule instance
    explicit BoostQuadratureWrapper(const BoostTanhSinhQuadrature<R>& rule)
        : rule_(rule) {}

    // Constructor taking parameters to create the rule internally
    explicit BoostQuadratureWrapper(R relative_error = std::sqrt(std::numeric_limits<R>::epsilon()))
        : rule_(relative_error) {}

    R integrate(
        const std::function<R(R)>& integrand,
        R lower_bound,
        R upper_bound) const override {
        return rule_.integrate(integrand, lower_bound, upper_bound);
    }

    std::unique_ptr<IQuadratureRule<R>> clone() const override {
        // Create a new wrapper containing a copy of the rule
        return std::make_unique<BoostQuadratureWrapper<R>>(rule_);
    }
};

/**
 * @class GSLQuadratureWrapper
 * @tparam R The floating-point type used for integration (e.g., double).
 * @brief Wrapper for the GSL adaptive quadrature rule.
 *
 * This class wraps a `GSLQuadrature` instance and exposes it through the `IQuadratureRule` interface.
 * It supports construction from an existing rule or by specifying the desired absolute and relative errors.
 *
 * - `integrate`: Performs numerical integration using the wrapped GSL rule.
 * - `clone`: Creates a deep copy of the wrapper and its underlying rule.
 */
template<typename R = traits::DataType::PolynomialField>
class GSLQuadratureWrapper final : public IQuadratureRule<R> {
     GSLQuadrature<R> rule_;
 public:
    // Constructor taking the specific rule instance
     explicit GSLQuadratureWrapper(const GSLQuadrature<R>& rule)
         : rule_(rule) {} // Note: GSLQuadrature might not be easily copyable if workspace is member

    // Constructor taking parameters to create the rule internally
    explicit GSLQuadratureWrapper(
        R absolute_error = 1e-9,
        R relative_error = 1e-9,
        size_t workspace_limit = 1000)
        : rule_(absolute_error, relative_error, workspace_limit) {}


     R integrate(
         const std::function<R(R)>& integrand,
         R lower_bound,
         R upper_bound) const override {
         return rule_.integrate(integrand, lower_bound, upper_bound);
     }

     std::unique_ptr<IQuadratureRule<R>> clone() const override {
          return std::make_unique<GSLQuadratureWrapper<R>>(
              rule_); 

     }
};

} // namespace quadrature
#endif // QUADRATURE_WRAPPERS_HPP
./include/options/BaseOptionPricer.hpp

/**
 * @file BaseOptionPricer.hpp
 * @brief Defines the BaseOptionPricer class, an abstract base class for option pricing models.
 *
 * This file contains the declaration of the BaseOptionPricer template class, which provides
 * a common interface and storage for option pricing parameters and payoff functions.
 * It is intended to be subclassed by specific option pricing implementations (e.g., FFTPricer, MCPricer).
 *
 * Dependencies:
 * - traits/OPOE_traits.hpp: Contains type definitions and traits for polynomial operations.
 * - Payoff.hpp: Defines the IPayoff interface for option payoffs.
 * - FinModels.hpp: Interface for stochastic differential equation models.
 */
#ifndef BASE_OPTION_PRICER_HPP
#define BASE_OPTION_PRICER_HPP

#include <cmath>
#include <memory>
#include "../traits/OPOE_traits.hpp"
#include "Payoff.hpp"
#include "../sde/FinModels.hpp"

namespace options {
    using Array = traits::DataType::StoringArray;

    /**
     * @brief Base class for option pricing.
     * This class provides a common interface for option pricing methods.
     * It holds the basic parameters of the option and the payoff function.
     * @tparam R The floating-point type used for calculations (default: traits::DataType::PolynomialField).
     * 
     * This class is designed to be inherited by specific option pricers like FFTPricer, MCPricer, etc.
     * It provides a common interface for setting and getting option parameters like time to maturity, strike price, and risk-free rate.
     * It also holds a shared pointer to the payoff function, which can be evaluated by derived classes.
     */
    template <typename R = traits::DataType::PolynomialField>
    class BaseOptionPricer {

        public:

            /**
             * @brief Constructs a BaseOptionPricer instance.
             * @param ttm Time to maturity.
             * @param rate Risk-free interest rate.
             * @param payoff Payoff function for the option.
             * @param sde_model Shared pointer to the SDE model used for pricing.
             */
            BaseOptionPricer(R ttm, R rate, std::shared_ptr<IPayoff<R>> payoff, std::shared_ptr<SDE::ISDEModel<R>> sde_model)
                : ttm_(ttm), rate_(rate), payoff_(payoff), sde_model_(sde_model) {}

            virtual ~BaseOptionPricer() = default;

            // Copy constructor
            BaseOptionPricer(const BaseOptionPricer& other)
                : payoff_(other.payoff_ ? other.payoff_->clone() : nullptr) {}

            // Copy assignment
            BaseOptionPricer& operator=(const BaseOptionPricer& other) {
                if (this != &other) {
                    payoff_ = other.payoff_ ? other.payoff_->clone() : nullptr;
                }
                return *this;
            }

            // Move constructor/assignment
            BaseOptionPricer(BaseOptionPricer&&) noexcept = default;
            BaseOptionPricer& operator=(BaseOptionPricer&&) noexcept = default;

            // The common pricing interface for all methods

            virtual R price() const = 0;

            inline void set_ttm(R ttm) noexcept { ttm_ = ttm; }
            inline R get_ttm() const noexcept { return ttm_; }

            inline void set_rate(R rate) noexcept { rate_ = rate; }
            inline R get_rate() const noexcept { return rate_; }

        protected:

        R ttm_;
        R rate_;
        std::shared_ptr<IPayoff<R>> payoff_;
        std::shared_ptr<SDE::ISDEModel<R>> sde_model_;

    };


} // namespace options

#endif // BASE_OPTION_PRICER_HPP./include/options/MCOptionPricer.hpp
/**
 * @file MCOptionPricer.hpp
 * @brief Defines the MCOptionPricer class for Monte Carlo option pricing.
 *
 * This header provides the implementation of a Monte Carlo pricer for financial options.
 * The MCOptionPricer class simulates multiple paths of the underlying asset using a provided
 * stochastic differential equation (SDE) model and a solver function. It evaluates the
 * option payoff at maturity for each simulated path and computes the expected discounted
 * payoff as the option price.
 *
 * Key features:
 * - Templated on the floating-point type for flexibility.
 * - Accepts custom payoff and SDE models via polymorphic interfaces.
 * - Allows injection of a custom SDE solver function.
 * - Supports configuration of the number of Monte Carlo paths and time steps.
 *
 * Dependencies:
 * - Eigen for matrix and vector operations.
 * - Standard library components for memory management and function objects.
 * - SDE.hpp for the SDE model interface.
 * - BaseOptionPricer.hpp for the base class of option pricing.
 *
 */

#ifndef MC_OPTION_PRICER_HPP
#define MC_OPTION_PRICER_HPP

#include "BaseOptionPricer.hpp"
#include "../sde/SDE.hpp"
#include <memory>
#include <Eigen/Dense>
#include <iostream>
#include <functional>

namespace options {

/**
 * @brief Monte Carlo Option Pricer class for pricing options using Monte Carlo simulation.
 *
 * This class implements the Monte Carlo method for option pricing, simulating paths of the underlying asset
 * and calculating the expected payoff at maturity.
 *
 * @tparam R The floating-point type used for calculations (default: traits::DataType::PolynomialField).
 */
    
template<typename R>
class MCOptionPricer : public BaseOptionPricer<R> {
public:
    using StoringVector = traits::DataType::StoringVector;
    using StoringMatrix = traits::DataType::StoringMatrix;
    using SolverType = traits::SolverType;

    
    /**
     * @brief Constructs a MCOptionPricer instance.
     *
     * @param ttm Time to maturity.
     * @param rate Risk-free interest rate.
     * @param payoff Payoff function for the option.
     * @param sde_model Shared pointer to the SDE model used for path generation.
     * @param solver_type Enum indicating the solver type.
     * @param num_paths Number of Monte Carlo paths to simulate (default: 10).
     * @param num_steps Number of time steps in each path (default: 3).
     */
    MCOptionPricer(R ttm, R rate,
             std::shared_ptr<IPayoff<R>> payoff,
             std::shared_ptr<SDE::ISDEModel<R>> sde_model,
             SolverType solver_type,
             unsigned int num_paths = 10,
             unsigned int num_steps = 3)
        : BaseOptionPricer<R>(ttm, rate, std::move(payoff), std::move(sde_model)),
          solver_type_(solver_type),
          num_paths_(num_paths),
          num_steps_(num_steps)
    {}


    /**
     * @brief Prices the option using Monte Carlo simulation.
     * This method generates paths of the underlying asset using the provided SDE model,
     * evaluates the payoff at maturity, and returns the expected discounted payoff.
     * @return The computed option price.
     * 
     */
    R price() const override {

        StoringMatrix all_paths;

        switch (solver_type_) {
            case SolverType::EulerMaruyama:
                all_paths = SDE::EulerMaruyamaSolver<SDE::ISDEModel<R>, R>(*this->sde_model_)
                                .solve(0.0, this->ttm_, num_steps_, num_paths_, std::nullopt);
                break;

            case SolverType::Milstein:
                all_paths = SDE::MilsteinSolver<SDE::ISDEModel<R>, R>(*this->sde_model_)
                                .solve(0.0, this->ttm_, num_steps_, num_paths_, std::nullopt);
                break;

            case SolverType::IJK:
                all_paths = SDE::InterpolatedKahlJackelSolver<SDE::ISDEModel<R>, R>(*this->sde_model_)
                                .solve(0.0, this->ttm_, num_steps_, num_paths_, std::nullopt);
                break;

            default:
                throw std::runtime_error("Unknown solver type");
        }

        int state_dim = this->sde_model_->get_state_dim();
        StoringVector terminal_column = all_paths.col(num_steps_);

        StoringVector terminal_logS(num_paths_);

        if (state_dim == 1) {
            terminal_logS = terminal_column;
        } else {
            terminal_logS = Eigen::Map<const StoringVector, 0, Eigen::InnerStride<>>(
                terminal_column.data() + 1,
                num_paths_,
                Eigen::InnerStride<>(state_dim)
            );
        }



        auto payoffs = this->payoff_->evaluate_from_log(terminal_logS);


        return std::exp(-this->rate_ * this->ttm_) * payoffs.mean();
    }

private:
    SolverType solver_type_;
    unsigned int num_paths_;
    unsigned int num_steps_;
};

} // namespace options

#endif // MC_OPTION_PRICER_HPP
./include/options/Payoff.hpp
/**
 * @file Payoff.hpp
 * @brief Defines interfaces and concrete classes for option payoff evaluation in quantitative finance.
 *
 * This header provides a generic interface (`IPayoff`) for evaluating the payoff of financial derivatives,
 * such as options, given the final price or log-price of the underlying asset. It also includes concrete
 * implementations for European call and put options, supporting both price and log-price evaluation.
 *
 * Classes:
 * - IPayoff<T>: Abstract base class for option payoffs, supporting polymorphic evaluation and cloning.
 * - EuropeanCallPayoff<T>: Implements the payoff for a European call option.
 * - EuropeanPutPayoff<T>: Implements the payoff for a European put option.
 *
 *
 * Usage:
 *   - Instantiate concrete payoff classes with the desired strike price.
 *   - Use `evaluate` for payoff calculation from price, or `evaluate_from_log` for log-price.
 *   - Use `clone` for polymorphic copying.
 *
 * Example:
 *   options::EuropeanCallPayoff<double> call(100.0);
 *   double payoff = call.evaluate(105.0); // Returns 5.0
 */
#ifndef PAYOFF_HPP
#define PAYOFF_HPP
#include <algorithm> 
#include <cmath>     
#include <memory>    
#include <stdexcept> 
#include "../traits/OPOE_traits.hpp" 


namespace options {

using StoringVector = traits::DataType::StoringVector;
using Array = traits::DataType::StoringArray;

/**
 * @brief Interface for option payoffs.
 * This class defines the contract for evaluating the payoff of financial derivatives,
 * such as options, based on the final price or log-price of the underlying asset.
 *
 * @tparam T The numeric type used for the strike price and evaluations (default: traits::DataType::PolynomialField).
 */
template <typename T = traits::DataType::PolynomialField>
class IPayoff {
public:
    // Virtual destructor is essential for polymorphic base classes
    virtual ~IPayoff() = default;

    /**
     * @brief Evaluates the payoff for a given final underlying asset price.
     * @param underlying_price The final price (S_T) of the underlying asset.
     * @return The calculated payoff value.
     */
    virtual T evaluate(T underlying_price) const = 0;   

    /**
     * @brief Evaluates the payoff for a given vector of final underlying asset prices.
     * @param underlying_prices The final prices (S_T) of the underlying asset.
     * @return The calculated payoff value for each underlying.
     */
    virtual StoringVector evaluate(StoringVector underlying_prices) const = 0;   
    
    
    /**
     * @brief Returns the type of the option (Call or Put).
     * @return The type of the option as an enum value.
     */
    virtual traits::OptionType type() const = 0;

    /**
     * @brief Creates a copy of the payoff object.
     * @return A std::unique_ptr to the new IPayoff object.
     */
    virtual std::unique_ptr<IPayoff<T>> clone() const = 0;

    // Optional: Add a method to evaluate based on log-price if frequently needed
    /**
     * @brief Evaluates the payoff for a given final log-price of the underlying.
     * @param log_underlying_price The final log-price (x_T = ln(S_T)) of the underlying asset.
     * @return The calculated payoff value.
     */
    virtual T evaluate_from_log(T log_underlying_price) const {
        // Default implementation converts log-price to price
        // Derived classes can override if a more direct calculation exists
        return evaluate(std::exp(log_underlying_price));
    }

    /**
     * @brief Evaluates the payoff for a vector of final log-prices of the underlying.
     * @param log_underlying_prices The final log-prices (x_T = ln(S_T)) of the underlying asset.
     * @return A vector of calculated payoffs for each log-price.
     */
    virtual StoringVector evaluate_from_log(StoringVector log_underlying_prices) const {
        // Default implementation converts log-prices to prices
        // Derived classes can override if a more direct calculation exists
        return evaluate(log_underlying_prices.array().exp());
    }

    virtual T getStrike() const = 0;
    /**
     * @brief Sets the strike price.
     * @param strike_price The new strike price (K).
     * @throws std::invalid_argument if the strike price is negative.
     */
    virtual void setStrike(T strike_price) = 0;
};

/**
 * @brief Specialization of IPayoff for European Call options.
 *
 * This class implements the payoff evaluation for European call options,
 * defined as max(S_T - K, 0), where S_T is the final price of the underlying asset
 * and K is the strike price.
 *
 * @tparam T The numeric type used for the strike price and evaluations (default: traits::DataType::PolynomialField).
 */
template <typename T = traits::DataType::PolynomialField>
class EuropeanCallPayoff final : public IPayoff<T> {
private:
    T strike_price_;

public:
    /**
     * @brief Constructor for European Call Payoff.
     * @param strike_price The strike price (K) of the option.
     */
    explicit EuropeanCallPayoff(T strike_price) : strike_price_(strike_price) {
        if (strike_price < static_cast<T>(0.0)) {
            throw std::invalid_argument("Strike price cannot be negative.");
        }
    }

    /**
     * @brief Returns the type of the option (Call).
     * @return The type of the option as traits::OptionType::Call.
     */
    traits::OptionType type() const override {
        return traits::OptionType::Call; // Return the type of the option
    }

    /**
     * @brief Evaluates the call payoff: max(S_T - K, 0).
     * @param underlying_price The final price (S_T) of the underlying asset.
     * @return The calculated call payoff value.
     */
    T evaluate(T underlying_price) const override {
        return std::max(underlying_price - strike_price_, static_cast<T>(0.0));
    }

    /**
     * @brief Evaluates the call payoff for a vector of underlying prices.
     * @param underlying_prices The final prices (S_T) of the underlying asset.
     * @return A vector of calculated call payoffs for each underlying price.
     */
    StoringVector evaluate(StoringVector underlying_prices) const override {
        // Vectorized evaluation for multiple underlying prices
        StoringVector payoffs(underlying_prices.size());
        
        payoffs = (underlying_prices.array() - strike_price_).cwiseMax(static_cast<T>(0.0));
        return payoffs;
    }

     /**
     * @brief Evaluates the call payoff from log-price: max(exp(x_T) - K, 0).
     * @param log_underlying_price The final log-price (x_T = ln(S_T)) of the underlying asset.
     * @return The calculated call payoff value.
     */
    T evaluate_from_log(T log_underlying_price) const override {
         return std::max(std::exp(log_underlying_price) - strike_price_, static_cast<T>(0.0));
    }

    /**
     * @brief Creates a copy of the EuropeanCallPayoff object.
     * @return A std::unique_ptr to the new IPayoff object.
     */
    std::unique_ptr<IPayoff<T>> clone() const override {
        // Use make_unique for safe and efficient memory allocation
        return std::make_unique<EuropeanCallPayoff<T>>(*this);
    }

    /**
     * @brief Gets the strike price.
     * @return The strike price (K).
     */
    T getStrike() const noexcept override {
        return strike_price_;
    }

    /**
     * @brief Sets the strike price.
     * @param strike_price The new strike price (K).
     * @throws std::invalid_argument if the strike price is negative.
     */
    void setStrike(T strike_price) override {
        if (strike_price < static_cast<T>(0.0)) {
            throw std::invalid_argument("Strike price cannot be negative.");
        }
        strike_price_ = strike_price;
    }
};


/**
 * @brief Specialization of IPayoff for European Put options.
 *
 * This class implements the payoff evaluation for European put options,
 * defined as max(K - S_T, 0), where S_T is the final price of the underlying asset
 * and K is the strike price.
 *
 * @tparam T The numeric type used for the strike price and evaluations (default: traits::DataType::PolynomialField).
 */
template <typename T = traits::DataType::PolynomialField>
class EuropeanPutPayoff final : public IPayoff<T> {
private:
    T strike_price_;

public:
    /**
     * @brief Constructor for European Put Payoff.
     * @param strike_price The strike price (K) of the option.
     */
    explicit EuropeanPutPayoff(T strike_price) : strike_price_(strike_price) {
         if (strike_price < static_cast<T>(0.0)) {
            throw std::invalid_argument("Strike price cannot be negative.");
        }
    }

    /**
     * @brief Returns the type of the option (Put).
     * @return The type of the option as traits::OptionType::Put.
     */
    traits::OptionType type() const override {
        return traits::OptionType::Put;
    }

    /**
     * @brief Evaluates the put payoff: max(K - S_T, 0).
     * @param underlying_price The final price (S_T) of the underlying asset.
     * @return The calculated put payoff value.
     */
    T evaluate(T underlying_price) const override {
        return std::max(strike_price_ - underlying_price, static_cast<T>(0.0));
    }
    
    /**
     * @brief Evaluates the put payoff for a vector of underlying prices.
     * @param underlying_prices The final prices (S_T) of the underlying asset.
     * @return A vector of calculated put payoffs for each underlying price.
     */
    StoringVector evaluate(StoringVector underlying_prices) const override {
        // Vectorized evaluation for multiple underlying prices
        StoringVector payoffs(underlying_prices.size());
        payoffs = (strike_price_ - underlying_prices.array()).cwiseMax(static_cast<T>(0.0));
        return payoffs;
    }

    /**
     * @brief Evaluates the put payoff from log-price: max(K - exp(x_T), 0).
     * @param log_underlying_price The final log-price (x_T = ln(S_T)) of the underlying asset.
     * @return The calculated put payoff value.
     */
    T evaluate_from_log(T log_underlying_price) const override {
         return std::max(std::log(strike_price_) - log_underlying_price, static_cast<T>(0.0));
    }


    /**
     * @brief Creates a copy of the EuropeanPutPayoff object.
     * @return A std::unique_ptr to the new IPayoff object.
     */
    std::unique_ptr<IPayoff<T>> clone() const override {
        return std::make_unique<EuropeanPutPayoff<T>>(*this);
    }

    /**
     * @brief Gets the strike price.
     * @return The strike price (K).
     */
    T getStrike() const noexcept override {
        return strike_price_;
    }

        /**
     * @brief Sets the strike price.
     * @param strike_price The new strike price (K).
     * @throws std::invalid_argument if the strike price is negative.
     */
    void setStrike(T strike_price) override {
        if (strike_price < static_cast<T>(0.0)) {
            throw std::invalid_argument("Strike price cannot be negative.");
        }
        strike_price_ = strike_price;
    }

};

} // namespace options

#endif // PAYOFF_HPP
./include/options/OPEOptionPricer.hpp
/**
 * @file OPEOptionPricer.hpp
 * @brief Defines the OPEOptionPricer class for pricing options using Orthogonal Polynomial Expansion (OPE).
 *
 * This header provides the implementation of the OPEOptionPricer class template, which inherits from BaseOptionPricer.
 * The class uses orthogonal polynomial expansions and mixture densities to efficiently price options under stochastic volatility models.
 * It supports flexible polynomial bases, customizable quadrature integration, and leverages quantization grids for path discretization.
 *
 * Dependencies:
 * - BaseOptionPricer.hpp: Base class for option pricing.
 * - SDE.hpp: Interface for stochastic differential equation models.
 * - Utils.hpp: Utility functions for enumerating polynomial bases and other operations.
 * - MixtureDensity.hpp: For handling mixture densities in polynomial expansions.
 * - QuadratureRuleHolder.hpp: For configurable quadrature integration methods.
 * 
 * @section Features
 * - Constructs an orthonormal polynomial basis for the expansion.
 * - Computes the generator matrix and propagates it via matrix exponentiation.
 * - Integrates the expected payoff using a configurable quadrature rule.
 * - Supports custom SDE solvers and stochastic volatility models.
 * - Outputs intermediate results and integrand values for debugging and analysis.
 *
 * @section Usage
 * Instantiate OPEOptionPricer with the desired template parameters, provide the required SDE model, payoff, and solver function.
 * Call the price() method to compute the discounted expected payoff.
 *
 * @section Example
 * @code
 * auto pricer = options::OPEOptionPricer<>(ttm, rate, payoff, sde_model, solver_type);
 * double option_price = pricer.price();
 * @endcode
 *
 * @see BaseOptionPricer
 * @see stats::MixtureDensity
 * @see quadrature::QuadratureRuleHolder
 */
#ifndef OPTION_PRICER_HPP
#define OPTION_PRICER_HPP

#include "../utils/FileReader.hpp"
#include "../utils/Utils.hpp"
#include "../quadrature/Projector.hpp"
#include "../quadrature/QuadratureRuleHolder.hpp"
#include "../stats/MixtureDensity.hpp"
#include "../traits/OPOE_traits.hpp"
#include "BaseOptionPricer.hpp"
#include <unsupported/Eigen/MatrixFunctions>
#include <variant>
#include <stdexcept>
#include <string>
#include <utility>
#include <cmath>
#include <execution>

namespace options {

/**
 * @brief OPEOptionPricer class for pricing options using Orthogonal Polynomial Expansion (OPE).
 *
 * This class implements the OPE method for option pricing, leveraging orthogonal polynomial expansions and mixture densities.
 * It supports flexible polynomial bases and integrates the expected payoff using configurable quadrature rules.
 *
 * @tparam R The floating-point type used for calculations (default: traits::DataType::PolynomialField).
 * @tparam PolynomialBaseDegree The degree of the polynomial basis (must be >= 2).
 */

template <typename R = traits::DataType::PolynomialField,
unsigned int PolynomialBaseDegree = 3>
requires (PolynomialBaseDegree >= 2 && std::is_integral_v<decltype(PolynomialBaseDegree)>) 
// Ensure the polynomial degree is at least 2, since approximation of the wiener motion with only 1 point is trivial (0, with 100% probability);
// Moreover, PolynomialBaseDegree must be an integral type
class OPEOptionPricer : public BaseOptionPricer<R> {
    static_assert(PolynomialBaseDegree >= 2, 
                  "PolynomialBaseDegree must be >= 2");

    using StoringVector = traits::DataType::StoringVector;
    using StoringMatrix = traits::DataType::StoringMatrix;
    using Array = traits::DataType::StoringArray;    
    using SolverType = traits::SolverType;


    using Base = BaseOptionPricer<R>;

    using DensityType = stats::BoostBaseDensity<
        boost::math::normal_distribution<R>, R, R, R>;

public:
/**
 * @brief Constructs an OPEOptionPricer instance.
 *
 * @param ttm Time to maturity.
 * @param rate Risk-free interest rate.
 * @param payoff Payoff function for the option.
 * @param sde_model Shared pointer to the stochastic differential equation model.
 * @param solver_type Enum that represents the solver type.
 * @param integrator_param Quadrature method for integration (default: TanhSinh).
 * @param num_paths Number of paths for simulation (default: 10).
 *
 * @throws std::invalid_argument if PolynomialBaseDegree < 2.
 * @throws std::runtime_error if the polynomial basis cannot be constructed.
 *
 * This constructor initializes the OPEOptionPricer with the provided parameters,
 * constructs the orthonormal polynomial basis, and prepares the density object for pricing.
 */
    OPEOptionPricer(R ttm, R rate,
                    std::shared_ptr<IPayoff<R>> payoff,
                    std::shared_ptr<SDE::ISDEModel<R>> sde_model,
                    SolverType solver_type,
                    traits::QuadratureMethod integrator_param = traits::QuadratureMethod::TanhSinh,
                    unsigned int num_paths = 10)
        : Base(ttm, rate, std::move(payoff), sde_model)
        , num_paths_(num_paths)
        , solver_type_(solver_type)
        , density_object_(make_density_object(ttm, num_paths, PolynomialBaseDegree,
                                              solver_type_, sde_model))
        , integrator_(integrator_param)
                                            
    {
        density_object_.constructOrthonormalBasis();
        density_object_.constructQProjectionMatrix();    
    }

    /**
     * @brief Computes the option price using the OPE method.
     *
     * This method calculates the expected value of the option payoff at maturity,
     * integrating over the log-spot price using the orthonormal polynomial basis.
     *
     * @return The computed option price.
     */
    R price() const override {
        // 1. Get the generator matrix H and the polynomial basis
        const auto& H = density_object_.getHMatrix();     // (N+1)x(N+1)
        const auto E  = Utils::enumerate_basis(PolynomialBaseDegree);
        const unsigned int M   = static_cast<int>(E.size());

        const auto mean = density_object_.mean();
        const auto stddev = std::sqrt(density_object_.variance());
        

        auto* gen_sde_model = dynamic_cast<SDE::GenericSVModelSDE<R>*>(this->sde_model_.get());
        const auto X0 = gen_sde_model->get_x0();  // Initial value
        const auto V0 = gen_sde_model->get_v0();  // Initial volatility
        
        StoringMatrix G = gen_sde_model->generator_G(E, H);         // MxM

        StoringVector h_vals = Utils::build_h_vals<R>(H, E, PolynomialBaseDegree, X0, V0);

        // Matrix exponential
        StoringMatrix expGT = (this->get_ttm() * G).exp();

        // 2. Build sparse selector matrix S (M x (N+1)), columns = e_{pi(0,n)}
        StoringMatrix S = StoringMatrix::Zero(M, PolynomialBaseDegree+1);
        for (unsigned int i = 0; i < M; ++i) {
            if (E[i].first == 0 && E[i].second <= PolynomialBaseDegree) {
                S(i, E[i].second) = 1.0;
            }
        }

        // 3. Compute all l_n in one shot: l = h_vals^T * expGT * S
        StoringVector l_values = (h_vals.transpose() * expGT * S).transpose();

        // 4. Get integration domain 
        //stats::DensityInterval<R> support = this->density_object_.getSupport();

        auto h_functions = density_object_.getHFunctionsMixture();

        // Integrand(x) = Payoff_log(x) * [ Σ_{n=0 to N} ℓ_n * H_n(x) ] * w(x)
        // where x is the log_spot.

        auto full_integrand_function =

            [this, &h_functions, &l_values](R log_spot_price) -> R {

            // Calculate Σ_{n=0 to N} ℓ_n * H_n(log_spot_price)
            R auxiliary_density_value = static_cast<R>(0.0);

            for (unsigned int n = 0; n <= PolynomialBaseDegree; ++n) {

                // Ensure the H_n function is valid before calling
                if (!h_functions[n]) {
                        throw std::runtime_error("Invalid (null) H_n function at index " + std::to_string(n) + ".");
                }

                auxiliary_density_value += l_values[n] * h_functions[n](log_spot_price);
            
            }

            std::shared_ptr<IPayoff<R>> eq_payoff;

            if (this->payoff_->type() == traits::OptionType::Put) {
                eq_payoff = std::make_shared<EuropeanCallPayoff<R>>(this->payoff_->getStrike());
            } else {
                eq_payoff = this->payoff_->clone();
            }

            // Inside integrand
            return auxiliary_density_value * eq_payoff->evaluate_from_log(log_spot_price) * this->density_object_.pdf(log_spot_price);


        };

        
        // 5. Perform numerical integration using the member integrator_
        R expected_value_at_maturity = this->integrator_.integrate(
            full_integrand_function,
            mean - 12*stddev, // Assuming this is the lower bound
            mean + 12*stddev // Assuming this is the upper bound
        );

    
        // 6. Discount the expected value back to today
        R call_price = std::exp(-this->rate_ * this->ttm_) * expected_value_at_maturity;

        if (this->payoff_->type() == traits::OptionType::Put) {
            return call_price - std::exp(this->sde_model_->get_x0()) + std::exp(-this->rate_ * this->ttm_) * this->payoff_->getStrike();
        } else {
            return call_price;
        }

    }

private:
    unsigned int num_paths_;
    SolverType solver_type_;
    stats::MixtureDensity<PolynomialBaseDegree, DensityType, R> density_object_;
    quadrature::QuadratureRuleHolder<R> integrator_;


    /**
     * @brief Constructs the density object for the OPEOptionPricer.
     *
     * This method reads the quantization grid, solves for paths using the provided solver function,
     * and builds the mixture density object for polynomial expansion.
     * It computes the mean and variance of the paths and constructs the densities.
     *
     * @param ttm Time to maturity.
     * @param num_paths Number of paths for simulation.
     * @param poly_deg Degree of the polynomial basis.
     * @param solver_type Enum representing the solver type.
     * @param sde_model Shared pointer to the stochastic differential equation model.
     * @return A stats::MixtureDensity object containing the computed densities.
     * @throws std::runtime_error if the quantization grid cannot be read or if the solver function fails.
     *
     * This method is crucial for setting up the polynomial basis and densities used in the OPE method.
     */
    static stats::MixtureDensity<PolynomialBaseDegree, DensityType, R>
    make_density_object(R ttm,
                        unsigned int num_paths,
                        unsigned int poly_deg,
                        SolverType solver_type,
                        const std::shared_ptr<SDE::ISDEModel<R>>& sde_model)
    {
        // Read quantization grid
        QuantizationGrid<R> grid =
            readQuantizationGrid<R>(num_paths, poly_deg, "include/quantized_grids");

        // Double the coordinates for dw
        StoringMatrix dw(grid.coordinates.rows() * 2, grid.coordinates.cols()); 
        dw << grid.coordinates, grid.coordinates;

        StoringMatrix paths;

        // Solve for paths
        switch (solver_type) {
            case SolverType::EulerMaruyama:
                paths = SDE::EulerMaruyamaSolver<SDE::ISDEModel<R>, R>(*sde_model).solve(0.0, ttm, poly_deg, num_paths, std::optional<StoringMatrix>(dw));
                break;

            case SolverType::Milstein:
                paths = SDE::MilsteinSolver<SDE::ISDEModel<R>, R>(*sde_model)
                                .solve(0.0, ttm, poly_deg, num_paths, std::optional<StoringMatrix>(dw));
                break;
            
            case SolverType::IJK:
                paths = SDE::InterpolatedKahlJackelSolver<SDE::ISDEModel<R>, R>(*sde_model)
                                .solve(0.0, ttm, poly_deg, num_paths, std::optional<StoringMatrix>(dw));
                break;

            default:
                throw std::runtime_error("Unknown solver type");
        }

        // Map vol_view
        Eigen::Map<const StoringMatrix, 0, Eigen::OuterStride<>> vol_view(
            paths.data(),
            num_paths,
            paths.cols(),
            Eigen::OuterStride<>(2 * paths.outerStride())
        );
        
        auto* sde_model_ptr = dynamic_cast<SDE::GenericSVModelSDE<R>*>(sde_model.get());
        if  (!sde_model_ptr){ 
            throw std::runtime_error("The model is not a stochastic volatility model!");}
        StoringVector mean = sde_model_ptr->M_T(ttm, ttm / poly_deg, vol_view, grid.coordinates);
        StoringVector variance = sde_model_ptr->C_T(ttm, ttm / poly_deg, vol_view);
    




        // Build densities
        std::vector<DensityType> densities(mean.size());
        std::transform(std::execution::unseq,
                       mean.data(), mean.data() + mean.size(),
                       variance.data(),
                       densities.begin(),
                       [](R m, R v) {
                           return stats::make_normal_density<R>(m, std::sqrt(v));
                       });

        // Convert Eigen weights to std::vector
        std::vector<R> weights(grid.weights.data(),
                               grid.weights.data() + grid.weights.size());

        // Build and return MixtureDensity
        return stats::MixtureDensity<PolynomialBaseDegree, DensityType, R>(
            std::move(weights),
            std::move(densities)
        );
    }
};

} // namespace options

#endif // OPTION_PRICER_HPP
./include/options/FFTOptionPricer.hpp
/**
 * @file FFTOptionPricer.hpp
 * @brief Defines the FFTOptionPricer class for option pricing using the Fast Fourier Transform (FFT) method.
 *
 * This header provides the FFTOptionPricer class template, which implements option pricing via FFT,
 * leveraging the characteristic function of the underlying asset's SDE model. The class supports
 * flexible polynomial bases, configurable FFT grid parameters, and provides methods for pricing
 * and computing option Greeks (delta, gamma, vega, rho, theta) using bump-and-difference techniques.
 * 
 * Dependencies:
 * - Eigen library for matrix operations.
 * - BaseOptionPricer.hpp: Base class for option pricing.
 * - ISDEModel.hpp: Interface for stochastic differential equation models.
 * - FFTW.hpp: Utility for Fast Fourier Transform operations.
 * 
 */
#ifndef FFT_OPTION_PRICER_HPP
#define FFT_OPTION_PRICER_HPP

#include <cmath>
#include <unsupported/Eigen/Splines>
#include "BaseOptionPricer.hpp"
#include "../utils/FFTW.hpp"

namespace options
{
using Array = traits::DataType::StoringArray;
using ComplexArray = traits::DataType::ComplexArray;
using ComplexStoringVector = traits::DataType::ComplexStoringVector;

template <typename T, typename R>
concept GetterFunction = requires(T obj) {
    { obj() } -> std::convertible_to<R>;
};

template <typename T, typename R>
concept SetterFunction = requires(T obj, R value) {
    { obj(value) };
};

/**
 * @brief FFTOptionPricer class for pricing options using Fast Fourier Transform (FFT).
 *
 * This class implements the FFT method for option pricing, leveraging the characteristic function of the underlying asset.
 * It supports flexible polynomial bases and integrates the expected payoff using configurable quadrature rules.
 * @tparam R The floating-point type used for calculations (default: traits::DataType::PolynomialField).
 */
template <typename R = traits::DataType::PolynomialField>
class FFTOptionPricer : public BaseOptionPricer<R> {
    using Base = BaseOptionPricer<R>;

    public:
        /**
         * @brief Constructs an FFTOptionPricer instance.
         * @param ttm Time to maturity.
         * @param rate Risk-free interest rate.
         * @param payoff Payoff function for the option.
         * @param sde_model Shared pointer to the SDE model used for pricing.
         * @param Npow Power of 2 for the FFT grid size (default: 20).
         * @param A Scaling factor for the FFT grid (default: 1200).
         */
        FFTOptionPricer(R ttm, R rate, std::shared_ptr<IPayoff<R>> payoff, std::shared_ptr<SDE::ISDEModel<R>> sde_model, unsigned int Npow = 10, unsigned int A = 10)
        : Base(ttm, rate, std::move(payoff), std::move(sde_model)), Npow_(Npow), A_(A) {
            initialize_fft_grid();
        }
        
        /**
         * @brief Price the option using FFT.
         * This method computes the option price by evaluating the characteristic function of the underlying asset
         * and applying the FFT to obtain the expected payoff.
         * @return The computed option price.
         */
        R price() const override {
            update_characteristic_fn();
            return interpolate_price(this->payoff_->getStrike());
        }

        /**
         * @brief Computes the delta of the option using a bump-and-difference method.
         * This method perturbs the initial state of the SDE model and calculates the change in option price.
         * @return The computed delta value.
         */
        R delta() const  {
            return bump_and_diff(
                [this]() { return this->sde_model_->get_x0(); },
                [this](R v) { this->sde_model_->set_x0(v); },
                /* bump as log-spot */ true
            );
        }
        
        /**
         * @brief Computes the gamma of the option using a bump-and-difference method.
         * This method perturbs the initial state of the SDE model twice and calculates the second derivative of the option price.
         * @return The computed gamma value.
         */
        R gamma() const  {
            return bump_and_diff(
                [this]() { return this->sde_model_->get_x0(); },
                [this](R v) { this->sde_model_->set_x0(v); },
                true, true
            );
        }

        /**
         * @brief Computes the vega of the option using a bump-and-difference method.
         * This method perturbs the volatility parameter of the SDE model and calculates the change in option price.
         * @return The computed vega value.
         */
        R vega() const  {
            return bump_and_diff(
                [this]() { return this->sde_model_->get_v0(); },
                [this](R v) { this->sde_model_->set_v0(v); }
            );
        }

        /**
         * @brief Computes the rho of the option using a bump-and-difference method.
         * This method perturbs the risk-free interest rate and calculates the change in option price.
         * @return The computed rho value.
         */
        R rho() const  {
            return bump_and_diff(
                [this]() { return this->get_rate(); },
                [this](R v)  { 
                    const_cast<FFTOptionPricer*>(this)->set_rate(v); 
                }
            );
        }

        /**
         * @brief Computes the theta of the option using a bump-and-difference method.
         * This method perturbs the time to maturity and calculates the change in option price.
         * @return The computed theta value.
         */
        R theta() const {
            return -bump_and_diff(
                [this]() { return this->get_ttm(); },
                [this](R v) {
                    const_cast<FFTOptionPricer*>(this)->set_ttm(v);
                }
            );
}


    private:
        /**
         * @brief Initializes the FFT grid parameters.
         * This method sets up the grid size, eta, and lambda based on the provided Npow and A parameters.
         * It also initializes the complex vectors v_ and k_ used in the FFT computation.
         * 
         */
        void initialize_fft_grid() {
            N_ = std::pow(2, Npow_);
            eta_ = A_ / static_cast<R>(N_);
            lambda_ = 2 * M_PI / (N_ * eta_);

            v_ = Array::LinSpaced(N_, std::numeric_limits<R>::epsilon(), A_ * (N_ - 1) / N_ + eta_).template cast<std::complex<R>>();
            k_ = (-lambda_ * N_ / 2) + lambda_ * Array::LinSpaced(N_, 0, N_ - 1);
            w_ = Array::Ones(N_);   
            w_(0) = w_(N_ - 1) = R(0.5);
        }

        /**
         * @brief Updates the characteristic function and computes the spline for option pricing.
         * This method evaluates the characteristic function of the underlying asset using the SDE model,
         * computes the necessary terms for the FFT, and builds a spline for interpolating option prices.
         * It is called before pricing the option to ensure the characteristic function is up-to-date.
         */
        void update_characteristic_fn() const {
            ComplexStoringVector res(N_);
            this->sde_model_->characteristic_fn(this->ttm_, v_ - SDE::ImaginaryUnit<R>, res);

            auto exp_term = (SDE::ImaginaryUnit<R> * this->rate_ * v_ * this->ttm_).exp();
            ComplexArray numerator = res.array() - std::complex<R>(1.0, 0.0);
            ComplexArray denominator = SDE::ImaginaryUnit<R> * v_ * (v_ * SDE::ImaginaryUnit<R> + std::complex<R>(1.0, 0.0));
            ComplexArray Z_k = exp_term.array() * numerator.array() / denominator.array();



            ComplexArray lin = Array::LinSpaced(N_, 0, N_ - 1).template cast<std::complex<R>>();
            ComplexArray x = w_.template cast<std::complex<R>>() * std::complex<R>(eta_, 0) *
                            (SDE::ImaginaryUnit<R> * M_PI * lin).array().exp() * Z_k.array();

            auto fft_result = Utils::forwardFFT(x / M_PI);
            Array z_k = fft_result.real();


            R S0 = std::exp(this->sde_model_->get_x0());
            Array C = S0 * (z_k + (1.0 - (k_.array() - this->rate_ * this->ttm_).exp()).cwiseMax(0.0));
            strikes_ = S0 * k_.array().exp();


            // Build spline once per price computation
            spline_ = Eigen::SplineFitting<Eigen::Spline<R, 1>>::Interpolate(C.transpose(), 3, strikes_.transpose());
        }

        /**
         * @brief Interpolates the option price based on the computed spline and strike price.
         * This method evaluates the spline at the given strike price and adjusts the result based on the option type.
         * @param K The strike price at which to interpolate the option price.
         * @return The interpolated option price.
         */
        R interpolate_price(R K) const {
            R result = spline_(K)(0);
            if (this->payoff_->type() == traits::OptionType::Put)
                return result - std::exp(this->sde_model_->get_x0()) + K * std::exp(-this->rate_ * this->ttm_);
            return result;
        }

        
        using Getter = std::function<R()>;
        using Setter = std::function<void(R)>;
        /**
         * @brief Bump-and-difference method for computing derivatives.
         * This method perturbs a value using a getter and setter function, computes the option price,
         * and returns the derivative based on the specified bump size.
         * @param getter Function to retrieve the current value.
         * @param setter Function to set the perturbed value.
         * @param log_spot Whether to apply the bump as a log-spot perturbation (default: false).
         * @param second Whether to compute the second derivative (default: false).
         * @return The computed derivative value.
         */
        R bump_and_diff(Getter getter, Setter setter, bool log_spot = false, bool second = false) const
        requires GetterFunction<Getter, R> && SetterFunction<Setter, R>
        {
            R original = getter();
            R bump = log_spot ? bump_size_ / std::exp(original) : bump_size_;

            setter(original + bump);
            R plus = this->price();

            if (second) {
                setter(original - bump);
                R minus = this->price();
                setter(original); // restore
                R base = this->price();
                return (plus - 2 * base + minus) / (bump_size_ * bump_size_);
            } else {
                setter(original - bump);
                R minus = this->price();
                setter(original); // restore
                return (plus - minus) / (2 * bump_size_);
            }
        }

        static constexpr R bump_size_ = 1e-6;

        // FFT parameters
        unsigned int Npow_, A_;
        mutable unsigned int N_;
        mutable R eta_, lambda_;
        mutable Array k_, w_, strikes_;
        mutable ComplexArray v_;
        mutable Eigen::Spline<R, 1> spline_;


};

} // namespace options


#endif // FFT_OPTION_PRICER_HPP./include/options/CFOptionPricer.hpp
/**
 * @file CFOptionPricer.hpp
 * @brief Defines the CFOptionPricer class for closed-form (Black-Scholes) option pricing.
 *
 * This header provides the implementation of the CFOptionPricer class, which computes the price and Greeks
 * of European options using the Black-Scholes model. The class supports both call and put payoffs,
 * and requires the underlying SDE model to be a Geometric Brownian Motion (GBM).
 *
 * Key Features:
 * - Pricing of European call and put options using the Black-Scholes closed-form solution.
 * - Calculation of option Greeks: delta, gamma, vega, theta, and rho.
 * - Type-safe construction, ensuring only GBM models are accepted.
 * - Template parameter for floating-point precision.
 *
 * Dependencies:
 * - BaseOptionPricer: Abstract base class for option pricers.
 * - DensityBase: Provides normal density and cumulative distribution functions.
 *
 */
#ifndef CF_OPTION_PRICER_HPP
#define CF_OPTION_PRICER_HPP

#include <cmath>
#include "BaseOptionPricer.hpp"
#include "../stats/DensityBase.hpp"
namespace options {

using Array = traits::DataType::StoringArray;

/**
 * @brief CFOptionPricer class for pricing options using the Black-Scholes model.
 * This class implements the closed-form solution for European options under the Black-Scholes model.
 * It supports both call and put options and provides methods for computing option price and Greeks.
 *
 * @tparam R The floating-point type used for calculations (default: traits::DataType::PolynomialField).
 */
template <typename R = traits::DataType::PolynomialField>
class CFOptionPricer : public BaseOptionPricer<R> {
    using Base = BaseOptionPricer<R>;
    
public:
    /**
     * @brief Constructor for CFOptionPricer.
     * @param ttm Time to maturity in years.
     * @param rate Risk-free interest rate.
     * @param payoff Unique pointer to the option payoff object (Call or Put).
     * @param sde_model Shared pointer to the SDE model (should be GeometricBrownianMotionSDE).
     */
    CFOptionPricer(R ttm, R rate,
             std::shared_ptr<IPayoff<R>> payoff,
             std::shared_ptr<SDE::ISDEModel<R>> sde_model
             )
        : Base(ttm, rate, std::move(payoff), std::move(sde_model))
          
    {
        if (!std::dynamic_pointer_cast<SDE::GeometricBrownianMotionSDE<R>>(Base::sde_model_)) {
            throw std::logic_error("CFOptionPricer is only valid for the Black-Scholes (GBM) model.");
        }

        const R S0 = std::exp(this->sde_model_->m_x0(0));
        volatility_ = std::dynamic_pointer_cast<SDE::GeometricBrownianMotionSDE<R>>(Base::sde_model_)->get_v0();
        S0_ = S0;

        d1_ = (std::log(S0 / this->payoff_->getStrike()) + (Base::rate_ + 0.5 * volatility_ * volatility_) * Base::ttm_) /
              (volatility_ * std::sqrt(Base::ttm_));
        d2_ = d1_ - volatility_ * std::sqrt(Base::ttm_);
    }

    /**
     * @brief Prices the option using the Black-Scholes formula.
     * This method computes the option price based on the Black-Scholes closed-form solution.
     * It handles both call and put options based on the type of payoff provided.
     * @return The computed option price.
     */
    R price() const override {
        const R r = Base::rate_;
        const R T = Base::ttm_;
        const R S = S0_;

        if (dynamic_cast<const EuropeanCallPayoff<R>*>(Base::payoff_.get())) {
            return S * normal_.cdf(d1_) - this->payoff_->getStrike() * std::exp(-r * T) * normal_.cdf(d2_);
        } else if (dynamic_cast<const EuropeanPutPayoff<R>*>(Base::payoff_.get())) {
            return this->payoff_->getStrike() * std::exp(-r * T) * normal_.cdf(-d2_) - S * normal_.cdf(-d1_);
        } else {
            throw std::logic_error("Unsupported payoff type for CFOptionPricer.");
        }
    }

    /**
     * @brief Computes the delta of the option.
     * This method calculates the sensitivity of the option price to changes in the underlying asset price.
     * @return The computed delta value.
     */
    R delta() const {
        if (dynamic_cast<const EuropeanCallPayoff<R>*>(Base::payoff_.get())) {
            return normal_.cdf(d1_);
        } else if (dynamic_cast<const EuropeanPutPayoff<R>*>(Base::payoff_.get())) {
            return normal_.cdf(d1_) - R(1.0);
        } else {
            throw std::logic_error("Unsupported payoff type for delta.");
        }
    }

    /**
     * @brief Computes the gamma of the option.
     * This method calculates the sensitivity of the delta to changes in the underlying asset price.
     * @return The computed gamma value.
     */
    R gamma() const {
        return normal_.pdf(d1_) / (S0_ * volatility_ * std::sqrt(Base::ttm_));
    }

    /**
     * @brief Computes the vega of the option.
     * This method calculates the sensitivity of the option price to changes in volatility.
     * @return The computed vega value.
     */
    R vega() const {
        return S0_ * normal_.pdf(d1_) * std::sqrt(Base::ttm_);
    }

    /**
     * @brief Computes the theta of the option.
     * This method calculates the sensitivity of the option price to the passage of time.
     * @return The computed theta value.
     */
    R theta() const {
        const R K = Base::strike_;
        const R r = Base::rate_;
        const R T = Base::ttm_;
        const R S = S0_;

        R term1 = -S * normal_.pdf(d1_) * volatility_ / (2.0 * std::sqrt(T));

        if (dynamic_cast<const EuropeanCallPayoff<R>*>(Base::payoff_.get())) {
            R term2 = -r * K * std::exp(-r * T) * normal_.cdf(d2_);
            return  (term1 + term2);
        } else if (dynamic_cast<const EuropeanPutPayoff<R>*>(Base::payoff_.get())) {
            R term2 = r * K * std::exp(-r * T) * normal_.cdf(-d2_);
            return  (term1 + term2);
        } else {
            throw std::logic_error("Unsupported payoff type for theta.");
        }
    }

    /**
     * @brief Computes the rho of the option.
     * This method calculates the sensitivity of the option price to changes in the risk-free interest rate.
     * @return The computed rho value.
     */
    R rho() const {
        const R K = Base::strike_;
        const R r = Base::rate_;
        const R T = Base::ttm_;

        if (dynamic_cast<const EuropeanCallPayoff<R>*>(Base::payoff_.get())) {
            return K * T * std::exp(-r * T) * normal_.cdf(d2_);
        } else if (dynamic_cast<const EuropeanPutPayoff<R>*>(Base::payoff_.get())) {
            return -K * T * std::exp(-r * T) * normal_.cdf(-d2_);
        } else {
            throw std::logic_error("Unsupported payoff type for rho.");
        }
    }

private:
    R volatility_;
    R d1_, d2_;
    R S0_;
    static inline auto normal_ = stats::make_normal_density<R>(0.0, 1.0);
};

} // namespace options

#endif // CF_OPTION_PRICER_HPP./include/sde/FinModels.hpp
/**
 * @file FinModels.hpp
 * @brief Stochastic Differential Equation (SDE) models for financial applications.
 *
 * This header defines a set of classes and interfaces for modeling various stochastic processes
 * commonly used in mathematical finance, such as Geometric Brownian Motion, Heston, Stein-Stein,
 * Hull-White, and Jacobi models. These models are implemented as SDEs and provide interfaces for
 * drift, diffusion, and their derivatives, as well as characteristic functions and generator matrices.
 *
 * Main Components:
 * - ISDEModel: Abstract base class for SDE models, defining the interface for drift, diffusion,
 *   their derivatives, characteristic functions, and initial state management.
 * - GeometricBrownianMotionSDE: Implements the classic GBM model for asset prices.
 * - GenericSVModelSDE: Generic stochastic volatility model supporting flexible exponents for volatility.
 * - HestonModelSDE: Specialization of GenericSVModelSDE for the Heston model (square-root volatility).
 * - SteinSteinModelSDE: Specialization for the Stein-Stein model (OU volatility).
 * - HullWhiteModelSDE: Specialization for the Hull-White model (linear volatility).
 * - JacobiModelSDE: Specialization for the Jacobi model, with bounded variance process.
 *
 * Features:
 * - Support for both real and complex-valued state vectors and matrices.
 * - Calculation of drift, diffusion, and their derivatives for use in numerical schemes.
 * - Characteristic function computation for Fourier-based pricing methods.
 * - Construction of generator matrices for polynomial expansion methods.
 * - Parameter validation and error handling for model consistency.
 *
 * Template Parameter:
 * - T: Numeric type (default: traits::DataType::PolynomialField), allowing for flexibility in precision.
 *
 * Usage:
 * - Instantiate a model class with appropriate parameters and initial state.
 * - Use the drift and diffusion methods for simulation or numerical solution of SDEs.
 * - Use the characteristic function for pricing or calibration tasks.
 * - Use generator_G for polynomial expansion or spectral methods.
 *
 * Dependencies:
 * - SDE.hpp: Base definitions for SDE vectors and matrices.
 *
 */
#ifndef FINMODELS_HPP
#define FINMODELS_HPP

#include "SDE.hpp"
#include <stdexcept>    // For std::invalid_argument, std::runtime_error
#include <iostream>     // For std::cerr
#include <complex>
#include <memory>
namespace SDE{

template <typename T = traits::DataType::PolynomialField>
constexpr std::complex<T> ImaginaryUnit{T(0), T(1)};

using SDEVector = SDE::SDEVector; 
using SDEComplexVector = SDE::SDEComplexVector; 
using SDEMatrix = SDE::SDEMatrix; 


static constexpr long key(int m, int n) noexcept {
        return (static_cast<long>(m) << 32) | static_cast<unsigned int>(n);
    }

/**
 * @brief Base interface for all SDE models.
 * @tparam T Numeric type for computations (default: traits::DataType::PolynomialField).
 */
template<typename T = traits::DataType::PolynomialField>
class ISDEModel {



public: 
        /**
         * @brief Returns the dimension of the state vector.
         * @return The number of state variables in the SDE model.
         *
         * This method provides the size of the state vector, which is essential for defining the model's structure.
         */
        virtual unsigned int state_dim() const = 0;

        /**
         * @brief Returns the dimension of the Wiener process.
         * @return The number of independent Wiener processes in the SDE model.
         *
         * This method provides the size of the Wiener process vector, which is essential for stochastic simulations.
         */
        virtual unsigned int wiener_dim() const = 0;
        /**
         * @brief Virtual destructor for proper cleanup in derived classes.
         */
        virtual ~ISDEModel() = default; 
        
        /**
         * @brief Clones the SDE model.
         * @return A shared pointer to a new instance of the SDE model.
         *
         * This method allows for polymorphic copying of the model, ensuring that derived classes can be copied correctly.
         */
        virtual std::shared_ptr<ISDEModel<T>> clone() const = 0;
        
        /**
         * @brief Computes the drift term of the SDE.
         * @param t Current time.
         * @param x Current state vector.
         * @param mu_out Output vector for the drift term.
         */
        virtual void drift(T t, const SDEVector& x, SDEVector& mu_out) const = 0;
        

        /**
         * @brief Computes the diffusion term of the SDE.
         * @param t Current time.
         * @param x Current state vector.
         * @param sigma_out Output matrix for the diffusion term.
         *
         * The diffusion term is typically a matrix that scales the Wiener increments.
         */
        virtual void diffusion(T t, const SDEVector& x, SDEMatrix& sigma_out) const = 0;

        // Essential for some numerical schemes (e.g., Milstein)
        // These could be optional or provide default (e.g., zero) implementations if not always needed
        // Or, better, have specialized interfaces for models that support these

        /**
         * @brief Computes the derivative of the drift term with respect to the state vector.
         * @param t Current time.
         * @param x Current state vector.
         * @param deriv_out Output vector for the drift derivative.
         *
         * This method is used in higher-order numerical schemes that require knowledge of how the drift changes with respect to the state.
         */
        virtual void drift_derivative_x([[maybe_unused]] T t, [[maybe_unused]] const SDEVector& x, [[maybe_unused]] SDEVector& deriv_out) const {
            // Default implementation: numerical differentiation or throw not_implemented
            throw std::logic_error("Drift derivative not implemented for this model.");
        }
        /**
         * @brief Computes the derivative of the diffusion term with respect to the state vector.
         * @param t Current time.
         * @param x Current state vector.
         * @param deriv_out Output matrix for the diffusion derivative.
         *
         * This method is used in higher-order numerical schemes that require knowledge of how the diffusion changes with respect to the state.
         */
        virtual void diffusion_derivative_x([[maybe_unused]] T t, [[maybe_unused]] const SDEVector& x, [[maybe_unused]] SDEMatrix& deriv_out) const {

            throw std::logic_error("Diffusion derivative not implemented for this model.");

        }

        /**
         * @brief Computes the second derivative of the diffusion term with respect to the state vector.
         * @param t Current time.
         * @param x Current state vector.
         * @param deriv_out Output matrix for the second diffusion derivative.
         *
         * This method is used in advanced numerical schemes that require knowledge of how the diffusion changes with respect to the state.
         */
        virtual void diffusion_second_derivative_x([[maybe_unused]] T t, [[maybe_unused]] const SDEVector& x, [[maybe_unused]] SDEMatrix& deriv_out) const {

            throw std::logic_error("Diffusion derivative not implemented for this model.");

        }

        /**
         * @brief Computes the characteristic function of the SDE.
         * @param t Time parameter for the characteristic function.
         * @param x Input vector for the characteristic function.
         * @param charact_out Output vector for the characteristic function.
         *
         * The characteristic function is used in Fourier-based method.
         */
        virtual void characteristic_fn([[maybe_unused]] T t,  [[maybe_unused]] const SDEComplexVector& x, [[maybe_unused]] SDEComplexVector& charact_out) const {

            // Default implementation: throw not_implemented
            throw std::logic_error("Characteristic function not implemented for this model.");

        }

        /**
         * @brief Gets the initial state vector of the SDE.
         * @return The initial state vector.
         *
         * This method provides access to the initial state, which can be used in characteristic functions or other calculations.
         */
        virtual T get_x0() const {

            // Default implementation: throw not_implemented
            throw std::logic_error("Bump volatility not implemented for this model.");

        }

        /**
         * @brief Sets the initial state vector of the SDE.
         * @param x0 The new initial state vector.
         *
         * This method allows setting the initial state, which can be useful for simulations or recalibrations.
         */
        virtual void set_x0([[maybe_unused]] const T& x0) {

            // Default implementation: throw not_implemented
            throw std::logic_error("Set x0 not implemented for this model.");

        }

        /**
         * @brief Gets the initial volatility (v0) of the SDE.
         * @return The initial volatility.
         *
         * This method provides access to the initial volatility, which can be used in characteristic functions or other calculations.
         */
        virtual T get_v0() const {

            // Default implementation: throw not_implemented
            throw std::logic_error("Bump volatility not implemented for this model.");

        }


        /**
         * @brief Sets the initial volatility (v0) of the SDE.
         * @param v0 The new initial volatility.
         *
         * This method allows setting the initial volatility, which can be useful for simulations or recalibrations.
         */
        virtual void set_v0([[maybe_unused]] const T& v0) {

            // Default implementation: throw not_implemented
            throw std::logic_error("Set v0 not implemented for this model.");

        }

        /**
         * @brief Gets the Wiener dimension of the SDE.
         * @return The Wiener dimension.
         *
         * This method provides the number of independent Wiener processes driving the SDE.
         */
        virtual unsigned int get_wiener_dimension() const = 0;

        /**
         * @brief Gets the state dimension of the SDE.
         * @return The state dimension.
         *
         * This method provides the number of state variables in the SDE model.
         */
        virtual unsigned int get_state_dim() const = 0;

        SDEVector m_x0; // Initial state vector, can be used in characteristic functions or other calculations

};

/**
 * @brief Geometric Brownian Motion SDE model.
 * @tparam T Numeric type for computations (default: traits::DataType::PolynomialField).
 *
 * This model represents the classic Geometric Brownian Motion, commonly used for modeling stock prices.
 * It includes methods for drift, diffusion, and characteristic function calculations.
 */
template<typename T = traits::DataType::PolynomialField>
class GeometricBrownianMotionSDE : public ISDEModel<T> {

public:

    static constexpr unsigned int WIENER_DIM = 1;
    static constexpr unsigned int STATE_DIM = 1; 

    unsigned int state_dim() const override { return STATE_DIM; }
    unsigned int wiener_dim() const override { return WIENER_DIM;} 

    /** * @brief Parameters for the Geometric Brownian Motion SDE.
     * Contains the drift (mu) and volatility (sigma) parameters.
     */
    struct Parameters {
        T mu; // X is log-price ln(S), mu is (r - 0.5*sigma^2)
        T sigma; // Volatility
    };

private:

    Parameters params_;

public:
    
    /**
     * @brief Geometric Brownian Motion SDE constructor.
     * @param mu Drift parameter (expected return rate).
     * @param sigma Volatility parameter (standard deviation of returns).
     * @param x0 Initial state (log-price).
     * @throws std::invalid_argument if sigma is negative.
     */
    GeometricBrownianMotionSDE(T mu, T sigma, T x0) : params_(Parameters{mu, sigma}) {
        this->m_x0 = SDEVector::Constant(STATE_DIM, x0);

        if (this->get_v0() < 0.0) {
            throw std::invalid_argument("Volatility cannot be negative.");
        }

    }

    std::shared_ptr<ISDEModel<T>> clone() const override {
        return std::make_shared<GeometricBrownianMotionSDE<T>>(*this);
    }

    unsigned int get_wiener_dimension() const override { return WIENER_DIM; }

    unsigned int get_state_dim() const override { return STATE_DIM;}

    inline void drift([[maybe_unused]] T t, [[maybe_unused]] const SDEVector& x, SDEVector& mu_out) const override {

        // Drift of X_t is mu
        mu_out = (this->get_mu() - this->get_v0() * this->get_v0() * static_cast<T>(0.5)) * SDEVector::Ones(STATE_DIM);

    }

    inline void diffusion([[maybe_unused]] T t, [[maybe_unused]] const SDEVector& x, SDEMatrix& sigma_out) const override {

        // Diffusion of X_t is sigma
        sigma_out = this->get_v0() * SDEMatrix::Identity(STATE_DIM, WIENER_DIM);

    }

    inline void drift_derivative_x([[maybe_unused]] T t, [[maybe_unused]] const SDEVector& x, SDEVector& deriv_out) const override {
        deriv_out.setZero();
    }
 
    inline void diffusion_derivative_x([[maybe_unused]] T t, [[maybe_unused]] const SDEVector& x, SDEMatrix& deriv_out) const override {    
        deriv_out.setZero();  
    }

    inline void diffusion_second_derivative_x([[maybe_unused]] T t, [[maybe_unused]] const SDEVector& x, SDEMatrix& deriv_out) const override {
        // For GBM, the second derivative of diffusion is zero
        deriv_out.setZero();

    }

    inline void characteristic_fn(T t, const SDEComplexVector& x, SDEComplexVector& charact_out) const override{
        // Verificare se post x. array in parentesi vada mu. DEVO VEDERE OVUNQUE
        charact_out = t * ( (-this->get_v0() * this->get_v0() * x.array().square()) * static_cast<T>(0.5) + ImaginaryUnit<> * x.array() * ( - this->get_v0() * this->get_v0() * static_cast<T>(0.5)));

        charact_out = charact_out.array().exp();
    }

    inline T get_x0() const override {
        // Return the initial state vector
        return this->m_x0(0);
    }

    inline void set_x0(const T& x0) override {
        // Set the initial state vector
        this->m_x0 = SDEVector::Constant(STATE_DIM, x0);
    }

    inline T get_v0() const noexcept override{
        return this->params_.sigma; // Return the initial variance (x(1))
    }

    inline void set_v0(const T& v0) noexcept override{
        this->params_.sigma = v0; // Set the initial variance (x(1))
    }

    inline T get_mu() const noexcept {
        return this->params_.mu; // Return the drift parameter (mu)
    }

};


/**
 * @brief Generic Stochastic Volatility SDE model.
 * @tparam T Numeric type for computations (default: traits::DataType::PolynomialField).
 * This model supports flexible exponents for volatility and allows for correlation between the asset and volatility processes.
 *
 * As defined in Fast strong approximation Monte-Carlo schemes for stochastic volatility models
 * The model is the following:
 * dS(t) = mu*S(t)*dt + V(t)^p * S(t) * dW(t)
 * dV(t) = kappa * (theta - V(t)) * dt + sigma * V(t)^q * dZ(t)
 * We employ Cholesky decomposition to handle the correlation between the two Wiener processes:
 * dW = rho * dZ_uncorr + sqrt(1 - rho^2) * dW_uncorr
 * dZ = dZ_uncorr
 * So that, we get the following system of SDEs:
 * dS(t) = mu*S(t)*dt + V(t)^p * S(t) * (rho*dZ_uncorr + sqrt(1 - rho^2)*dW_uncorr)
 * dV(t) = kappa * (theta - V(t)) * dt + sigma * V(t)^q * dZ_uncorr
 * where dZ_uncorr and dW_uncorr are two independent Wiener motions.
 * Applying the Ito's lemma, we can derive the drift and diffusion terms for the SDEs.
 * dX(t) (mu - V(t)^2p/2) * dt + V(t)^p * (rho*dZ_uncorr + sqrt(1 - rho^2)*dW_uncorr
 * dY(t) = kappa * (theta - Y(t)) * dt + sigma * Y(t)^q * dZ_uncorr
*/
template<typename T = traits::DataType::PolynomialField>
class GenericSVModelSDE : public ISDEModel<T> {
        using Base = ISDEModel<T>;

public:

    static constexpr unsigned int WIENER_DIM = 2; // Two correlated Wiener processes
    static constexpr unsigned int STATE_DIM = 2; // Two state variables (log-price and variance)

    unsigned int state_dim() const override { return STATE_DIM; }
    unsigned int wiener_dim() const override { return WIENER_DIM;} 
    /**
     * @brief Parameters for the Generic Stochastic Volatility SDE.
     * Contains the drift (asset_drift_const), mean-reversion speed (sv_kappa), long-term mean (sv_theta),
     * volatility of the stochastic factor (sv_sigma), correlation (rho), and exponents for asset and volatility processes.
     * asset_vol_exponent and sv_vol_exponent are used to define the power of the stochastic volatility factor in the diffusion terms.
     * asset_vol_exponent is the exponent for the asset volatility term (p in the model).
     * sv_vol_exponent is the exponent for the stochastic volatility term (q in the model).
     */
    struct Parameters {
        T asset_drift_const; // e.g., r if x(1) is log-price
        T sv_kappa;          // mean-reversion speed for x(0)
        T sv_theta;          // long-term mean for x(0)
        T sv_sigma;          // volatility of x(0)
        T correlation;       // rho
        T asset_vol_exponent; // asset vol ~ x(0)^p
        T sv_vol_exponent;    //  sv vol ~ x(0)^q
    };

protected:

    Parameters params_;

public:

    GenericSVModelSDE(const Parameters& params, const SDEVector x0) : params_(params) {

        this->m_x0 = x0;

        // Parameter validation

        if (this->get_theta() <= 0.0) {
             throw std::invalid_argument("Long-term variance theta must be positive.");
        }

        if (this->get_kappa() < 0.0) { 
            // Usually kappa > 0 for mean reversion.
            std::cerr << "Warning: Mean-reversion kappa is negative or zero.\n";

        }

        if (this->get_correlation() < -1.0 || this->get_correlation() > 1.0) {
            throw std::invalid_argument("Correlation rho must be between -1 and 1.");
        }

        if (this->get_sigma_v() <= 0.0 && this->get_q() > 0) { 
             throw std::invalid_argument("Volatility of stochastic factor (sv_sigma) must be positive if it has an impact.");
        }

         // Feller condition check

        if (this->get_q() == 0.5 && this->get_kappa() > 0 && this->get_theta() > 0) { 
            if (2.0 * this->get_kappa() * this->get_theta() < this->get_sigma_v() * this->get_sigma_v()) {
                std::cerr << "Warning: Feller condition (2*kappa*theta >= sigma_v^2) may not be satisfied; x(0) might become negative if it represents variance.\n";
            }
        }
    }

    unsigned int get_wiener_dimension() const override { return WIENER_DIM; }
    
    unsigned int get_state_dim() const override { return STATE_DIM;}

    inline void drift([[maybe_unused]] T t, const SDEVector& x, SDEVector& mu_out) const override 
    {
        T asset_vol_term_squared;

        if (this->get_p() == static_cast<T>(0.5)) {

            asset_vol_term_squared = x(0);

        } else if (this->get_p() == static_cast<T>(1.0)) {

            asset_vol_term_squared = x(0) * x(0);

        } else {

            // General case: std::pow(x(1), 2.0 * this->get_p())
            asset_vol_term_squared = std::pow(x(0), static_cast<T>(2.0) * this->get_p());

        }

        // Drift for x(0): the stochastic volatility factor (e.g. CIR process or OU)
        mu_out(0) = this->get_kappa() * (this->get_theta() - x(0));

        // Drift for x(1): log-price
        mu_out(1) = this->get_drift() - static_cast<T>(0.5) * asset_vol_term_squared;

    }

    inline void diffusion([[maybe_unused]] T t, const SDEVector& x, SDEMatrix& sigma_out) const override {

        const T sv_factor = x(0); // The stochastic volatility factor

        // Calculate factor_p = sv_factor^p
        T factor_p;
        if (this->get_p() == static_cast<T>(0.5)) {
            factor_p = std::sqrt(sv_factor);
        } 
        else if (this->get_p() == static_cast<T>(1.0)) {
            factor_p = sv_factor;
        } 
        else {
            factor_p = std::pow(sv_factor, this->get_p());
        }

        // Calculate factor_q = sv_factor^q
        T factor_q;

        if (this->get_q() == static_cast<T>(0.0)) {
            factor_q = static_cast<T>(1.0); // For q=0, x^0 = 1
        } 
        else if (this->get_q() == static_cast<T>(0.5)) {
            factor_q = std::sqrt(sv_factor);
        }
        else if (this->get_q() == static_cast<T>(1.0)) {
            factor_q = sv_factor;
        } 
        else {
            factor_q = std::pow(sv_factor, this->get_q());
        } 


        // Row 0: volatility diffusion components
        sigma_out(0, 1) = 0.0;                 // Component for dW_uncorr
        sigma_out(0, 0) = this->get_sigma_v() * factor_q; // Component for dZ

        // Row 1: Log Price diffusion components
        sigma_out(1, 1) = std::sqrt(1 - this->get_correlation()*this->get_correlation()) * factor_p ; // Corresponds to dW_uncorr
        sigma_out(1, 0) = this->get_correlation() * factor_p;      // Corresponds to dZ_uncorr


    }
    
    inline void drift_derivative_x([[maybe_unused]] T t, [[maybe_unused]] const SDEVector& x, SDEVector& deriv_out) const override {
        // Derivative of drift w.r.t. x(0) and x(1)
        deriv_out(0) = this->get_kappa(); // Derivative of drift w.r.t. x(0)
        deriv_out(1) = 0.0;
        }
    
    inline void diffusion_derivative_x([[maybe_unused]] T t, [[maybe_unused]] const SDEVector& x, SDEMatrix& deriv_out) const override {



        deriv_out.setZero();

    }

    inline void diffusion_second_derivative_x([[maybe_unused]] T t, [[maybe_unused]] const SDEVector& x, SDEMatrix& deriv_out) const override {
        // For GenericSVModel, the second derivative of diffusion is zero
        deriv_out.setZero();
      
    }

    /**
     * @brief Struct to hold polynomial coefficients for the stochastic volatility model.
     * This struct contains the coefficients for the polynomial representation of the drift and diffusion terms.
     * It is used to build the generator matrix for polynomial expansion methods.
     *
     * The coefficients are stored as vectors, where each vector corresponds to a polynomial term:
     * - bx: Coefficients for b_x(v)
     * - axx: Coefficients for a_xx(v)
     * - bv: Coefficients for b_v(v)
     * - axv: Coefficients for a_xv(v)
     * - avv: Coefficients for a_vv(v)
     *
     * The coefficients are indexed by the polynomial degree, allowing for efficient polynomial evaluation.
     * This struct is essential for constructing the generator matrix and performing polynomial expansions in the SDE model.
     */
    struct SVPolyCoeffs {
        SDEVector bx;   // b_x(v)
        SDEVector axx;  // a_xx(v)
        SDEVector bv;   // b_v(v)
        SDEVector axv;  // a_xv(v)
        SDEVector avv;  // a_vv(v)
    };


    /**
     * @brief Builds the polynomial coefficients for the stochastic volatility model.
     * @param N Number of polynomial coefficients to compute.
     * @return SVPolyCoeffs containing the polynomial coefficients for the drift and diffusion terms.
     */
    virtual SVPolyCoeffs build_sv_polynomials(
        int N
    ) {
        SVPolyCoeffs out;

        // b_x(v) = μ - 0.5 v^(2p)
        out.bx = SDEVector::Zero(N);
        out.bx[0] = this->get_drift();
        {
            int exp = static_cast<int>(2 * this->get_p());
            if (exp < N)
                out.bx[exp] = out.bx[exp] - T(0.5);
        }

        // a_xx(v) = v^(2p)
        out.axx = SDEVector::Zero(N);
        {
            int exp = static_cast<int>(2 * this->get_p());
            if (exp < N)
                out.axx[exp] = T(1.0);
        }

        // b_v(v) = κ θ - κ v
        out.bv = SDEVector::Zero(N);
        out.bv[0] = this->get_kappa() * this->get_theta();
        if (1 < N)
            out.bv[1] = -this->get_kappa();

        // a_xv(v) = ρ σ v^(p+q)
        out.axv = SDEVector::Zero(N);
        {
            int exp = static_cast<int>(this->get_p() + this->get_q());
            if (exp < N)
                out.axv[exp] = this->get_correlation() * this->get_sigma_v();
        }

        // a_vv(v) = σ² v^(2q)
        out.avv = SDEVector::Zero(N);
        {
            int exp = static_cast<int>(2 * this->get_q());
            if (exp < N)
                out.avv[exp] = this->get_sigma_v() * this->get_sigma_v();
        }

        return out;
    }



    /**
     * @brief Constructs the generator matrix G for the stochastic volatility model.
     * @param E Vector of pairs representing the indices of the basis functions.
     * @param N Number of basis functions.
     * @param sigma Volatility parameter.
     * @return The generator matrix G as an SDEMatrix.
     *
     * This method constructs the generator matrix G based on the polynomial coefficients derived from the stochastic volatility model.
     * The matrix is built using the coefficients for the drift and diffusion terms, and it is projected to a triangular form based on the basis functions defined in E.
     * The resulting matrix G is used in polynomial expansion methods for solving the SDE. This version of the method uses an approximation when it comes to mixture models, since
     * the sigma parameter provided is approximated through moment matching and is not the actual volatility of the process.
     */
    virtual SDEMatrix generator_G(std::vector<std::pair<int,int>> E, int N, T sigma) const {

        const int M = static_cast<int>(E.size());

        // Fast index lookup
        Utils::IndexMap idx;
        idx.reserve(M);
        for (int i = 0; i < M; ++i) {
            const auto& [m, n] = E[i];
            idx.emplace(key(m, n), i);
        }

        SDEMatrix G = SDEMatrix::Zero(M, M);

        const auto q = this->get_q();
        const auto p = this->get_p();
        const auto kappa = this->get_kappa();
        const auto theta = this->get_theta();
        const auto rho = this->get_correlation();
        const auto r = this->get_drift();
        const auto sigma_v = this->get_sigma_v();

        auto add_entry = [&](int row_m, int row_n, int col, T value) {
            if (row_m < 0 || row_n < 0) return;
            if (row_m + row_n > N) return; // out of basis range
            auto it = idx.find(key(row_m, row_n));
            if (it != idx.end()) {
                G(it->second, col) += value; // Since p and q are dynamic, the same cell may be called multiple times, so we must add to the existing value
            }
        };

        for (int col = 0; col < M; ++col) {
            const auto [m, n] = E[col];

            // 1) h_{m-2+2q, n}
            if (m >= 2 - 2 * q) {

                add_entry(m-2 + 2 * q, n, col, sigma_v * sigma_v * 0.5 * m * (m - 1));
            }
            // 2) h_{m-1+p+q, n-1}
            if (m >= 1 - p - q && n >= 1) {
            
                add_entry(m - 1 + p + q, n-1, col, rho * sigma_v * m * std::sqrt((T)n) / sigma);
            }
            // 3) h_{m-1, n}
            if (m >= 1) {
                
                add_entry(m - 1, n, col, m * kappa * theta);
            }
            // 4) h_{m, n-1}
            if (n >= 1) {
                
                add_entry(m, n-1, col, std::sqrt((T)n) / sigma * r);
            }
            // 5) h_{m+2p, n-2}
            if (n >= 2) {
                
                add_entry(m + 2 * p, n-2, col, std ::sqrt((T)n * (n - 1)) / (2.0 * sigma * sigma));
            }
            // 6) h_{m, n}
            add_entry(m, n, col, -m * kappa);

            // 7) h_{m+2p, n-1}
            if (n >= 1) {
                
                add_entry(m + 2 * p, n-1, col, -0.5 * std::sqrt((T)n) / sigma);
            }
        }

        return G;

    }; 

    /**
     * @brief Constructs the generator matrix G for the stochastic volatility model.
     * @param E Vector of pairs representing the indices of the basis functions.
     * @param H The SDEMatrix representing the current state of the model.
     * @return The generator matrix G as an SDEMatrix.
     * 
     * This method constructs the generator matrix G based on the polynomial coefficients derived from the stochastic volatility model.
     * The matrix is built using the coefficients for the drift and diffusion terms, and it is projected to a triangular form based on the basis functions defined in E.
     * The resulting matrix G is used in polynomial expansion methods for solving the SDE.
     * This version of the method uses Kronecker products to build the generator matrix G based on the provided basis H, which can be also a mixture.
     */
    SDEMatrix generator_G(std::vector<std::pair<int,int>> E, const SDEMatrix& H){

        auto const N = static_cast<int>(H.rows());

        auto coeffs = build_sv_polynomials(N);

        auto G = Utils::build_G_full(H, coeffs.bx, coeffs.axx, coeffs.bv, coeffs.axv, coeffs.avv, N);

        auto G_projected = Utils::project_to_triangular(G, E, N);

        return G_projected;

    }


    inline T get_x0() const noexcept override  {
        // Return the initial state vector
        return this->m_x0(1);
    }

    inline void set_x0(const T& x0) noexcept override  {
        // Set the initial state vector
        this->m_x0(1) = x0;
    }

    inline T get_v0() const noexcept override{
        return this->m_x0(0); // Return the initial variance (x(1))
    }

    inline void set_v0(const T& v0) noexcept override{
        this->m_x0(0) = v0; // Set the initial variance (x(1))
    }

    /**
     * @brief Getters for model parameters.
     * These methods provide access to the model parameters used in the SDE.
     * They are useful for retrieving specific parameters without exposing the entire Parameters struct.
     */
    inline T get_p() const noexcept {
        return params_.asset_vol_exponent; // p in the model
    }

    inline T get_q() const noexcept {
        return params_.sv_vol_exponent; // q in the model
    }

    inline T get_correlation() const noexcept {
        return params_.correlation; // Correlation between the two Wiener processes
    }

    inline T get_kappa() const noexcept {
        return params_.sv_kappa; // Mean reversion speed for the variance process
    }

    inline T get_theta() const noexcept {
        return params_.sv_theta; // Long-term mean for the variance process
    }

    inline T get_sigma_v() const noexcept {
        return params_.sv_sigma; // Volatility of the variance process
    }

    inline T get_drift() const noexcept {
        return params_.asset_drift_const; // Constant drift term of log-price
    }


    /**
     * @brief Computes the Mean of the SDE at time T by employing an IJK scheme combined with weighted Monte Carlo integration.
     * @param ttm Time to maturity.
     * @param dt Time step size.
     * @param y_t Current state of the SDE (matrix form).
     * @param w_t Wiener increments (matrix form).
     * @return The mean of the SDE at time T as an SDEVector.
     *  
     * This method computes the mean of the SDE at time T using a combination of trapezoidal rule for integration and stochastic integral for the Wiener increments.
     * It handles the correlation between the asset and volatility processes and applies the appropriate transformations based on the model parameters.
     * The method assumes that y_t and w_t are matrices with compatible dimensions.
     * 
     */
    inline SDEVector M_T(T ttm, T dt, const SDEMatrix& y_t, const SDEMatrix& w_t) {
        const auto n = y_t.cols();
        const auto k = y_t.rows();

        // Quick sanity check
        assert(w_t.cols() == n - 1 && w_t.rows() == k && "y_t and w_t must have the same number of rows and w_t must have one less column than y_t");

        // Precompute .matrix() view once
        const auto& y_mat = y_t.matrix();
        const auto& w_mat = w_t.matrix();

        // Precompute powers
        auto y_t_asset = y_mat.array().pow(this->get_p()).matrix();
        auto y_t_vol   = y_mat.array().pow(this->get_q()).matrix();

        // 1. Trapezoidal rule
        auto trap_block1 = y_t_asset.array().square().block(0, 0, k, n - 1);
        auto trap_block2 = y_t_asset.array().square().block(0, 1, k, n - 1);
        auto trap = -static_cast<T>(0.5) * dt * (trap_block1 + trap_block2).rowwise().sum();

        // 2. Vanilla stochastic integral
        auto stoch = this->get_correlation() * y_t_asset.block(0, 1, k, n - 1).cwiseProduct(w_t).rowwise().sum();

        // 3. IJK term
        auto w_sq_minus_dt = w_mat.array().square() - dt;
        auto ijk = this->get_correlation() * static_cast<T>(0.5) * this->get_sigma_v()
                * y_t_vol.block(0, 1, k, n - 1).cwiseProduct(w_sq_minus_dt.matrix()).rowwise().sum();


        // Final result
        auto result = get_x0()
                    + this->get_drift() * ttm
                    + trap.array() + stoch.array() + ijk.array();

        return result;
    };

    /**
     * @brief Computes the C_T term for the SDE at time T.
     * @param ttm Time to maturity.
     * @param dt Time step size.
     * @param y_t Current state of the SDE (matrix form).
     * @return The C_T term as an SDEVector.
     * This method computes the C_T term for the SDE at time T using the trapezoidal rule.
     * It handles the correlation between the asset and volatility processes and applies the appropriate transformations based on the model parameters.
     * The method assumes that y_t is a matrix with compatible dimensions.
     */
    inline SDEVector C_T([[maybe_unused]] T ttm, T dt, const SDEMatrix& y_t) {
        const auto n = y_t.cols();
        const auto k = y_t.rows();


        // Precompute .matrix() view once
        const auto& y_mat = y_t.matrix();

        // Precompute powers
        auto y_t_asset = y_mat.array().pow(2 * this->get_p()).matrix();

        // 1. Trapezoidal rule
        auto trap_block1 = y_t_asset.block(0, 0, k, n - 1);
        auto trap_block2 = y_t_asset.block(0, 1, k, n - 1);
        auto trap = static_cast<T>(0.5) * dt * (trap_block1 + trap_block2).rowwise().sum();

        // Final result
        auto result = (1 - this->get_correlation()*this->get_correlation()) * trap.array();

        return result;
    };

};

/**
 * @brief Heston Model SDE implementation.
 * @tparam T Numeric type for computations (default: traits::DataType::PolynomialField).
 */
template<typename T = traits::DataType::PolynomialField>
class HestonModelSDE : public GenericSVModelSDE<T> {
public:
    using Base = GenericSVModelSDE<T>;
    using Parameters = typename Base::Parameters;

    HestonModelSDE(T asset_drift_const,
                   T sv_kappa,
                   T sv_theta,
                   T sv_sigma,
                   T correlation,
                   SDEVector x0)
        : Base(Parameters{
            asset_drift_const,
            sv_kappa,
            sv_theta,
            sv_sigma,
            correlation,
            static_cast<T>(0.5), // asset_vol_exponent p
            static_cast<T>(0.5)  // sv_vol_exponent q
        }, x0) {}

    std::shared_ptr<ISDEModel<T>> clone() const override {
        return std::make_shared<HestonModelSDE<T>>(*this);
    }


    inline void characteristic_fn(T t, const SDEComplexVector& x, SDEComplexVector& charact_out) const override{

            // Step 1: gamma
        SDEComplexVector d = ((this->get_kappa() - ImaginaryUnit<> * this->get_correlation() * this->get_sigma_v() * x.array()).square()
                            + this->get_sigma_v() * this->get_sigma_v() * (x.array() * (x.array() + ImaginaryUnit<>))).matrix();
        SDEComplexVector gamma = d.array().sqrt().matrix();

                // Step 2: A (exp1 + exp2)

        SDEComplexVector exp1 = gamma.array() + this->get_kappa() - ImaginaryUnit<> * this->get_correlation() * this->get_sigma_v() * x.array();
        SDEComplexVector exp2 = gamma.array() - this->get_kappa() + ImaginaryUnit<> * this->get_correlation() * this->get_sigma_v() * x.array();
        SDEComplexVector A = (this->get_kappa() * this->get_theta() / (this->get_sigma_v() * this->get_sigma_v())) * ((this->get_kappa() - gamma.array() -
                            ImaginaryUnit<> * this->get_correlation() * this->get_sigma_v() * x.array()) * t - 2 *((exp1.array() + exp2.array() * (-gamma.array() * t).exp())/
                            (exp1.array() + exp2.array())).log()).matrix();



        SDEComplexVector B_func_out;

        {
        const auto& x_arr = x.array();
        const auto& gamma_arr = gamma.array();
        const T one = T(1.0);
        const T two = T(2.0);

        const auto& kappa = this->get_kappa();
        const auto& rho = this->get_correlation();
        const auto& sigma = this->get_sigma_v();

        auto i_x = ImaginaryUnit<> * x_arr;
        auto x_sq = x_arr.square();
        auto exp_gamma_t = (gamma_arr * t).exp();
        auto exp_gamma_t_minus1 = exp_gamma_t - one;

        // Numerator and denominator
        auto numerator = (x_sq + i_x) * exp_gamma_t_minus1;
        auto den_term1 = gamma_arr + kappa - ImaginaryUnit<> * rho * sigma * x_arr;
        auto denominator = den_term1 * exp_gamma_t_minus1 + two * gamma_arr;

        B_func_out = numerator / denominator;

        // Fallback correction mask: detect NaN or Inf using Eigen’s select expression
        Eigen::Array<bool, Eigen::Dynamic, 1> mask = 
            (!((B_func_out.array().real().isFinite()) && (B_func_out.array().imag().isFinite())));

        if (mask.any()) {
            // Precompute fallback only for required entries
            auto fallback_num = x_sq + i_x;
            auto fallback_den = gamma_arr + kappa - ImaginaryUnit<> * rho * sigma * x_arr;

            // Apply fallback using Eigen::select
            B_func_out = mask.select(fallback_num / fallback_den, B_func_out);
            }
        }


        charact_out = (A.array() - B_func_out.array() * Base::m_x0(0)).exp().matrix();

    }

};


/**
 * @brief Stein-Stein Model SDE implementation.
 * @tparam T Numeric type for computations (default: traits::DataType::PolynomialField).
 * This model is a specific case of the GenericSVModelSDE with p=1 and q=0.
 */
template<typename T = traits::DataType::PolynomialField>
class SteinSteinModelSDE : public GenericSVModelSDE<T> {
public:
    using Base = GenericSVModelSDE<T>;
    using Parameters = typename Base::Parameters;

    SteinSteinModelSDE(T asset_drift_const,
                   T sv_kappa,
                   T sv_theta,
                   T sv_sigma,
                   T correlation,
                    SDEVector x0)
        : Base(Parameters{
            asset_drift_const,
            sv_kappa,
            sv_theta,
            sv_sigma,
            correlation,
            static_cast<T>(1.0), // asset_vol_exponent p
            static_cast<T>(0.0)  // sv_vol_exponent q
        }, x0) {}

    std::shared_ptr<ISDEModel<T>> clone() const override {
        return std::make_shared<SteinSteinModelSDE<T>>(*this);
    }


};

/**
 * @brief Hull-White Model SDE implementation.
 * @tparam T Numeric type for computations (default: traits::DataType::PolynomialField).
 * This model is a specific case of the GenericSVModelSDE with p=1 and q=1.
 * It is commonly used in interest rate modeling.
 */
template<typename T = traits::DataType::PolynomialField>
class HullWhiteModelSDE : public GenericSVModelSDE<T> {
public:
    using Base = GenericSVModelSDE<T>;
    using Parameters = typename Base::Parameters;

    HullWhiteModelSDE(T asset_drift_const,
                   T sv_kappa,
                   T sv_theta,
                   T sv_sigma,
                   T correlation,
                   SDEVector x0)
        : Base(Parameters{
            asset_drift_const,
            sv_kappa,
            sv_theta,
            sv_sigma,
            correlation,
            static_cast<T>(1.0), // asset_vol_exponent p
            static_cast<T>(1.0)  // sv_vol_exponent q
        }, x0) {}
    
    std::shared_ptr<ISDEModel<T>> clone() const override {
        return std::make_shared<HullWhiteModelSDE<T>>(*this);
    }

};

/**
 * @brief Jacobi Model SDE implementation.
 * @tparam T Numeric type for computations (default: traits::DataType::PolynomialField).
 * This model is a specific case of the GenericSVModelSDE with p=1 and q=0.
 * It is used for modeling processes with bounded variance, such as in the Jacobi process.
 */
template<typename T = traits::DataType::PolynomialField>
class JacobiModelSDE : public GenericSVModelSDE<T> {

public:
    using Base = GenericSVModelSDE<T>;
    using Parameters = typename Base::Parameters;
    using Base::generator_G;                 // bring the base class generator_G into scope


    static constexpr unsigned int WIENER_DIM = 2; // Two correlated Wiener processes
    static constexpr unsigned int STATE_DIM = 2; // Two state variables (log-price and variance)

private:

    T y_min_;
    T y_max_;
    T q_denominator_sq_; // (sqrt(y_max) - sqrt(y_min))^2

    /**
     * @brief Computes the Q function for the Jacobi model.
     * @param y The input value for which to compute Q(y).
     * @return The computed value of Q(y).
     * 
     * This function computes the Q function for the Jacobi model, which is used to transform the variance process.
     * It ensures that the input value y is within the bounds defined by y_min and y_max, and handles cases where the denominator might be zero.
     * The Q function is defined as:
     * Q(y) = (y - y_min) * (y_max - y) / (sqrt(y_max) - sqrt(y_min))^2
     * 
     * If the denominator is zero (which can happen if y_max is very close to y_min), it returns 0.0 to avoid division by zero.
     * The function also clamps the input value y to ensure it stays within the bounds [y_min, y_max].
     */
    inline T Q_func(const T y) const {

        if (q_denominator_sq_ <= 0) return 0.0; // Avoid division by zero if y_max approx y_min

        // Ensure y is within bounds for Q(y) to be non-negative, or handle appropriately
        // The SDE formulation usually assumes Y_t stays within [y_min, y_max]

        T y_clamped = std::max(y_min_, std::min(y, y_max_));
        return (y_clamped - y_min_) * (y_max_ - y_clamped) / q_denominator_sq_;

    }

    /**
     * @brief Computes the Q function for a matrix of values.
     * @param y The input matrix for which to compute Q(y).
     * @return An Eigen::Array containing the computed values of Q(y) for each element in the input matrix.
     * 
     * This function computes the Q function for each element in the input matrix y, which is expected to be an Eigen::MatrixBase type.
     * It ensures that the input values are clamped within the bounds defined by y_min and y_max, and handles cases where the denominator might be zero.
     * The Q function is defined as:
     * Q(y) = (y - y_min) * (y_max - y) / (sqrt(y_max) - sqrt(y_min))^2
     * 
     * If the denominator is zero (which can happen if y_max is very close to y_min), it returns an array of zeros with the same shape as the input matrix.
     * The function uses Eigen's array operations for efficient computation and broadcasting.
     * 
     * @tparam Derived The type of the Eigen matrix (must be derived from Eigen::MatrixBase).
     * @return An Eigen::Array containing the computed values of Q(y) for each element in the input matrix.
     * 
     * This function is useful for vectorized operations where the Q function needs to be applied to multiple values simultaneously.
     * It leverages Eigen's capabilities for efficient computation and broadcasting, making it suitable for large datasets.
     * 
     * @note The function assumes that the input matrix y is compatible with the defined bounds [y_min, y_max].
     * If the input values exceed these bounds, they will be clamped to ensure valid computations.
     */
    template<typename Derived>
    Eigen::Array<typename Derived::Scalar,
                Derived::RowsAtCompileTime,
                Derived::ColsAtCompileTime>
    Q_func(const Eigen::MatrixBase<Derived>& y) const
    {
        using R = typename Derived::Scalar;
        using ReturnType = Eigen::Array<R, Derived::RowsAtCompileTime, Derived::ColsAtCompileTime>;

        if (q_denominator_sq_ <= R(0)) {
            // materialize the Zero() expression to the concrete ReturnType
            return ReturnType::Zero(y.rows(), y.cols()).eval();
        }

        // work in array-space for broadcasting with scalars
        ReturnType y_arr = y.array().template cast<R>().eval();
        ReturnType y_clamped = y_arr.min(R(y_max_)).max(R(y_min_)).eval();

        return ((y_clamped - R(y_min_)) * (R(y_max_) - y_clamped) / R(q_denominator_sq_)).eval();
    }

    /**
     * @brief Computes the first and second derivatives of the Q function with respect to y.
     * @param y The input value for which to compute the derivatives.
     * @return The computed first derivative of Q(y) with respect to y.
     * 
     * This function computes the first derivative of the Q function for the Jacobi model, which is used to transform the variance process.
     * It ensures that the input value y is within the bounds defined by y_min and y_max, and handles cases where the denominator might be zero.
     * The first derivative is defined as:
     * Q'(y) = (y_max - 2y + y_min) / (sqrt(y_max) - sqrt(y_min))^2
     * 
     * If the denominator is zero (which can happen if y_max is very close to y_min), it returns 0.0 to avoid division by zero.
     * The function also clamps the input value y to ensure it stays within the bounds [y_min, y_max]. 
     */
    
    inline T Q_func_der1(const T y) const {

        if (q_denominator_sq_ <= 0) return 0.0; 

        

        T y_clamped = std::max(y_min_, std::min(y, y_max_));
        return  (y_max_ - static_cast<T>(2.0)*y_clamped + y_min_) / q_denominator_sq_;

    }


    /**
     * @brief Computes the second derivative of the Q function with respect to y.
     * @param y The input value for which to compute the second derivative.
     * @return The computed second derivative of Q(y) with respect to y.
     * 
     * This function computes the second derivative of the Q function for the Jacobi model, which is used to transform the variance process.
     * It ensures that the input value y is within the bounds defined by y_min and y_max, and handles cases where the denominator might be zero.
     * The second derivative is defined as:
     * Q''(y) = -2 / (sqrt(y_max) - sqrt(y_min))^2
     * 
     * If the denominator is zero (which can happen if y_max is very close to y_min), it returns 0.0 to avoid division by zero.
     * The function also clamps the input value y to ensure it stays within the bounds [y_min, y_max].
     */
    inline T Q_func_der2(const T  y) const {

        if (q_denominator_sq_ <= 0) return 0.0; 

        

        return  -2/q_denominator_sq_;

    }

public:

    JacobiModelSDE(T asset_drift_const, 
            T sv_kappa,
            T sv_theta,
            T sv_sigma,
            T correlation,
            T y_min,
            T y_max,
            SDEVector x0)
    : Base(Parameters{asset_drift_const, sv_kappa, sv_theta, sv_sigma, correlation, static_cast<T>(1.0), static_cast<T>(1.0)}, x0),
      y_min_(y_min),y_max_(y_max)
        {
        if (this->get_correlation() < -1.0 || this->get_correlation() > 1.0) {
            throw std::invalid_argument("JacobiModelSDE: Rho must be between -1 and 1.");
        }

        if (y_min_ < 0.0 || y_max_ <= y_min_) {
            throw std::invalid_argument("JacobiModelSDE: Invalid y_min/y_max. y_min >= 0 and y_max > y_min required.");
        }

        if (this->get_theta() < y_min_ || this->get_theta() > y_max_) {
             std::cerr << "Warning: JacobiModelSDE: Theta is outside variance bounds [y_min, y_max].\n";
        }


        if (this->get_sigma_v() <= 0) {
            throw std::invalid_argument("JacobiModelSDE: Sigma (vol of vol factor) must be positive.");
        }

        if (this->get_kappa() < 0) {
             std::cerr << "Warning: JacobiModelSDE: Kappa (mean reversion speed) is negative.\n";
        }

        T sqrt_ymax = std::sqrt(y_max_);
        T sqrt_ymin = std::sqrt(y_min_);

        if (std::abs(sqrt_ymax - sqrt_ymin) < 1e-9) { // Handles y_max very close to y_min
             q_denominator_sq_ = 1.0; // Avoid division by zero, though Q(y) will be near zero

             if (y_max_ > y_min_)
                std::cerr << "Warning: JacobiModelSDE: y_max is very close to y_min, Q(y) might be ill-conditioned.\n";

        } else {

            q_denominator_sq_ = (sqrt_ymax - sqrt_ymin) * (sqrt_ymax - sqrt_ymin);

        }

    }


    inline void drift([[maybe_unused]] T t, const SDEVector& x_state, SDEVector& mu_out) const override {

        const T Y_t = x_state(0);


        // Drift for X_t (log-price)
        mu_out(1) = this->get_drift()  - Y_t * static_cast<T>(0.5);


        // Drift for Y_t
        mu_out(0) = this->get_kappa() * (this->get_theta() - Y_t);

    }

    inline void diffusion([[maybe_unused]] T t, const SDEVector& x_state, SDEMatrix& sigma_out) const override {

        const T Y_t = x_state(0); // Current variance process value


        T q_y = Q_func(Y_t);
        T sqrt_q_y = (q_y > 0.0) ? std::sqrt(q_y) : 0.0;


        T Y_minus_rho_sq_Q = Y_t - this->get_correlation() * this->get_correlation() * q_y;
        T sqrt_Y_minus_rho_sq_Q = (Y_minus_rho_sq_Q > 0.0) ? std::sqrt(Y_minus_rho_sq_Q) : 0.0;
        
        // dY_t = ... + sigma*sqrt(Q(Y_t))dW_1t

        // dX_t = ... + rho*sqrt(Q(Y_t))dW_1t + sqrt(Y_t - rho^2*Q(Y_t))dW_2t


        
        // Row 0: variance (Y_t) diffusion coefficients for dW1, dW2

        sigma_out(0, 0) = this->get_sigma_v() * sqrt_q_y;
        sigma_out(0, 1) = 0.0;

        // Row 1: log-price (X_t) diffusion coefficients for dW1, dW2

        sigma_out(1, 0) = this->get_correlation() * sqrt_q_y;
        sigma_out(1, 1) = sqrt_Y_minus_rho_sq_Q;


    }

    typename Base::SVPolyCoeffs build_sv_polynomials(
        int N) override
        {
        typename Base::SVPolyCoeffs out;

        const T C = q_denominator_sq_;
        const T vmin = y_min_;
        const T vmax = y_max_;

        // b_x(v) = μ - 0.5 v
        out.bx = SDEVector::Zero(N);
        out.bx[0] = this->get_drift();
        {
            if (1 < N)
                out.bx[1] = out.bx[1]  - T(0.5);
        }

        // a_xx(v) = v
        out.axx = SDEVector::Zero(N);
        {
            if (1 < N)
                out.axx[1] = T(1.0);
        }

        // b_v(v) = κ θ - κ v
        out.bv = SDEVector::Zero(N);
        out.bv[0] = this->get_kappa() * this->get_theta();
        if (1 < N)
            out.bv[1] = -this->get_kappa();

        // a_xv(v) = ρ σ Q(v)
        out.axv = SDEVector::Constant(N, this->get_correlation() * this->get_sigma_v());
        {
            out.axv[0] *= -vmin * vmax / C; // Adjust for the constant term
            if (1 < N)
                out.axv[1] *=  (vmin + vmax) / C; 
            if (2 < N)
                out.axv[2] /= -C; 
 
        }
        // a_vv(v) = σ² Q(v)
        out.avv = SDEVector::Constant(N, this->get_sigma_v() * this->get_sigma_v());
        {
            out.avv[0] *= -vmin * vmax / C; // Adjust for the constant term
            if (1 < N)
                out.avv[1] *= (vmin + vmax) / C; 
            if (2 < N)
                out.avv[2] /= -C; 
 
        }

        return out;
    }

    SDEMatrix generator_G(std::vector<std::pair<int,int>> E, int N, T sigma) const override{
        const int M = static_cast<int>(E.size());

        // Fast index lookup
        Utils::IndexMap idx;
        idx.reserve(M);
        for (int i = 0; i < M; ++i) {
            const auto& [m, n] = E[i];
            idx.emplace(key(m, n), i);
        }

        SDEMatrix G = SDEMatrix::Zero(M, M);
        

        const T C = q_denominator_sq_;
        const T vmin = y_min_;
        const T vmax = y_max_;
        const T kappa = this->get_kappa();
        const T theta = this->get_theta();
        const T r = this->get_drift();
        const T sigma_v = this->get_sigma_v();
        const T rho = this->get_correlation();

        auto add_entry = [&](int row_m, int row_n, int col, T value) {
            if (row_m < 0 || row_n < 0) return;
            if (row_m + row_n > N) return; // out of basis range
            auto it = idx.find(key(row_m, row_n));
            if (it != idx.end()) {
                G(it->second, col) = value;
            }
        };

        for (int col = 0; col < M; ++col) {
            const auto [m, n] = E[col];


            // 1) h_{m-2, n}
            if (m >= 2) {

                add_entry(m-2, n, col, -sigma_v * sigma_v * m * (m - 1) * vmax * vmin / (2.0 * C));
            }
            // 2) h_{m-1, n-1}
            if (m >= 1 && n >= 1) {

                add_entry(m-1, n-1, col, -rho * sigma_v * m * std::sqrt((T)n) / sigma * vmax * vmin / C);
            }
            // 3) h_{m-1, n}
            if (m >= 1) {

                add_entry(m-1, n, col, m * kappa * theta + sigma_v * sigma_v * m * (m - 1) * (vmax + vmin) / (2.0 * C));
            }
            // 4) h_{m, n-1}
            if (n >= 1) {

                add_entry(m, n-1, col, std::sqrt((T)n) / sigma * (r   + m * rho * sigma_v * (vmax + vmin) / C));
            }
            // 5) h_{m+1, n-2}
            if (n >= 2) {

                add_entry(m+1, n-2, col, std::sqrt((T)n * (n - 1)) / (2.0 * sigma * sigma));
            }
            // 6) h_{m, n}
            add_entry(m, n, col, -m * kappa - sigma_v * sigma_v * m * (m - 1) / (2.0 * C));
            // 7) h_{m+1, n-1}
            if (n >= 1) {
        
                add_entry(m+1, n-1, col, -std::sqrt((T)n) / (2.0 * sigma) - rho * sigma_v * m * std::sqrt((T)n) / (sigma * C));
            }
        }

        return G;
    }

    std::shared_ptr<ISDEModel<T>> clone() const override {
        return std::make_shared<JacobiModelSDE<T>>(*this);
    }

    inline SDEVector M_T(T ttm, T dt, const SDEMatrix& y_t, const SDEMatrix& w_t) {
            const auto n = y_t.cols();
            const auto k = y_t.rows();

            // Quick sanity check
            assert(w_t.cols() == n - 1 && w_t.rows() == k && "y_t and w_t must have same shape");
            // Precompute .matrix() view once
            const auto& y_mat = y_t.matrix();
            const auto& w_mat = w_t.matrix();

            // Precompute powers
            auto y_t_vol   = Q_func(y_mat).array().sqrt().matrix().eval(); // Use eval to get rid of lazy evaluation
 
            // 1. Trapezoidal rule
            auto trap_block1 = y_mat.array().block(0, 0, k, n - 1);
            auto trap_block2 = y_mat.array().block(0, 1, k, n - 1);
            auto trap = -static_cast<T>(0.25) * dt * (trap_block1 + trap_block2).rowwise().sum();

            // 2. Vanilla stochastic integral
            auto stoch = this->get_correlation() * y_t_vol.block(0, 0, k, n - 1).cwiseProduct(w_t).rowwise().sum();

            // 3. IJK term
            auto w_sq_minus_dt = w_mat.array().square() - dt;
            auto ijk = this->get_correlation() * static_cast<T>(0.5) * this->get_sigma_v()
                    * y_t_vol.block(0, 0, k, n - 1).cwiseProduct(w_sq_minus_dt.matrix()).rowwise().sum();

            // Final result
            auto result = Base::get_x0()
                        + this->get_drift() * ttm
                        + trap.array() + stoch.array() + ijk.array();

            return result;
        };

    inline SDEVector C_T([[maybe_unused]] T ttm, T dt, const SDEMatrix& y_t) {
        const auto n = y_t.cols();
        const auto k = y_t.rows();

        // Precompute .matrix() view once
        const auto& y_mat = y_t.matrix();


        // Precompute powers
        auto y_t_asset = (y_mat - this->get_correlation() * this->get_correlation() * Q_func(y_mat).matrix()).eval(); // Use Q_func for variance process

        std::cout << "y_t_asset:\n" << Q_func(y_mat) << std::endl;

        // 1. Trapezoidal rule
        auto trap_block1 = y_t_asset.block(0, 0, k, n - 1);
        auto trap_block2 = y_t_asset.block(0, 1, k, n - 1);
        std::cout << "n = " << n << ", k = " << k << "\n";
        std::cout << "trap_block1:\n" << trap_block1 << "\n";
        std::cout << "trap_block2:\n" << trap_block2 << "\n";



        auto trap = static_cast<T>(0.5) * dt * (trap_block1 + trap_block2).rowwise().sum();

        // Final result
        auto result = trap.array();

        return result;
    };

    /**
     * @brief Getters for the y_min parameter.
     * Minimum bound for the variance process in the Jacobi model.
     * It is useful for retrieving the lower bound without exposing the entire model parameters.
     * 
     * @return The minimum bounds for the variance process.
     */
    inline T get_y_min() const noexcept {
        return y_min_;
    };
    
    /**
     * @brief Getters for the y_max parameter.
     * This method provides access to the maximum bound for the variance process in the Jacobi model.
     * It is useful for retrieving the upper bound without exposing the entire model parameters.
     * 
     * @return The maximum bound for the variance process.
     */
    inline T get_y_max() const noexcept {
        return y_max_;
    };



};




}

#endif // FINMODELS_HPP./include/sde/SDE.hpp

/**
 * @file SDE.hpp
 * @brief Stochastic Differential Equation (SDE) solver framework with support for multiple numerical schemes.
 *
 * This header defines a flexible and extensible framework for simulating SDEs using various numerical methods,
 * including Euler-Maruyama, Milstein, and Interpolated Kahl-Jackel schemes. The framework leverages C++20 concepts
 * for compile-time constraints, Eigen for linear algebra, and OpenMP for parallelism.
 *
 * Key Features:
 * - Thread-local random number generation utilities for reproducible and parallel-safe simulations.
 * - Strongly-typed SDE model concepts (SDEModel, SVSDEModel, Milstein1DSDEModel, Milstein2DSVSDEModel) for compile-time validation.
 * - CRTP-based base solver class (SDESolverBase) for static polymorphism and code reuse.
 * - Concrete solver implementations for Euler-Maruyama, Milstein, and Interpolated Kahl-Jackel methods.
 * - Support for multi-path, multi-step simulations with observer callbacks and optional pre-generated Wiener increments.
 * - Full truncation to ensure non-negativity of state variables where appropriate.
 *
 * Template Parameters:
 * - SdeType: The SDE model type, which must satisfy the relevant SDEModel concept.
 * - R: Scalar type for computations (default: traits::DataType::PolynomialField).
 *
 * Dependencies:
 * - OPOE_traits.hpp: For type definitions and concepts.
 * - Utils.hpp: For utility functions and type traits.
 *
 * Usage:
 * 1. Define an SDE model class satisfying the required concept(s).
 * 2. Instantiate a solver (e.g., EulerMaruyamaSolver, MilsteinSolver) with the model.
 * 3. Call `solve()` to simulate paths, optionally providing pre-generated Wiener increments.
 */
#ifndef SDE_HPP
#define SDE_HPP

#include <cmath>        
#include <concepts>     
#include <iostream>     
#include <random>       
#include <stdexcept>   
#include <thread>       
#include <optional>       
#include "../traits/OPOE_traits.hpp"
#include "../utils/Utils.hpp"


namespace SDE {
using SDEVector = traits::DataType::StoringVector; // Eigen::VectorXd or similar
using SDEComplexVector = traits::DataType::ComplexStoringVector; // Eigen::VectorXcd or similar
using SDEMatrix = traits::DataType::StoringMatrix; // Eigen::MatrixXd or similar
using SDEArray = traits::DataType::StoringArray;   // SDEArray or similar
/**

 * @brief Returns a reference to a thread-local Mersenne Twister engine for random number generation.
 * @return Reference to thread-local std::mt19937 engine, seeded with std::random_device.

 */
inline std::mt19937& get_default_rng_engine() {
    // Get time since epoch in nanoseconds
    auto now = std::chrono::high_resolution_clock::now();
    auto nanos = std::chrono::duration_cast<std::chrono::nanoseconds>(now.time_since_epoch()).count();

    // Combine with thread ID hash
    size_t thread_hash = std::hash<std::thread::id>{}(std::this_thread::get_id());

    // Mixed seed
    unsigned int seed = static_cast<unsigned int>(nanos ^ thread_hash);

    static thread_local std::mt19937 engine(seed);
    return engine;
}

/**

 * @brief Returns a reference to a thread-local standard normal distribution.
 * @tparam R Scalar type for the distribution (default: traits::DataType::PolynomialField).
 * @return Reference to thread-local std::normal_distribution<double> with mean 0 and std dev 1.

 */
template<typename R = traits::DataType::PolynomialField>
inline std::normal_distribution<R>& get_standard_normal_dist() {

    static thread_local std::normal_distribution<R> standard_normal(0.0, 1.0);
    return standard_normal;

}

/**
 * @brief Returns a reference to a thread-local uniform distribution on [0, 1).
 * @tparam R Scalar type for the distribution (default: traits::DataType::PolynomialField).
 * @return Reference to thread-local std::uniform_real_distribution<double>.
 */
template<typename R = traits::DataType::PolynomialField>
inline std::uniform_real_distribution<R>& get_uniform_distribution() {

    static thread_local std::uniform_real_distribution<R> uniform_distribution(0.0, 1.0);
    return uniform_distribution;

}

// --- SDE Concepts for Compile-Time Constraints ---

/** 
 * @brief Concept for general SDE models, ensuring dimensional constants and drift/diffusion methods.
 */
template<typename T, typename R = traits::DataType::PolynomialField>
concept SDEModel = requires(const T& sde, R t, const SDEVector& x, SDEVector& mu_out, SDEMatrix& sigma_out) {
    
    sde.drift(t, x, mu_out);       // Drift function must write to mu_out
    sde.diffusion(t, x, sigma_out); // Diffusion function must write to sigma_out

};



/**
 * @brief Concept for Stochastic Volatility (SV) SDE models, extending SDEModel with SV-specific parameters.
 */
template<typename T, typename R = traits::DataType::PolynomialField>
concept SVSDEModel = SDEModel<T, R> && requires(const T& sde) {
    

    { sde.get_correlation() } -> std::convertible_to<R>; // Correlation parameter (rho)
    { sde.get_kappa() } -> std::convertible_to<R>;       // Mean-reversion speed
    { sde.get_theta() } -> std::convertible_to<R>;       // Long-term variance/mean
    { sde.get_sigma_v() } -> std::convertible_to<R>;     // Volatility of volatility
    { sde.get_mu() } -> std::convertible_to<R>;          // Drift or risk-neutral rate
    { sde.get_p() } -> std::convertible_to<R>;           // Power parameter for volatility (if applicable)
    { sde.get_q() } -> std::convertible_to<R>;           // Additional power parameter (if applicable)
};

/**
 * @brief Concept for 1D SDEs supporting Milstein scheme, requiring derivative information.
 */

template<typename T, typename R = traits::DataType::PolynomialField>
concept Milstein1DSDEModel = SDEModel<T, R> && requires(const T& sde, R t, R x_scalar) {

    requires T::WIENER_DIM == 1;
    requires T::STATE_DIM >= 1;

};

/** 
 * @brief Concept for 2D Stochastic Volatility SDEs supporting Milstein scheme.
 */

template<typename T, typename R = traits::DataType::PolynomialField>
concept Milstein2DSVSDEModel = SDEModel<T> && requires(const T& sde, R t, const SDEVector& x) {

    requires T::WIENER_DIM == 2;// Two Wiener processes
    requires T::STATE_DIM >= 2;

};



// --- Base SDE Solver Class using CRTP ---

/**
 * @brief Base class for SDE solvers using CRTP for static polymorphism.
 * @tparam DerivedSolver The derived solver class (CRTP pattern).
 * @tparam SdeType The SDE model type satisfying SDEModel concept.
 * @tparam R Scalar type for computations (default: traits::DataType::PolynomialField).
 */


template <typename DerivedSolver, SDEModel SdeType,  typename R = traits::DataType::PolynomialField>
class SDESolverBase {
public:
    SDESolverBase(const SdeType& sde, std::mt19937& rng_engine = SDE::get_default_rng_engine())
        : sde_ref_(sde), rng_engine_ref_(rng_engine) {}

    virtual ~SDESolverBase() = default;

    /**
     * @brief Generates Wiener process increments for simulation.
     * @param dt Time step size.
     * @param dW_out Matrix to store increments (WIENER_DIM x num_steps).
     * @param num_steps Number of time steps.
     * @param num_paths Number of paths to simulate.
     * @throws std::invalid_argument if dt is negative.
     *
     * This method generates independent Wiener increments for each path and stores them in dW_out.
     * If dt is zero, it initializes dW_out to zero.
     */
    void generate_wiener_increments(R dt, SDEMatrix& dW_out, int num_steps, int num_paths) const {
        if (dt < 0.0) throw std::invalid_argument("dt must be non-negative");

        if (dt == 0.0) {
            dW_out.setZero(num_paths * sde_ref_.wiener_dim(), num_steps);
            return;
        }

        const int num_wiener = sde_ref_.wiener_dim();
        const R sqrt_dt = std::sqrt(dt);


        #pragma omp parallel for
        for (int w = 0; w < num_wiener; ++w) {
            // Unique seed per Wiener dimension
            SDEMatrix block = Utils::sampler<R>(
                get_default_rng_engine(),
                SDE::get_standard_normal_dist<R>(),
                num_paths, num_steps
            ) * sqrt_dt;

            // Write the block into the correct location of dW_out
            dW_out.block(w * num_paths, 0, num_paths, num_steps) = block;

        }
}
    /**
     * @brief Solves the SDE path and invokes an observer at each step.
     * @param t_start Starting time.
     * @param t_end Ending time.
     * @param num_steps Number of time steps.
     * @param num_paths Number of paths to simulate.
     * @param observer Callback function with signature void(double time, const SDEVector& state).
     * @param dW_opt Optional pre-generated Wiener increments (if provided, must match num_paths and num_steps).
     * @throws std::invalid_argument if initial state size does not match SDE model dimensions.
     * @throws std::invalid_argument if num_steps is non-positive or t_end <= t_start.
     *
     * This method simulates the SDE over the specified time range and invokes the observer callback
     * at each step with the current time and state vector.
     */

    void solve(R t_start, R t_end, int num_steps, int num_paths,
           const std::function<void(unsigned int, const SDEVector&)>& observer, 
           const std::optional<SDEMatrix>& dW_opt = std::nullopt) const {
            
        if (sde_ref_.m_x0.size() != sde_ref_.state_dim()) 
            throw std::invalid_argument("initial_x must have STATE_DIM");

        if (num_steps <= 0 || t_end <= t_start)
            throw std::invalid_argument("Invalid time range or num_steps");

        R dt = (t_end - t_start) / num_steps;

        // Flattened state vector: num_paths * STATE_DIM
        SDEVector current_x(num_paths * sde_ref_.state_dim());

        // initial_x is a column vector: [0.25, 100]
        SDEMatrix initial_states = sde_ref_.m_x0.transpose().replicate(num_paths, 1); 
        current_x = Eigen::Map<SDEVector>(initial_states.data(), initial_states.size());   
        SDEVector next_x(num_paths * sde_ref_.state_dim());

        // dW is matrix: (num_paths * WIENER_DIM, num_steps)
        SDEMatrix dW;

    
        if (dW_opt.has_value()) {

            assert(dW_opt->rows() == num_paths * sde_ref_.wiener_dim() && dW_opt->cols() == num_steps);
            dW = dW_opt.value();

        } else {

            dW.resize(num_paths * sde_ref_.wiener_dim(), num_steps);
            generate_wiener_increments(dt, dW, num_steps, num_paths);

        }
        
        
        

        R current_t = t_start;
        observer(0, current_x);

        for (int i = 0; i < num_steps; ++i) {
            
            this->derived().step(current_t, current_x, dt, dW.col(i), num_paths, next_x);
            current_x = next_x;
            current_t += dt;
            if (i == num_steps - 1) current_t = t_end;
            observer(i + 1, current_x);
        }
    }


    /**
     * @brief Solves the SDE and returns the full path.
     * @return Vector of state vectors at each time step (size num_steps + 1).
     */

    SDEMatrix solve(R t_start, R t_end, int num_steps, int num_paths,
                    const std::optional<SDEMatrix>& dW_opt = std::nullopt) const {
        SDEMatrix path_flat(num_paths * sde_ref_.state_dim(), num_steps + 1);
        solve(t_start, t_end, num_steps, num_paths,
            [&path_flat](unsigned int idx, const SDEVector& x) { path_flat.col(idx) = x; },
            dW_opt);
        return path_flat;
    }

protected:

    const SdeType& sde_ref_;
    std::mt19937& rng_engine_ref_;
    const DerivedSolver& derived() const { return *static_cast<const DerivedSolver*>(this); }
    DerivedSolver& derived() { return *static_cast<DerivedSolver*>(this); }

};



// --- Concrete Solver Implementations ---

// --- Euler-Maruyama Solver Implementation ---

/**
 * @brief Euler-Maruyama solver for general SDEs, a first-order method.
 * @tparam SdeType SDE model type satisfying SDEModel concept.
 * @tparam R Scalar type for computations (default: traits::DataType::PolynomialField).
 */

template <SDEModel SdeType,  typename R = traits::DataType::PolynomialField>
class EulerMaruyamaSolver : public SDESolverBase<EulerMaruyamaSolver<SdeType>, SdeType, R> {
public:
    using Base = SDESolverBase<EulerMaruyamaSolver<SdeType>, SdeType, R>;
    using Base::Base;

void step(
    R t, const SDEVector& current_x, R dt, const SDEVector& dW_t,
    int num_paths, SDEVector& next_x
    ) const {
        const int state_dim = this->sde_ref_.state_dim();
        const int wiener_dim = this->sde_ref_.wiener_dim();

        #pragma omp parallel
        {
        // Thread-local storage for temporary buffers to avoid heap allocations
        SDEVector mu(state_dim);
        SDEMatrix sigma(state_dim, wiener_dim);

        #pragma omp for 
        for (int p = 0; p < num_paths; ++p) {
            const int offset = p * state_dim;

            // Map current and next state slices
            Eigen::Map<const SDEVector> x_p(current_x.data() + offset, state_dim);
            Eigen::Map<SDEVector> next_x_p(next_x.data() + offset, state_dim);
            
            // Compute drift and diffusion
            this->sde_ref_.drift(t, x_p, mu);
            this->sde_ref_.diffusion(t, x_p, sigma);


            // Map dW for this path, spaced by num_paths per Wiener dimension
            Eigen::Map<const SDEVector, 0, Eigen::InnerStride<>> dW_p(dW_t.data() + p, wiener_dim, Eigen::InnerStride<>(num_paths));

            // Euler-Maruyama update
            next_x_p.noalias() = x_p + mu * dt + sigma * dW_p;



        }
    }
    // Full truncation to ensure non-negativity of volatility
    next_x = next_x.cwiseMax(1e-4);



    }



};


// --- Milstein Solver Implementation ---

/**
 * @brief Milstein solver for SDEs, a higher-order method using derivative information.
 * @tparam SdeType SDE model type satisfying SDEModel concept.
 * @tparam R Scalar type for computations (default: traits::DataType::PolynomialField).
 */

template <SDEModel SdeType,  typename R = traits::DataType::PolynomialField>
class MilsteinSolver : public SDESolverBase<MilsteinSolver<SdeType>, SdeType,  R> {

public:

    using Base = SDESolverBase<MilsteinSolver<SdeType>, SdeType>;
    using Base::Base;

    void step(R t, const SDEVector& current_x, R dt, const SDEVector& dW_t, int num_paths, SDEVector& next_x) const {

        const int state_dim = this->sde_ref_.state_dim();
        const int wiener_dim = this->sde_ref_.wiener_dim();

        #pragma omp parallel
        {
        // Thread-local working memory
        SDEVector mu(state_dim);
        SDEMatrix sigma(state_dim, wiener_dim);

        // Optional buffers for Milstein models
        SDEVector drift_prime_at_x(state_dim);
        SDEMatrix sigma_prime_at_x(state_dim, wiener_dim);
        SDEMatrix sigma_second_at_x(state_dim, wiener_dim);

        #pragma omp for
        for (int p = 0; p < num_paths; ++p) {
            const int offset = p * state_dim;

            Eigen::Map<const SDEVector> x_p(current_x.data() + offset, state_dim);
            Eigen::Map<SDEVector> next_x_p(next_x.data() + offset, state_dim);

            this->sde_ref_.drift(t, x_p, mu);
            this->sde_ref_.diffusion(t, x_p, sigma);

            // Map dW for this path, spaced by num_paths per Wiener dimension
            Eigen::Map<const SDEVector, 0, Eigen::InnerStride<>> dW_p(
                dW_t.data() + p, // start at row=p
                wiener_dim,
                Eigen::InnerStride<>(num_paths)
            );

            next_x_p.noalias() = x_p + mu * dt + sigma * dW_p;

            // Milstein correction term:
            if constexpr (Milstein1DSDEModel<SdeType>) {
            // This block is only compiled if SdeType meets the Milstein1DSDEModel concept.

            this->sde_ref_.drift_derivative_x(t, x_p, drift_prime_at_x);
            this->sde_ref_.diffusion_derivative_x(t, x_p, sigma_prime_at_x);
            this->sde_ref_.diffusion_second_derivative_x(t, x_p, sigma_second_at_x);

            const SDEMatrix correction = 0.5 * sigma
                .cwiseProduct(sigma_prime_at_x
                .cwiseProduct((dW_p.array().square() - dt).matrix()));            
            const SDEMatrix correction_two = 
            (1.0 / 6.0) *
            (
                sigma
                    .cwiseProduct(sigma_prime_at_x)
                    .cwiseProduct(sigma_prime_at_x)
                + 
                sigma_second_at_x
                    .cwiseProduct(sigma)
                    .cwiseProduct(sigma)
            ).cwiseProduct(dW_p.array().cube().matrix());
            const SDEMatrix term1_3 = sigma.array().colwise() * drift_prime_at_x.array(); // σ · μ'
            const SDEMatrix term2_3 = sigma_prime_at_x.array().colwise() * mu.array();    // σ' · μ
            const SDEMatrix term3_3 = sigma
                .cwiseProduct(sigma_prime_at_x)
                .cwiseProduct(sigma_prime_at_x);                                              // σ · σ'^2
            const SDEMatrix term4_3 = 0.5 * sigma_second_at_x
                .cwiseProduct(sigma)
                .cwiseProduct(sigma);                                                     // 0.5 · σ'' · σ²
            const SDEMatrix correction_three = 0.5 * (term1_3 + term2_3 - term3_3 - term4_3)
                .cwiseProduct(dW_p) * dt;

        

            next_x_p.noalias() += (correction + correction_two + correction_three);
        }

        if constexpr (Milstein2DSVSDEModel<SdeType>) {

            // This block is only compiled if SdeType meets the Milstein1DSDEModel concept        
            const R pEXP = this->sde_ref_.get_p();
            const R q = this->sde_ref_.get_q();
            const R rho = this->sde_ref_.get_correlation();
            const R rho_p = std::sqrt(1.0 - rho * rho);
            const R sigma_v = this->sde_ref_.get_sigma_v();
            auto Q = Utils::sampler<R>(get_default_rng_engine(), get_uniform_distribution<R>(), 1);

            // It computes the Levy integral correction term
            const R X = dt / M_PI * std::log(Q(0)/(1.0 - Q(0))); // X is the log-normal variable
            const R Y = std::sqrt((dW_p(1)*dW_p(1) + dW_p(0)*dW_p(0))*dt/3)* Utils::sampler<R>(get_default_rng_engine(), get_standard_normal_dist<R>(), 1)(0);
            
            const R double_integral = 0.5 * dW_p(1) * dW_p(0) - 0.5 * (X + Y); // Integral term for the correction
            const R correction_vol = sigma_v * pEXP * std::pow(x_p(0), pEXP + q - 1) *
            (rho_p * double_integral + rho * 0.5 * (dW_p(0) * dW_p(0) - dt));

            
            next_x_p(0) += correction_vol;
        } 
           

        }
    }

    next_x = next_x.cwiseMax(1e-4); // Full truncation to ensure non-negativity
};
};

// --- Interpolated Kahl-Jackel Solver Implementation ---

/**
 * @brief Interpolated Kahl-Jackel solver for stochastic volatility SDEs.
 * @tparam SdeType SDE model type satisfying SDEModel concept.
 * @tparam R Scalar type for computations (default: traits::DataType::PolynomialField).
 */
template <SDEModel SdeType, typename R = traits::DataType::PolynomialField>
class InterpolatedKahlJackelSolver : public SDESolverBase<InterpolatedKahlJackelSolver<SdeType>, SdeType,  R> {
public:
    using Base = SDESolverBase<InterpolatedKahlJackelSolver<SdeType>, SdeType, R>;
    using Base::Base;

    void step(R t_current, const SDEVector& current_x,
              R dt, const SDEVector& dW_t, int num_paths,
              SDEVector& next_x) const {
        
        EulerMaruyamaSolver<SdeType> euler_solver(this->sde_ref_, this->rng_engine_ref_);
        euler_solver.step(t_current, current_x, dt, dW_t, num_paths, next_x);


        if constexpr (Milstein2DSVSDEModel<SdeType>) {
            const R pEXP = this->sde_ref_.get_p();
            const R q = this->sde_ref_.get_q();
            const R rho = this->sde_ref_.get_correlation();
            const R rho_p = std::sqrt(1.0 - rho * rho);
            const R sigma_v = this->sde_ref_.get_sigma_v();


            // Map to Eigen views
            Eigen::Map<const SDEArray, 0, Eigen::InnerStride<>> v_curr(current_x.data(), num_paths,  Eigen::InnerStride<>(this->sde_ref_.state_dim()));        
            Eigen::Map<const SDEArray, 0, Eigen::InnerStride<>> v_next(next_x.data(), num_paths,  Eigen::InnerStride<>(this->sde_ref_.state_dim()));    
    
            Eigen::Map<const SDEArray> dW0(dW_t.data(), num_paths);
            Eigen::Map<const SDEArray> dW1(dW_t.data() + num_paths, num_paths);

            // Compute all power terms once
            SDEArray v_pow_2p = v_curr.pow(2 * pEXP);
            SDEArray v_next_pow_2p = v_next.pow(2 * pEXP);
            SDEArray v_pow_p = v_curr.pow(pEXP);
            SDEArray v_next_pow_p = v_next.pow(pEXP);
            SDEArray v_pow_pm1 = v_curr.pow(pEXP - 1.0);


            // Full correction formula
            SDEArray correction_ijk = 
                -0.25 * (v_pow_2p + v_next_pow_2p) * dt
                + rho * v_pow_p * dW0
                + 0.5 * rho_p * (v_pow_p + v_next_pow_p) * dW1
                + 0.5 * rho * rho_p * v_pow_pm1 * sigma_v * (dW0.square() - dt);


            
            Eigen::Map<SDEArray, 0, Eigen::InnerStride<>> x_next(next_x.data() + 1, num_paths,  Eigen::InnerStride<>(this->sde_ref_.state_dim()));   
      
            x_next += correction_ijk;

    }
    }
};



} // namespace SDE

#endif // SDE_HPP